<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<title>Grafika</title>
	 <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1250">
 	 <meta name="Content-language" content="sk">	
	  <LINK href="../css/style.css" type="text/css" rel=stylesheet>
	<script>
        var canvas; var context;
		var x; var y;
		var x1=[0]; var y1=[0]; var pu=0;
		var x2=[0]; var y2=[0];
		var farba=[0];
		var dole=0;
		function init()
		{	canvas = document.getElementById("platno");
   			if (canvas.getContext) 
   			{ context = canvas.getContext("2d");
				context.fillStyle = "#a8c101";
    			context.fillRect(0, 0, 800, 600); }
			f.style.backgroundColor="#000000";	
		}		
        function mdole(xs,ys)
		{ dole=1;
		  x1[pu]=xs;y1[pu]=ys;
		  farba[pu]=f.style.backgroundColor; 
		}
		function mhore(xs,ys)
		{ dole=0;
		  x2[pu]=xs;y2[pu]=ys;
		  pu++; 
		}
		function rect(xs,ys)
		{ if(dole)
		   {x2[pu]=xs; y2[pu]=ys;
		    context.fillStyle = "#a8c101";
		     context.fillRect(0, 0, 800, 600); 
           for (i=0;i<=pu;i++)
		   { 
		    context.fillStyle = farba[i];
		     context.fillRect(x1[i],y1[i],x2[i]-x1[i],y2[i]-y1[i]); 
		   }
		   }
		}
		</script>  
</head>

<body  onload="init();">
<center><h3 class=nadpis>Kreslenie plôch myšou</h3></center>
<dl><dt class=main>Úvod
	<dd>Urèite ste sa stretli s nejakım rastrovım grafickım programom, ktorı umoòuje kresli obrázky (napr. MsPain).
		Kreslenie plôch (kruhou, obdånikov, ...) tam prebieha nasledovne:
		<ul><li>uívate¾ zvolí miesto, kde bude plocha zaèína a stlaèí tam ¾avé tlaèítko myši
			<li>ahaním/posúvaním myši vzniká "doèasnı" plošnı útvar
				<br>pri kadom posunutí "starı" plošnı objekt zanikne a "novı" sa vykreslí
			<li>po uvo¾není tlaèítka myši je plošnı útvar nakreslenı definitívne a u sa nedá "naahova"
		</ul>
		Cie¾om tejto lekcie bude ukáza si základné myšlienky, ako tento efekt dosiahnu 
	<dt>Udalosti súvisiace s myšou
	<dd>Na grafickej ploche mono ošetrova 3 rôzne udalosti súvisiace s myšou: 
		<ul><li>onMouseDown - zatlaèili sme nad plochou niektoré tlaèidlo myši 
			<li>onMouseMove - myš sa hıbe nad plochou 
			<li>onMouseUp - pustili sme tlaèidlo myši 
		</ul>	
	<dt>Jednoduchım ahaním myši kreslíme obdånik
	<dd>Kreslenie "na prvı pokus" sa v praxi pouíva menej ale jednoducho sa programuje. Myšlienka je nasledovná:
	<br>stlaèíme myš a natiahneme obdånik - zväèšova moono ale zmenši nejde - po pustení myši je obdånik ukonèenı.
		Na testovanie vyuijeme parameter Shift: je typu TShiftState (èo je vlastne mnoina zatlaèenıch "vıznamnıch" tlaèítok)
		 <br>type TShiftState = set of (ssShift,ssAlt,ssCtrl,ssLeft,ssRight,ssMiddle,ssDouble);
		 <br>Tlaèítko do mnoiny automaticky patrí ak je zatlaèené, ak ho uvo¾níme automaticky sa 
		 z tejto mnoiny vyradí. My budeme sledova ¾avé tlaèítko myši - ssLeft
		Na testovanie, èi prvok patrí do mnoiny sa pouíva metóda  <b>Contains</b>. 
		Pozri <a href="../02programujeme/mnoziny.html" target="_blank">mnoiny</a>
		Takto vyzerá program, ktorı kreslí len pri stlaèenom ¾avom tlaèítku myši
		<div style="border-width:3;border-style:outset;width:690px;margin:10px;background-color:#dddddd;">
   		<div align="left" style="background-color:#3366ff; width:690px; padding:0;border-width:0;color:white">Unit1.pas
   		</div>
   		<div style="background-color:#dddddd; width:690px;" >
   			<div style="margin:10px">
<pre>
void __fastcall TForm1::Image1MouseMove(TObject *Sender, TShiftState Shift, int X, int Y)
{
  if (Shift.Contains(ssLeft)) Image1->Canvas->Rectangle(xx,yy,X,Y) 
  else 
  { xx=X; yy:=Y; 
  }
}
</pre>	
		</div></div></div>
		Obdånik je hneï krelenı farbou vıplne a pera a nie je ho moné "naahovaním zmenšova. Skúste porozmıšla ako by program fungoval, 
		ak by sme nedali vetvu else - overte si, èi ste "uhádli".
	<dt>ahaním myši kreslíme obdånik
	<dd>Treba upozorni, e nasledovnı postup funguje pri pouití príkazu Rectangle ale pri FillRect nefunguje
	Tu potrebujeme kresli "doèasné" plochy, ktoré budú pri pohybe myši do nového koncového bodu miznú a nové sa zas kresli.
	<br>Na doèasné obdåniky nemáme poiadavky, e by mal by jednofarebné, hlavné aby sme ich vedeli odstráni 
		<br>Èo budeme k tomu potrebova:
		<ul><li>premenné
				<br>xx,yy - poloha zaèiatku našej plochy - napr. súradnica ¾avého horného rohu - (nastaví sa pri stlaèení ¾avého tlaèítka)
				<br>xs,ys - "stará" poloha koncového bodu úseèky napr. súradnica pravého dolného rohu - (nastaví sa po vykrelení "doèasnej" 
				plochy do nového koncového bodu	
			<li>techniku ako zotrie doèasnú plochu s tım, e sa obrazovka vráti do stavu v akom bola pred jej nakreslením. 
				Táto úloha sa zdá by aká, ale pomocou nastavenia Pen.Mode:=pmNot je to jednoduché riešenie.
				<br>(Je zvláštne, e nastavenie vlastnosti pera má vplyv na vıplò, ale funguje to) 
				<br>Vysvetlenie:
				<br>Ak kreslíme plochu v reime pmNot nekreslí sa farbou vıplne a pera (navolená farba vıplne a pera nemá na zobrazenú plochu vplyv)
				ale robí inverziu/negáciu podkladu (biely podlkad -&gt;èierna farba, zelenı podklad -&gt;fialová èiara).
				Z matematiky vieme, e ak urobíme 2-krát negáciu dostaneme pôvodnú hodnotu.
				<br>Èie ak druhı-krát nakreslíme tú istú plochu tak nám plocha korektne zmizne.
		</ul>		
		<br>A takto nejak by to mohlo by naprogramované:
		<div style="border-width:3;border-style:outset;width:800px;margin:10px;background-color:#dddddd;">
   		<div align="left" style="background-color:#3366ff; width:800px; padding:0;border-width:0;color:white">Unit1.pas
   		</div>
   		<div style="background-color:#dddddd; width:800px;" >
   			<div style="margin:10px">
<pre>
//****************** Pohyb myši nad Image *********************************
void __fastcall TForm1::Image1MouseMove(TObject *Sender, TShiftState Shift, int X, int Y)
{
  if (Shift.Contains(ssLeft)) 
  {   Image1->Canvas->Rectangle(xx,yy,xs,ys);    //zotrieme starú doèasnú úseèku
      Image1->Canvas->Rectangle(xx,yy,X,Y);  //nakreslíme novú doèasnú úseèku
      xs:=X; ys:=Y;                 		//odpamätáme, aby sme neskôr mohli zmaza
  {
//ak nie je stlaèené tlaèítko myši nerobíme niè
}
//****************** Stlaèili sme dole *************************************
void __fastcall TForm1::Image1MouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{   xx = X; yy = Y;                    //zapamätáme si zaèiatok novej doèasnej úseèky
    xs = X;  ys = Y;
    Image1->Canvas->Pen->Mode = pmNot;   //zapneme doèasnı mód
}
//****************** Pustili sme tlaèítko myši *****************************
void __fastcall TForm1::Image1MouseUp(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{     Image1->Canvas->Rectangle(xx,yy,xs,ys);  //zotrieme starú plochu (pre istotu)
      Image1->Canvas->Pen->Mode = pmCopy;   //zapneme "normálny" reim kreslenia
      Image1->Canvas->Rectangle(xx,yy,x,y);  //nakreslíme novú trvalú PLOCHU
}
/pre>	
		</div></div></div>

<div style="border-width:3;border-style:outset;width:850px;margin:10px;background-color:silver;">
   <div align="right" style="background-color:#3366ff; width:850px; padding:0;border-width:0;">
	   <img src="../obr/krizik.jpg" width="70px" height="22px" border="0" alt="" style="margin:0">
   </div>
  	<div style="background-color:silver; width:850px;" 
	 onmousemove="if (canvas.getContext) rect(event.pageX-this.offsetLeft,event.pageY-this.offsetTop );"
	onmousedown="if (canvas.getContext) mdole(event.pageX-this.offsetLeft,event.pageY-this.offsetTop );" 
	onmouseup="if (canvas.getContext) mhore(event.pageX-this.offsetLeft,event.pageY-this.offsetTop );">
<canvas width="800" height="600" id="platno" style="margin:6">
   <br>Váš prohlíeè nepodporuje kreslenie. Animácie nebudú fungova - zvolte IE9, Mozilla alebo Chrome.<br>
</canvas>
</div>
<table border="1"><tr><td rowspan="2" colspan="2" id="f" bgcolor="#000000" >&nbsp; &nbsp;<td bgcolor="black" onclick="f.style.background='black'">&nbsp;
                                                                      <td bgcolor="#880000" onclick="f.style.background='#880000'">&nbsp;
																	  <td bgcolor="#008800" onclick="f.style.background='#008800'">&nbsp;
																	  <td bgcolor="#555500" onclick="f.style.background='#555500'">&nbsp;
																	  <td bgcolor="#000088" onclick="f.style.background='#000088'">&nbsp;
																	  <td bgcolor="#550055" onclick="f.style.background='#550055'">&nbsp;
																	  <td bgcolor="005555" onclick="f.style.background='#005555'">&nbsp;
																	  <td bgcolor="#c0c0c0" onclick="f.style.background='#c0c0c0'">&nbsp;</tr>
		<tr><td bgcolor="#666666" onclick="f.style.background='#666666'">&nbsp;
			<td bgcolor="#ee0000" onclick="f.style.background='#ee0000'">&nbsp;
			<td bgcolor="#00ee00" onclick="f.style.background='#00ee00'">&nbsp;
			<td bgcolor="#eeee00" onclick="f.style.background='#eeee00'">&nbsp;
			<td bgcolor="#0000ee" onclick="f.style.background='#0000ee'">&nbsp;
			<td bgcolor="#ee00ee" onclick="f.style.background='#ee00ee'">&nbsp;
			<td bgcolor="#00eeee" onclick="f.style.background='#00eeee'">&nbsp;
			<td bgcolor="#ffffff" onclick="f.style.background='#ffffff'">&nbsp;</tr>
</table>		
<input type="Button" value="Clear" onclick="context.fillStyle = '#a8c101';context.fillRect(0, 0, 800, 600);pu=0;">
</div>
<br>

	<dt>Podporné akcie
	<dd>Kadı grafickı program by mal vedie svoj vytvorenı obrázok zapísa na disk, èo mono spravi
		cez menu alebo cez tlaèítko. Príkaz je nasledovnı
		<br>Image1.Pictures.SaveToFile('subor.bmp');
		<br><br>Na vo¾bu farby mono poui ColorDialog alebo ColorGrid
</dl>
</body>
</html>
