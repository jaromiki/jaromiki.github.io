<html>
<head>
	 <title>Animácia</title>
	 <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1250">
 	 <meta name="Content-language" content="sk">	
	  <LINK href="../css/style.css" type="text/css" rel=stylesheet>
</head>

<body>
<center><h3 class=nadpis>Zobrazovanie obrazkov</h3></center>
<h3>Bitmapy</h3>

<P>v tejto èasti môete poui nasledovné súbory 
   <br><A href="obr/obrazky.zip">obrazky.zip</A> 
   <br><A href="obr/obrazky2.zip">obrazky2.zip</A>
</P>

<UL type=disc>
    <LI>zatia¾ sme poznali jeden spôsob, ako vloi obrázok (súbor.BMP) do grafickej plochy: pomocou LoadFromFile 
	</LI></UL>
<TABLE cellSpacing=0 borderColorDark=white width="90%" align=center bgColor=white borderColorLight=gray border=1>
<TR><TD vAlign=" top" bgColor=#99cccc>
    	<P><I>preèítanie obrázka zo súboru&nbsp;do grafickej plochy Image:</I></P>
<TR><TD vAlign=top>
<PRE>void __fastcall TForm1::Button1Click(TObject *Sender)
{   Image1->Picture-><B>LoadFromFile</B>("tiger.bmp");
}
</PRE>
</TABLE>

<UL type=disc><LI>pomocou tohto spôsobu sa zapíše obrázok od súradníc (0,0) a bude nepouite¾nı, keï potrebujeme bitmapu 
					umiestni nie do ¾avého horného rohu, ale na nejaké iné konkrétne súradnice 
				<LI>na odstránenie spomenutého problému budeme pracova s novım objektom - <B>bitmapa</B> - môeme si 
					všimnú istú podobnos s objektom korytnaèka: 
			        <UL type=disc>
        				<LI>deklarovaním premennej <B>TBitmap *tmp</B> objekt (inštancia) ešte nevzniká - novı objekt treba ešte vytvori 
        				<LI><B>bmp=new Graphics::TBitmap();</B> - vytvorí sa nová bitmapa (obrázok), ktorı je zatia¾ prázdny - má rozmery 0x0 
				        <LI>do existujúceho objektu&nbsp;bitmapa môeme preèíta obrázok zo súboru pomocou <B>LoadFromFile()</B> 
							(ak u bitmapa mala nejakı obsah, tento sa stráca a nahradí sa preèítanım obrázkom - zmení sa jej ve¾kos) 
				        <LI>teraz môeme "opeèiatkova" náš novı objekt bitmapa do grafickej plochy Image1 pomocou metódy <B>Draw</B> 
        				<LI>a mali by sme si na záver zvyknú na jedno dôleité pravidlo: <B>vdy</B>, keï skonèíme pracova 
							s objektom bitmapa, tak je potrebné ju <B><I><FONT color=red>uvo¾ni</FONT></I></B> zo systému pomocou 
							metódy <B>delete Bitmap;</B> - bitmapa je toti takı špeciálny objekt, ktorı odèerpáva zdroje z Windows a ak takıchto 
							zdrojov Windows minieme prive¾a, systém sa môe zrúti... 
</UL>
</UL>

<TABLE cellSpacing=0 borderColorDark=white width="90%" align=center bgColor=white borderColorLight=gray border=1>
<TR><TD vAlign=" top" bgColor=#99cccc><P><I>bitmapa do pozadia grafickej plochy:</I></P>
<TR><TD vAlign=top>
<PRE>void __fastcall TForm1::Button1Click(TObject *Sender)
{   Graphics::TBitmap *bmp = new Graphics::TBitmap();
    bmp-><B>LoadFromFile</B>("tiger.bmp");
    Image1->Canvas-><B>Draw</B>(0,0,<B>bmp</B>);
    delete bmp;
(	 
</PRE> 
</TABLE>

<UL type=disc><LI>metóda <B>Draw</B> opeèiatkuje bitmapu do Canvasu na súradnice zadané dvoma prvımi parametrami - tieto 
					urèujú ¾avı hornı roh kladeného obrázka - pritom môe&nbsp;nejaká èas obrázka z plochy vypadnú; niekedy 
					sa môu hodi aj záporné súradnice obrázka ...    
			  <LI>existuje ešte špeciálny prípad metódy Draw - poloenie obrázka do plochy so zmenou ve¾kosti <B>StretchDraw</B> 
					- obrázok môeme ¾ubovo¾ne zmenši alebo zväèši, môeme ho napríklad natiahnu na celú grafickú plochu 
    <LI>			<B>StretchDraw</B> má dva parametre: prvım je obdånik (rectangle), do ktorého treba umiestni obrázok a druhım je 
           			samotná bitmapa; na definovanie obdånika èasto pouijeme konštrukciu <B>Rect(<I>x1,y1,x2,y2</I>)</B>, v ktorej zadáme 
           			súradnice ¾avého horného a pravého dolného rohu oblasti, napr. 
</UL>
<TABLE cellSpacing=0 borderColorDark=white width="90%" align=center bgColor=white borderColorLight=gray border=1>
<TR><TD vAlign=" top" bgColor=#99cccc><P><I>natiahnutie obrázka na celú plochu:</I></P>
<TR><TD vAlign=top>
<PRE>void __fastcall TForm1::Button2Click(TObject *Sender)
{   Graphics::TBitmap *bmp = new Graphics::TBitmap();
    bmp-><B>LoadFromFile</B>("tiger.bmp");
    Image1->Canvas-><B>StretchDraw</B>(Rect(0,0,Image1->Width,Image1->Height),bmp);
    delete bmp;
(	 
</PRE>
</TABLE>

<UL type=disc><LI>ukáeme typickú prácu s bitmapou - opeèiatkujeme obrázok viackrát ved¾a seba a pod seba tak, 
	aby presne vyplnil celé pozadie grafickej plochy</UL>

<TABLE cellSpacing=0 borderColorDark=white width="90%" align=center bgColor=white borderColorLight=gray border=1>
<TR><TD vAlign=" top" bgColor=#99cccc><P><I>okachlièkovanie plochy:</I></P>
<TR><TD vAlign=top>
<PRE>void __fastcall TForm1::Button2Click(TObject *Sender)
{   Graphics::TBitmap *bmp = new Graphics::TBitmap();
    int x,y=0,w=Image1.Width,h=Image1.Height;
    bmp-><B>LoadFromFile</B>("pozadie.bmp");
  while (y&lt;h) 
  {  x:=0;
     while (x&lt;w) 
     { Image1.Canvas.Draw(x,y,bmp);
       x+=bmp.Width;
     {
     y+=bmp.Height;
  {
  delete bmp;
}
</PRE>
</TABLE>

<H3 class=main>NDÚ</H3>
    <UL type=disc>
    <LI>vycentrujete bitmapu do grafickej plochy 
    <LI>vykachlièkujte plochu dvojnásobne zväèšenım (zmenšenım) obrázkom 
    <LI>natiahnite obrázok tak, aby pokryl celú plochu, ale pritom, aby ostal pomer strán obrázka zachovanı 
		- pravdepodobne obrázok v jednom rozmere môe vypadnú z plochy
    <LI>predpokladajme, e máme pripravenıch 8 súborov .BMP - bitmáp malıch obrázkov bmp1.bmp, bmp2.bmp, ...; 
		po zatlaèení tlaèidla sa na náhodnom mieste plochy poloí náhodne vybranı jeden z obrázkov 
    </UL>

<TABLE cellSpacing=0 borderColorDark=white width="90%" align=center bgColor=white borderColorLight=gray border=1>
<TR><TD vAlign=" top" bgColor=#99cccc><P><I>náhodnı obrázok na náhodnú pozíciu plochy:</I></P>
<TR><TD vAlign=top>
<PRE>void __fastcall TForm1::Button4Click(TObject *Sender)
{   Graphics::TBitmap *bmp = new Graphics::TBitmap();
    bmp->LoadFromFile("bmp"+IntToStr(random(8)+1)+".bmp");
  Image1.Canvas.Draw(random(Image1->Width-bmp->Width),
                     random(Image1->Height-bmp->Height),bmp);
  delete bmp;
}
</PRE>
</TABLE>

<UL type=disc><LI>ak pouije obrázky zo súboru <A href="obrazky2.zip">obrazky2.zip</A>, môete si všimnú, e niektoré 
				èasti obrázkov sú biele, ale bolo by krajšie, keby boli priesvitné - bitmapám môeme jednu farbu urèi 
				ako priesvitnú a potom kladenie obrázka do plochy pomocou <B>Draw</B> alebo <B>StretchDraw</B> ponechá 
				priesvitné èasti nezmenené - bitmape musíme zadefinova dve stavové premenné (vlastnosti) <B>TransparentColor</B> 
				a <B>Transparent</B> - prvou definujeme farbu, ktorá sa stane priesvitnou a druhou zapíname (môeme aj vypnú) 
				reim priesvitnej farby, napr.
</UL>

<TABLE cellSpacing=0 borderColorDark=white width="90%" align=center bgColor=white borderColorLight=gray border=1>
<TR><TD vAlign=" top" bgColor=#99cccc><P><I>obrázky s priesvitnımi èasami:</I></P>
<TR><TD vAlign=top>
<PRE>void __fastcall TForm1::Button5Click(TObject *Sender)
{   Graphics::TBitmap *bmp = new Graphics::TBitmap();
    bmp->LoadFromFile("bmp"+IntToStr(random(8)+1)+".bmp");
  bmp-><B>TransparentColor</B> = clWhite;
  bmp-><B>Transparent</B> = 1;
  Image1.Canvas.Draw(random(Image1->Width-bmp->Width),
                     random(Image1->Height-bmp->Height),bmp);
  delete bmp;
}
</PRE>
</TABLE>

<UL type=disc><LI>môeme pracova nielen s bitmapami, ktoré sme preèítali zo súboru, ale bitmapu si môeme nakresli aj sami: 
				bitmapa má rovnakı <B>Canvas</B> ako grafická plocha Image1 a teda do nej môeme kresli rovnakım spôsobom 
    		  <LI>ak nebudeme do práve vytvorenej bitmapy èíta súbor pomocou <B>LoadFromFile</B>, 
        		ale chystáme sa kresli do jej <B>Canvas</B>u, musíme jej najprv urèi ve¾kos (<B>bmp->Width</B> a <B>bmp->Height</B>) 
				a tie Canvas najprv vyfarbi nejakou farbou (napr. pomocou <B>FillRect</B>) 
</ul>	

<TABLE cellSpacing=0 borderColorDark=white width="90%" align=center bgColor=white borderColorLight=gray border=1>
<TR><TD vAlign=" top" bgColor=#99cccc><P><I>programom vytvorenı obrázok:</I></P>
<TR><TD vAlign=top>
<PRE>void __fastcall TForm1::Button6Click(TObject *Sender)
{   Graphics::TBitmap *bmp = new Graphics::TBitmap();
    int i;
    bmp->Width = 100; bmp->Height = 100;
    bmp->Canvas->Brush.Color = clWhite;
    bmp->Canvas->FillRect(Rect(0,0,bmp->Width,bmp->Height));
    for (i=10;i;i--)
    {   if (odd(i))  bmp->Canvas->Brush->Color = clYellow;
        else bmp->Canvas->Brush->Color = clRed;
        bmp->Canvas->Ellipse(50-5*i,50-5*i,50+5*i,50+5*i);
    }
  bmp->TransparentColor = clWhite;
  bmp->Transparent = 1;
  Image1->Canvas->Draw(random(Image1->Width-100),random(Image1->Height-100),bmp);
  delete bmp;
}
</PRE>
</TABLE>

<UL type=disc><LI>do bitmapy môeme opeèiatkova aj iné bitmapy -&nbsp;vytvoríme bitmapu so ltım kruhom a do nej opeèiatkujeme 
					náhodne vybranú bitmapu, napr.
</UL>
<P align=center><IMG height=220 src="subory/pz10_1.jpg" width=303 border=0></P>

<TABLE cellSpacing=0 borderColorDark=white width="90%" align=center bgColor=white borderColorLight=gray border=1>
<TR><TD vAlign=" top" bgColor=#99cccc><P><I>pouitie dvoch bitmáp:</I></P>
<TR><TD vAlign=top>
<PRE>void __fastcall TForm1::Button6Click(TObject *Sender)
{   Graphics::TBitmap *bmp = new Graphics::TBitmap(),Graphics::TBitmap *bmp1 = new Graphics::TBitmap() ;
    bmp->Width = 100; bmp->Height = 100;
    bmp->Canvas->Brush.Color = clWhite;
    bmp->Canvas->FillRect(Rect(0,0,bmp->Width,bmp->Height));
    bmp->Canvas->Brush->Color = clYellow;
    bmp->Canvas->Ellipse(0,0,100,100);
    bmp->TransparentColor = clWhite;
    bmp->Transparent = 1;
  
    <B>bmp1</B>->LoadFromFile("bmp"+IntToStr(random(5)+1)+".bmp");
    <B>bmp1</B>->TransparentColor = clWhite;
    <B>bmp1</B>->Transparent = 1;
    bmp->Canvas->Draw((100-bmp1->Width) div 2,(100-bmp1->Height) div 2,<B>bmp1</B>);
    <B>delete bmp1</B>;
    Image1->Canvas->Draw(random(Image1->Width-100),random(Image1->Height-100),bmp);
    delete bmp;
}
</PRE>
</TABLE>

<UL type=disc><LI>je ešte ve¾a inıch moností, ako pracova s bitmapami, napr. 
		        <UL type=disc>
        			<LI>namiesto <FONT face="Courier New"><B>bmp->LoadFromFile("bmp.bmp");</B></FONT> môeme pomocou <B><FONT face="Courier New">
						bmp->Assign(Image1->Picture);</FONT></B> naèíta-prekopírova obsah celej grafickej plochy do bitmapy 
			        <LI>z grafickej plochy môeme do bitmapy prekopírova len èas, napr. <B><FONT face="Courier New">
						bmp->Canvas->Draw(-200,-100,Image1->Picture->Graphic);</FONT></B> opeèiatkuje celú grafickú plochu do Canvasu bitmapy 
						- tá èas, ktorá sa nezmestí, bude odrezaná - zrejme bitmapa u musí ma pred tımto volaním nastavenú ve¾kos, napr. 
						<B><FONT face="Courier New">bmp->Width = 100; bmp->Height = 100;</FONT></B> - podobne by sme mohli poui aj <B>StretchDraw</B> 
        			<LI>metóda <B>CopyRect</B> je podobná <B>StretchDraw</B>, len môeme zada nielen obdånik kam sa kopíruje, ale aj obdånik 
            			(vırez), ktorı sa bude kopírova; <B>CopyRect</B> má tri parametre: 
            			<UL type=disc>
            				<LI>obdånik kam sa kopíruje (rovnako ako pre <B>StretchDraw</B>) 
            				<LI>Canvas obrázka/plochy, ktorı sa kopíruje (napr. <B>bmp->Canvas</B>, <B>Image1->Canvas</B>, ...) 
				            <LI>obdånik vırezu obrázka, ktorı sa bude kopírova, napr. 
				                Rect(100,100,200,150); 
						</UL>
				</UL>
    		<LI>pouitie <B>CopyRect</B> na jednoduchom príklade: z bitmapy tigra "vystrihneme" len hlavu
</UL>

<TABLE cellSpacing=0 borderColorDark=white width="90%" align=center bgColor=white borderColorLight=gray border=1>
<TR><TD vAlign=" top" bgColor=#99cccc><P><I>opeèiatkovanie len èasti obrázka:</I></P>
<TR><TD vAlign=top>
<PRE>void __fastcall TForm1::Button6Click(TObject *Sender)
{   Graphics::TBitmap *bmp = new Graphics::TBitmap(),Graphics::TBitmap *bmp1 = new Graphics::TBitmap() ;
    int x1,y1,x2,y2,w,h;
    bmp->LoadFromFile("tiger.bmp");
   x1 = random(Image1->Width); y1 = random(Image1->Height); <I><FONT color=navy>// kam </FONT></I>
   x2 = 64; y2 = 51;   <I><FONT color=navy>// odkia¾</FONT></I>
   w = 130; h = 152;   <I><FONT color=navy>// ve¾kos toho, èo vystrihnem </FONT></I>
   Image1->Canvas->CopyRect(Rect(x1,y1,x1+w,y1+h),bmp->Canvas,Rect(x2,y2,x2+w,y2+h));
   delete bmp;
}
</PRE>
</TABLE>

<UL type=disc>
    <LI>ak vám pri práci s grafickou plochou (nielen pri práci s bitmapami) bliká celá plocha, môeme formuláru nastavi takúto 
        stavovú premennú (môe kvôli tomu sa mierne spomali zobrazovanie v Image) 
</UL>

<TABLE cellSpacing=0 borderColorDark=white width="90%" align=center bgColor=white borderColorLight=gray border=1>
<TR><TD vAlign=" top" bgColor=#99cccc><P><I>aby grafická plocha neblikala:</I></P>
<TR><TD vAlign=top>
<PRE>void __fastcall TForm1::FormCreate(TObject *Sender)
{
   DoubleBuffered = 1;
}
</PRE>
</TABLE>

<H3 class=main>Bitmapa ako globálna premenná</H3>

<UL type=disc>
    <LI>èasto sa nám môe hodi, aby sme nemuseli èasto pouívanú bitmapu (ale aj viac bitmáp - mono aj pole bitmáp) tesne pred 
        pouitím vytvori a&nbsp;preèíta zo súboru a po pouití (napr. po <B>Draw</B>) ju pomocou <B>Free</B> uvo¾ni 
    <LI>najjednoduchším spôsobom&nbsp;je vytvorenie globálnych premennıch pri štarte formulára - <B>FormCreate</B> 
    <LI>potom je dobre&nbsp;nezabudnú uvo¾ni takéto bitmapy pri konci aplikácie - <B>FormDestroy</B>
</UL>

<TABLE cellSpacing=0 borderColorDark=white width="90%" align=center bgColor=white borderColorLight=gray border=1>
<TR><TD vAlign=" top" bgColor=#99cccc><P><I>bitmapa ako globálna premenná:</I></P>
<TR><TD vAlign=top>
<PRE>
Graphics::TBitmap *bmp = new Graphics::TBitmap();

void __fastcall TForm1::FormCreate(TObject *Sender)
{
   bmp->LoadFromFile("tiger.bmp");
   DoubleBuffered = 1;
}

void __fastcall TForm1::Button1Click(TObject *Sender)
{   int x,y,w,h;
    w = 50+random(200); h = 50+random(200);
    x = random(Image1->Width-w); y = random(Image1->Height-h);
    Image1->Canvas->StretchDraw(Rect(x,y,x+w,y+h),bmp);
}

void __fastcall TForm1::FormDestroy(TObject *Sender)
{
   delete bmp;
}
</PRE>
</TABLE>

<H3 class=main>Kópia bitmapy</H3>
<UL type=disc>
    <LI>ak potrebujeme prekopírova obsah jednej bitmapy do druhej, nikdy nesmieme poui "obyèajné" priradenie, napr.
</UL>
<TABLE cellSpacing=0 borderColorDark=white width="90%" align=center bgColor=white borderColorLight=gray border=1>
<TR><TD vAlign=" top" bgColor=#99cccc><P><B><I>!!! chybné riešenie !!!</I></B></P>
<TR><TD vAlign=top>
<PRE>Graphics::TBitmap *b1 = new Graphics::TBitmap(),Graphics::TBitmap *b2 = new Graphics::TBitmap() ;
     b1->LoadFromFile("miri.bmp");

     b2 = b1;    <I><FONT color=navy>// tá istá bitmapa dostala druhé meno - b2</FONT></I>
    <I><FONT color=navy>// ... poívanie bitmapy b2 ...</FONT></I>
    delete b1; delete b2;
  </PRE>
</TABLE>

<UL type=disc>
    <LI>táto èas programu spadne, lebo po <B>delete b1</B> u neexistuje ani <B>b2</B> a teda sa nedá urobi <B>delete b2</B> ... 
    <LI>prvé správne riešenie
</UL>
<TABLE cellSpacing=0 borderColorDark=white width="90%" align=center bgColor=white borderColorLight=gray border=1>
<TR><TD vAlign=" top" bgColor=#99cccc><P><I>kopírovanie jednej bitmapy do Canvasu druhej bitmapy:</I></P>
<TR><TD vAlign=top>
<PRE>Graphics::TBitmap *b1 = new Graphics::TBitmap(),Graphics::TBitmap *b2 = new Graphics::TBitmap() ;
     b1->LoadFromFile("miri.bmp");

     b2->Width = b1->Width; b2->Height = b1->Height;
     b2->Canvas->Draw(0,0,b1);
    <I><FONT color=navy>// ... poívanie bitmapy b2 ...</FONT></I>
    delete b1; delete b2;
  </PRE>
</TABLE>

<UL type=disc>
    <LI>druhé správne riešenie
</UL>
<TABLE cellSpacing=0 borderColorDark=white width="90%" align=center bgColor=white borderColorLight=gray border=1>
<TR><TD vAlign=" top" bgColor=#99cccc><P><I>pouitie metódy <B>Assign</B>:</I></P>
<TR><TD vAlign=top>
<PRE>Graphics::TBitmap *b1 = new Graphics::TBitmap(),Graphics::TBitmap *b2 = new Graphics::TBitmap() ;
     b1->LoadFromFile("miri.bmp");

    <B>b2.Assign(b1);</B>
    <I><FONT color=navy>// ... poívanie bitmapy b2 ...</FONT></I>
    delete b1; delete b2;
 </PRE>
</TABLE>

<H3 class=main>Zhrnutie triedy TBitmap</H3>
<P><B>TBitmap</B> je preddefinovaná trieda, ktorá slúi na manipuláciu s obrázkami - môeme si ju predstavi ako obsah súboru s 
       príponou .BMP (dá sa s ním pracova napr. v programe Paint/Skicár). Táto trieda má nieko¾ko uitoènıch stavovıch premennıch 
	   (vlastnosti - property) a metód. 
</P>
<H3 class=main>niektoré stavové premenné: </H3>
<UL>
    <LI><B>Width</B>, <B>Height</B> - momentálna šírka a vıška obrázka (môeme ju zmeni priradením novıch hodnôt do tıchto premennıch) 
    <LI><B>Canvas</B> - grafická plocha obrázka 
    <LI><B>Transparent</B> - èi má nejaké priesvitné èasti (inak je to nepriesvitnı obdånik) 
    <LI><B>TransparentColor</B> - ktorá farba v obrázku je povaovaná za priesvitnú
</UL>

<H3 class=main>niektoré metódy: </H3>
<UL>
    <LI>operátor <B>new Graphics::TBitmap()</B> - vytvorí zatia¾ prázdny obrázok 
    <LI>operátor <B>delete bitmap </B> - uvo¾ní bitmapu z pamäti Windows 
    <LI><B>LoadFromFile()</B> - naèíta obrázok zo súboru vo formáte .BMP 
    <LI><B>SaveToFile()</B> - uloí obrázok do súboru vo formáte .BMP 
    <LI><B>Assign()</B> - urobí kópiu obrázka z inej bitmapy
</UL>
<P>Môeme pracova s Canvasom bitmapy, t.j. s dvojrozmernım po¾om farebnıch Pixelov (bodov) - do bitmapy môeme kresli, môeme 
   pracova s jednotlivımi pixelmi - úplne rovnako ako v "obyèajnej" grafickej ploche (TImage)
</P>
<UL>
    <LI>Canvas->FillRect 
    <LI>Canvas->Pixels[riadok,ståpec] 
    <LI>Canvas->Rectangle, Ellipse, TextOut, ... 
    <LI>Canvas->MoveTo, LineTo, Polygon, Polyline, FloodFill, 
        ...
</UL>
<P>a teda môeme tımto metódam nastavi pero, štetec, font, ..., napr. Canvas->Pen->Color = ...</P>
<UL>
   	<LI><B>Canvas->Draw()</B> - "opeèiatkuje" inú bitmapu 
   	<LI><B>Canvas->StretchDraw()</B> - "opeèiatkuje" inú bitmapu, prièom ju môe zväèši/zmenši 
   	<LI><B>Canvas->CopyRect()</B> - "opeèiatkuje" vırez iného <B>Canvas</B>u (bitmapy alebo grafickej plochy) 
   	<LI><B>Canvas->BrushCopy()</B> - podobnı <B>CopyRect()</B> - jednu z farieb pri kopírovaní vie nahradi inou 
</UL>
</TABLE>
<HR width=550 SIZE=1>
<dl><dt class=main>Príklady na precvièenie:
	<dd><table cellspacing="20">
		<tr><td><img src="../obr/ktstrofa.wmf" border="0" alt="" height="50">		
			<td>
			<ol>
			<li>Naprogramuj <a href="lodz.exe">stiahni</a>
			</ol>
		</table>

<dl>
<dt class=main>Pohyb obrázkov na obrazovke
<dd>Postup:
<ol>
	<li>animovanı objekt - obrázok si pripravíme v premennej obr typu Tpicture, ak treba urèíme prieh¾adnú farbu
	<li>odloenie oblasti Canvasu, ktorá bude zasiahnutá novım ojektom - príkaz CopyRect
	<li>poloenie objektu - príkaz draw resp. StretchDraw - na zmenu ve¾kosti
	<li>pauza, ktorá je na "vychutnanie" poh¾adu na zobrazenı objekt
	<li>vıpoèet novıch súradníc objektu
	<li> odloené pozadie nazad na canvas - náš objekt zmizne
	<li>a môme zaèa od zaèiatku - bodu 2
</ol>
V prípade e chceme pohybova viacerımi objektami (úloha2), je vhodné radšej zotrie okno a nakresli objekty v novıch pozíciách.
   <dl> <dt class=second>Úlohy:
		<dd><ol><li><a href="anim4.exe">uloha1</a>
	    				  <li><a href="anim5.exe">uloha2</a>
			    	  </ol>
   </dl>   				   	  
<hr>
<dt class=main>Animované obrázky
<dd>Niekedy chceme aby sa obrázok pri pohybe menil - vtáci mávajú krídlami, roboti hıbu nohami atï. Predpokladám, e máme obrázky
	obr1, ... ,obrn, kde je rozfázovanı pohyb objektu. Zavedieme si bajtovú premennú <font color="red">fáza</font>, kde bude zapísané
	ko¾kı obrázok - faza -  sa má aktuálne zobrazi.
	<br>Postup:
	<br>- obrázky si cyklom naèítame do po¾a obrázkov (array of Tpicture) 
	<br>- èasovaè robí nasledné  - zotrie obrazovku - zmení fázu a súradnice obrázka a zobrazí ho 
   <dl>
   <dt><font color="green">Úlohy:</font>
   <dd><ol><li><a href="anim6.exe">uloha1</a></ol>
   </dl>
 <hr>
<dt class=main>Pohyb pozadia
<dd>Niekedy potrebujeme posúva pozadie, napr. hráè prišiel ku kraju okna a zobrazí sa mu ïalší priestor alebo
	pre efekt letu nad krajinou sa pozadie plynule posúva nabok.
	<br>Postup:
	<ol>
	<li>pripravíme si do premennej velkı obrázok (resp. opakujúci sa obrázok, nieèo ako kachlièky)
	<li>parametrami príkazu draw - x,y urèíme ktorá èas ve¾kého obrázku bude vlastne viditelná
		(x, y môu by súradnice mimo canvasu). 
	<li>menením x,y vznikne dojem pohybujúceho sa pozadia
	</ol>	 
   <dl>
   <dt class=second>Úlohy:
   <dd><ol><li><a href="anim7.exe">uloha1</a></ol>
   </dl>
 <hr>
</dl>
</body>
</html>
