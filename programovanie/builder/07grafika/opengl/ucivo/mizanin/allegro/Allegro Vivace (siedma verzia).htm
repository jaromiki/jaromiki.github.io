<html lang="sk"><head>
<title>Allegro Vivace (siedma verzia)</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
</head><body>
<h1><a name="Top">Allegro Vivace</a></h1>

<p>Copyright &copy; 1997-1999 George Foot
<p>Preklad (Translation) &copy; 2002 Anino Belan

<p> Táto dokumentácia sa mô¾e ¹íri» bezo zmeny v µubovoµnej podobe bez
obmedzenia. V prípade ¹írenia zmenených kópií je nutné uvies», ¾e do¹lo ku
zmene.

<p> Toto je siedma verzia, posledná zmena v origináli bola urobená 26 Augusta
1999

<ul>
<li><a href="#Legal%20issues">Právne ustanovenia</a>

<li><a href="#Introduction">Úvod</a>

<li><a href="#Getting%20installing%20and%20using%20Allegro">Ako získa»,
nain¹talova» a pou¾íva» Allegro</a>

<li><a href="#A%20basic%20game%20structure">Základná ¹truktúra hry</a>

<li><a href="#Introducing%20graphics">Úvod do grafiky</a>

<li><a href="#Making%20several%20things%20happen%20at%20once">Ako zariadi», aby
sa niekoµko vecí dialo súèasne</a>

<li><a href="#User%20input">U¾ivateµský vstup</a>

<li><a href="#More%202D%20graphics">Nieèo viac z 2D grafiky</a>

<li><a href="#Sound">Zvuk</a>

<li><a href="#Timers">Èasovaèe</a>

<li><a href="#Datafiles">Datasúbory</a>

<p>
</p>
<li><a href="#Index">Index</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Introduction">Úvod</a>
 | Hore:<a rel=up href="#Top">Zaèiatok</a>
 ]<p>

<h1><a name="Legal%20issues">Právne ustanovenia</a></h1>

<h2>©írenie</h2>

<p> Tento dokument mô¾ete bezo zmien voµne ¹íri» v akejkoµvek forme. Nechcem za
to niè, ale e-mail pote¹í.

<p> Mô¾ete tie¾ ¹íri» zmenené kópie v akejkoµvek forme, ak sa postaráte o to,
aby bolo zrejmé, ¾e tieto kópie sú zmenené.

<h2>Vyhlásenie</h2>

<p> Neprijímam ¾iadnu zodpovednos» za akúkoµvek ¹kodu, ktorú pou¾itie alebo
zneu¾itie tohto tutoriálu mô¾e komukoµvek spôsobi». Nie je zaruèené, ¾e príklady,
ktoré sú súèas»ou tohto balíka budú fungova» ani nie je zaruèené, ¾e sú
bezpeèné. Vo v¹eobecnosti by ste v ¾iadnom prípade nemali kompilova» programy,
ktorým nerozumiete.


<p><hr>[ Ïal¹í:<a rel=next
href="#Getting%20installing%20and%20using%20Allegro">Ako získa»,
nain¹talova» a pou¾íva» Allegro</a>
 | Predo¹lý:<a rel=previous href="#Legal%20issues">Právne ustanovenia</a>
 | Hore:<a rel=up href="#Top">Zaèiatok</a>
 ]<p>

<h1><a name="Introduction"><a name="TOC_0">1. Úvod</a></a></h1>

<ul>
<li><a href="#About%20the%20tutorial">O tutoriáli</a>

<li><a href="#Aim">Zámer</a>

<li><a href="#Target%20audience">Cieµová skupina</a>

<li><a href="#Requirements">Po¾iadavky</a>

<li><a href="#Before%20we%20start">Predtým, ne¾ zaèneme</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Aim">Zámer</a>
 | Hore:<a rel=up href="#Introduction">Úvod</a>
 ]<p>

<h2><a name="About%20the%20tutorial"><a name="TOC_1">1.1 O tutoriáli</a></a></h2>

<p>Tento tutoriál je dostupný v niekoµkých verziach - textový súbor, Info formát
(ktorý funguje aj s RHIDE) a v zdrojovom tvare ako Texinfo. Zdrojová distribúcia
obsahuje nástroje na vytvorenie iných formátov vèítane DVI a Postscript-u, ktoré
mô¾u by» vytlaèené. Podpora pre HTML sa plánuje. (pozn. prekl. V slovenèine 
existuje len HTML verzia, ak z toho spravite aj nejaké iné, nech sa páèi.)

<p>K tutoriálu patrí aj súbor uká¾kových programov, väè¹inou napísaných
Grzegorzom Adamom Hanciewiczom. Demon¹trujú funkcie a techniky o ktorých sa
hovorí v texte tutoriálu a sú hodnotným zdrojom informácií, ak sa vám nedarí
nieèo pochopi».

<p>V¹etky èasti Allegro Vivace - tutoriál v hlavných formátoch, zdrojová
distribúcia tutoriálu a uká¾kové programy - mô¾u by» stiahnuté jednotlivo alebo
po skupinách z webovej stránky:

<pre>http://www.canvaslink.com/gfoot/vivace/
</pre>

<p>Ak ma chcete kontaktova», moja e-mailová adresa je:

<pre>gfoot@users.sourceforge.net
</pre>

<p>Komentáre, návrhy a s»a¾nosti sú, ako v¾dy, veµmi cenené.

<p><hr>[ Ïal¹í:<a rel=next href="#Target%20audience">Cieµová skupina</a>
 | Predo¹lý:<a rel=previous href="#About%20the%20tutorial">O tutoriáli</a>
 | Hore:<a rel=up href="#Introduction">Úvod</a>
 ]<p>

<h2><a name="Aim"><a name="TOC_2">1.2 Zámer</a></a></h2>

<p>Zámerom tohto tutoriálu je vies» nováèikov k programovaniu hier a Allegru s
pomocou procesu vytvárania jednoduchej hry.

<p><hr>[ Ïal¹í:<a rel=next href="#Requirements">Po¾iadavky</a>
 | Predo¹lý:<a rel=previous href="#Aim">Zámer</a>
 | Hore:<a rel=up href="#Introduction">Úvod</a>
 ]<p>

<h2><a name="Target%20audience"><a name="TOC_3">1.3 Cieµová skupina</a></a></h2>

<p> Ako bolo povedané vy¹¹ie, tento tutoriál je urèený pre nováèikov v
programovaní hier a Allegre. Nie je urèený pre úplných zaèiatoèníkov v jazyku C.
Tým myslím, ¾e sa predpokladá istá znalos» a skúsenosti s pou¾ívaním jazyka C a
oèakávam, ¾e u¾ máte funkèný kompilátor, ktorý podporuje Allegro.


<p><hr>[ Ïal¹í:<a rel=next href="#Before%20we%20start">Pred tým, ne¾ zaèneme</a>
 | Predo¹lý:<a rel=previous href="#Target%20audience">Cieµová skupina</a>
 | Hore:<a rel=up href="#Introduction">Úvod</a>
 ]<p>

<h2><a name="Requirements"><a name="TOC_4">1.4 Po¾iadavky</a></a></h2>

<ul>
<li>Funkèný kompilátor (odporúèa sa: gcc v2.7.2.1 alebo nov¹í; pou¾ite
djgpp v2.01 alebo nov¹í pre DOS)

<li>Allegro verzia 4.0 alebo kompatibilná (pozrite ni¾¹ie komentár k iným
verziam)

<li>GNU Make utilita (na kompiláciu Allegra, a preto¾e je aj inak u¾itoèná)
</ul>

<p>Pod <dfn>funkèným kompilátorom</dfn> myslím taký, ktorý vie kompilova»
programy v jazyku C a urobi» z nich programy spustiteµné na va¹ej platforme.
Tie¾ samozrejme musí by» schopný pracova» s kni¾nicou Allegro, ale tomu sa
budeme venova» ni¾¹ie.

<p>Ak vá¹ kompilátor nefunguje správne, potrebujete problém odstráni» a toto nie
je miesto, kde by som túto problematiku mal rozobera» do detailov. Ak pou¾ívate
djgpp, preèítajte si <code>readme.1st</code> a djgpp FAQ; ak to nepomô¾e,
konajte podµa in¹trukcií, ktoré sú vo FAQ ohµadom poslielania otázok na mailing
list a usenetovú skupinu venovanú djgpp. Ak pou¾ívate verziu djgpp v2.00, vrelo
odporúèam upgrade.

<p>Tento tutoriál bol poslednýkrát zmenený, keï bola na svete verzia Allegro
4.0, ale nepokrýva e¹te úplne v¹etky nové vlastnosti. Napriek tomu je Allegro
4.0 hlavnou verziou, pre ktorú je tento tutoriál písaný a èoskoro ho budem
aktualizova».

<p>Väè¹ina vecí bude fungova» aj pre star¹ie verzie, ale niektoré nemusia --
taký je ¾ivot. Urobím, èo budem môc», aby som opísal zmeny potrebné pre Allegro
3.x. Aby mohli by» skompilované verzie Allegra star¹ie ne¾ 3.0, potrebujú C++.
Nemusíte v C++ programova», ale vá¹ poèítaè ho musí podporova». Ak nepodporuje,
buï nain¹talujte najnov¹iu verziu Allegra (odporúèa sa, sú samozrejme veµmi
stabilné) alebo nain¹talova» podporu C++ (pre djgpp pozrite <code>readme.1st</code>)
Ak nenain¹talujete novú verziu allegra, <em>budete musie»</em> zmeni» èasti kódu
uká¾ok z tohto tutoriálu.

<p>Dúfame, ¾e nov¹ie verzie zmienených balíkov sú spätne kompatibilné so 
star¹ími; ak nie, je opä» na vás, aké zmeny urobíte.

<p><em>Budete</em> potrebova» program GNU make, napriek faktu, ¾e je v súbore
<code>readme.1st</code> z djgpp oznaèený ako nepovinný. Je to náramne u¾itoèný
balík a aj Allegro aj príklady sprevádzajúce tento tutoriál sú navrhnuté tak,
aby sa dali (bezbolestne) skompilova» s jeho pomocou. Najnov¹ia verzia pre djgpp
(poèas písania) je <code>mak3761b.zip</code>, ktorá patrí k verzii djgpp 2.01 a
<em>nefunguje</em> správne s verziou 2.00.

<p>Väè¹ina µudí pri programovaní pou¾íva jeden z troch spôsobov: niekto pou¾íva
IDE ako napríklad RHIDE, niekto má rad¹ej Emacs a iní pou¾ívajú jednoduché textové editory
a utilitu Make. Tento tutoriál sa nesna¾í vnúti» vám niektorý z týchto systémov;
programujte v tom prostredí, ktoré máte najrad¹ej. Príklady mô¾u by»
skompilované utilitou Make, ale jednoducho pre ne mô¾ete vytvori» RHIDE
projekty.

<p><hr>[ Predo¹lý:<a rel=previous href="#Requirements">Po¾iadavky</a>
 | Hore:<a rel=up href="#Introduction">Úvod</a>
 ]<p>

<h2><a name="Before%20we%20start"><a name="TOC_5">1.5 Predtým, ne¾ zaèneme <small>...</small></a></a></h2>

<p>Tento tutoriál je urèený µuïom s rôznymi programátorskými schopnos»ami,
od tých, ktorí sa e¹te len uèia a¾ po tých, ktorí u¾ majú mno¾stvo skúseností.
Ak máte pocit, ¾e niektorá èas» zachádza priveµmi do podrobností, tak to v¹etko
neèítajte -- táto èas» je najskôr urèená µuïom s ni¾¹ím ¹tandardom, ne¾ máte vy
a staèí, keï ju preletíte, aby ste sa zoznámili s príkazmi, ktoré sú v nej
uvedené. 

<p>Nadpisy niektorých sekcií som uzavrel medzi [ a ]. Znamená to, ¾e kapitoly
obsahujú témy pre pokroèilých, komplikované, ktoré je namáhavé programova» alebo
sú len okrajové. Ak nechcete, neèítajte to.

<p>Veµkým problémom pri písaní hier je in¹pirácia -- ak nemáte v hlave niè, èo
by ste chceli napísa», tak to ani nenapí¹ete. V prvom momente vás pravdepodobne
buï nenapadne niè, alebo dostanete spústu nápadov, ktoré ale budú vyzera» príli¹
zlo¾ito na to, aby sa dali naprogramova».

<p>Ak vás nenapadne niè, relaxujte a èítajte tento tutoriál. Pou¾ite uká¾kové
príklady ako základ, pridajte k nim nové veci a prispôsobte si ich podµa svojej
potreby. Poèas èítania získate lep¹í prehµad o tom, èo sa dá urobi» a èo nie.
Mrknite sa aj na komerèné hry -- skúste, èi viete na prvý pohµad poveda», ako
robia to, èo robia a potom to skúste vylep¹i». Nehovorte si, ¾e je to nieèo, èo
nikdy nezvládnete -- ako budete získava» skúsenosti, budete prichádza» na rôzne
spôsoby, ako veci spravi». Pamätajte si, ¾e ak to autori nejako napísali,
musí sa to da» urobi».

<p>Ak sú va¹e nápady príli¹ zlo¾ité, to èo bolo napísané vy¹¹ie platí tie¾ --
èím viac hier napí¹ete, tým lep¹í v tom budete a tým viac hier budete schopní
napísa». V takmer ka¾dom prípade je pre zaèiatoèníkov najlep¹ie, keï zaènú s
jednoduchými vecami a urobia rýchle fungujúcu hru a potom na tom základe 
stavajú. Táto technika má svoje nevýhody, ale nateraz bude celkom dobrá.

<p>A nakoniec -- hry musia priná¹a» zábavu; je to ich cieµom. Nemô¾ete napísa»
peknú hru, ak sa nete¹íte z toho, ¾e ju pí¹ete. Ak sa vám bude tento tutoriál
zda» nudný, tak som ho napísal zle a treba ho zmeni», dajte mi, prosím,
vedie». Tento tutoriál je pre vás a vám podobných; u¾ite si ho!

<p><hr>[ Ïal¹í:<a rel=next href="#A%20basic%20game%20structure">Základná
¹truktúra hry</a>
 | Predo¹lý:<a rel=previous href="#Introduction">Úvod</a>
 | Hore:<a rel=up href="#Top">Zaèiatok</a>
 ]<p>

<h1><a name="Getting%20installing%20and%20using%20Allegro"><a name="TOC_6">2. Ako získa»,
nain¹talova» a pou¾íva» Allegro</a></a></h1>

<ul>
<li><a href="#What%20is%20Allegro">Èo je to Allegro</a>

<li><a href="#Where%20to%20find%20Allegro">Kde získa» Allegro</a>

<li><a href="#How%20to%20install%20Allegro">Ako nain¹talova» Allegro</a>

<li><a href="#Testing%20the%20installation">Testovanie in¹talácie</a>

<li><a href="#Using%20Allegro">Pou¾itie Allegra</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Where%20to%20find%20Allegro">Kde získa» Allegro</a>
 | Hore:<a rel=up href="#Getting%20installing%20and%20using%20Allegro">Ako získa»,
nain¹talova» a pou¾íva» Allegro</a>
 ]<p>

<h2><a name="What%20is%20Allegro"><a name="TOC_7">2.1 Èo je to Allegro?</a></a></h2>

<p>Allegro je kni¾nica urèená na programovanie hier, ktorej hlavným autorom a
koordinátorom je Shawn Hargreaves. Je to veµmi dobrá kni¾nica; je rýchla, má
mno¾stvo vlastností a od verzie 4 predstavuje skvelú multiplatformnú vrstvu,
ktorá vám umo¾òuje písa» kód, ktorý bude fungova» aj na systémoch, ktoré ste v
¾ivote nevideli. Ak chcete podrobnej¹ie informácie, pozrite si domovskú stránku
projektu:

<pre>http://www.talula.demon.co.uk/allegro/
</pre>

<p><hr>[ Ïal¹í:<a rel=next href="#How%20to%20install%20Allegro">Ako nain¹talova» Allegro</a>
 | Predo¹lý:<a rel=previous href="#What%20is%20Allegro">Èo je to Allegro?</a>
 | Hore:<a rel=up href="#Getting%20installing%20and%20using%20Allegro">Ako získa»,
nain¹talova» a pou¾íva» Allegro</a>
 ]<p>

<h2><a name="Where%20to%20find%20Allegro"><a name="TOC_8">2.2 Kde získa» Allegro</a></a></h2>

<p>Allegro je dostupné v prvom rade na linkách uvedených na jeho domovskej
stránke (pozri <a href="#What%20is%20Allegro">Èo je to Allegro?</a>) a tie¾ ako
súèas» distribúcie djgpp na <code>ftp.simtel.net</code>. Verzie, ktoré sú
pribalené k
djgpp sú zvyèajne posledné stabilné verzie. Ak chcete najnov¹iu vývojovú verziu,
musíte ís» na stránku allegra.

<p>Odporúèam vám stiahnu» si vývojovú verziu, preto¾e tento tutoriál bol písaný
s prihliadnutím na òu. Je celkom stabilná. Poèas písania tohto
tutoriálu bola vonku u¾ niekoµko tý¾dòov verzia 3.9.25 a musím poveda», ¾e som s
òou nemal ¾iadne väè¹ie problémy. (pozn.prekl. U¾ pomerne dlho sú na svete aj
stabilné verzie radu 4. Ja osobne som mal lep¹ie skúsenosti so stabilnými, ne¾ s
vývojovými verziami.)


<p><hr>[ Ïal¹í:<a rel=next href="#Testing%20the%20installation">Testovanie
in¹talácie</a>
 | Predo¹lý:<a rel=previous href="#Where%20to%20find%20Allegro">Kde získa» Allegro</a>
 | Hore:<a rel=up href="#Getting%20installing%20and%20using%20Allegro">Ako získa»,
nain¹talova» a pou¾íva» Allegro</a>
 ]<p>

<h2><a name="How%20to%20install%20Allegro"><a name="TOC_9">2.3 Ako nain¹talova» Allegro</a></a></h2>

<p>Tieto in¹trukcie majú slú¾i» len ako struèný návod - postup sa lí¹i od
platformy k platforme a je vysvetlený oveµa podrobnej¹ie v zodpovedajúcich
readme súboroch, ktoré sú vo verzii, ktorú ste si stiahli.

<p>Vytvorte pre Allegro adresár kdekoµvek chcete a rozbaµte do neho Allegro tak,
aby ste zachovali jeho adresárovú ¹truktúru (parameter <code>-d</code> pre
<code>pkunzip</code> pod DOSom; Unixové rozpakovávaèe to spravia automaticky a
¾iadne prepínaèe nie sú nutné). Uistite sa, ¾e bol vytvorený napríklad adresár s
názvom <code>docs</code>.

<p>Keï to bude hotové, choïte do adresára kde Allegro máte. Ak pou¾ívate
vývojovú verziu, treba spusti» fix, ktorý distribúciu upraví pre va¹u platformu.
Pre DOS a djgpp napí¹te:

<pre>fixdjgpp
</pre>

<p>Pre Unixové systémy napí¹te:

<pre>chmod 700 fixunix.sh
./fixunix.sh
</pre>

<p> Potom bude treba skonfigurova» kompiláciu. Pozrite si readme súbor pre va¹u
verziu a platformu, aby ste sa dozvedeli detaily. 

<p>Aby ste skompilovali kni¾nicu a nástroje, zadajte 'make':

<pre>make
</pre>

<p>To by potom malo be¾a» samo a skonèi» krátkou správou, ktorá vám povie, ¾e to
funguje. Ak sa tak nestane, preèítajte si dokumentáciu k Allegru ak ste tak e¹te
nespravili (v adresári v ktorom máte Allegro súbory <code>allegro.txt</code>,
<code>faq.txt</code> a èiastoène aj <code>readme.txt</code>).

<p>Nakoniec potrebujete nain¹talova» kni¾nicu a hlavièkové súbory, aby ich va¹e
programy mohli jednoducho pou¾íva»:

<pre>make install
</pre>

<p>Pod Unixom budete pravdepodobne potrebova» práva roota, aby ste to mohli
urobi».

<p>Ak ste niekde zamrzli, skúste sa popýta» na Allegrovskej konferencii --
<code>allegro@canvaslink.com</code>. Ak potrebujete informáciu o tom, ako sa do
konferencie prihlási», pozrite si èas» <cite>Contact Info</cite> na
konci Allegrovského súboru <code>readme.txt</code>. Väè¹ina µudí pí¹e odpovede
iba do konferencie, tak¾e ak nie ste prihlásení, v maili to uveïte a poproste
µudí, aby poslali Cc: aj vám.

<p><hr>[ Ïal¹í:<a rel=next href="#Using%20Allegro">Pou¾itie Allegra</a>
 | Predo¹lý:<a rel=previous href="#How%20to%20install%20Allegro">Ako nain¹talova» Allegro</a>
 | Hore:<a rel=up href="#Getting%20installing%20and%20using%20Allegro">Ako získa»,
nain¹talova» a pou¾íva» Allegro</a>
 ]<p>

<h2><a name="Testing%20the%20installation"><a name="TOC_10">2.4 Testovanie
in¹talácie a kompilácia uká¾kových programov</a></a></h2>

<p>In¹talácia je v podstate samotestujúca, preto¾e sa pri nej kompilujú v¹etky
Allegrovské vzorové príklady a nástroje. Napriek tomu som pre úplnos» zaradil
krátky program na kontrolu toho, èi nie sú problémy s nájdením hlavièkového
súboru a kni¾nice. Ak chcete test spusti», vojdite do adresára
<code>examples</code> a napí¹te:

<pre>make test
</pre>

<p>Ak tam nie sú ¾iadne chyby, skvelé - mô¾ete skompilova» ostatné vzorové
programy z Vivace znovuspustením <code>make</code> bez argumentu
<code>test</code>.

<p>Ak ale kompilátor nemô¾e nájs» <code>allegro.h</code>,
<code>liballeg.a</code> alebo <code>-lalleg</code>, in¹talácia neprebehla
správne a vy budete musie» znovu podrobnej¹ie preèíta» dokumentáciu.


<p><hr>[ Predo¹lý:<a rel=previous href="#Testing%20the%20installation">Testovanie
in¹talácie</a>
 | Hore:<a rel=up href="#Getting%20installing%20and%20using%20Allegro">Ako získa»,
nain¹talova» a pou¾íva» Allegro</a>
 ]<p>

<h2><a name="Using%20Allegro"><a name="TOC_11">2.5 Pou¾itie Allegra</a></a></h2>

<p>Táto èas» struène opakuje veci, ktoré sú v dokumentácii Allegra

<p>Za prvé, ka¾dý zdrojový kód, ktorý pou¾íva funkcie alebo procedúry z Allegra,
musí obsahova» <code>#include &lt;allegro.h&gt;</code>. Dajte to a¾ <em>za</em>
v¹etky ¹tandardné hlavièkové súbory -- konkrétne musí ís» a¾ za <code>#include
&lt;stdio.h&gt;</code> -- aby sa predi¹lo kolíziam medzi hlavièkovými súbormi.

<p>Za druhé treba zavola» <code>allegro_init()</code> krátko po ¹tarte vá¹ho
programu. Inicializuje to niektoré dôle¾ité v¹eobecné veci, ktoré sú pre
kni¾nicu podstatné. Tie¾ budete potrebova» inicializova» jednotlivé subsystémy,
ktoré budete pou¾íva», ale k tomu sa vrátime neskôr. Odporýèam, aby bola
<code>allegro_init()</code> prvá vec, ktorú spustíte vo va¹ej funkcii
<code>main</code>.

<p>Za tretie, musíte [V Allegro 4 a vývojových verziach] napísa»
<code>END_OF_MAIN()</code> za uzatváraciu zátvorku va¹ej funkcie main. Ak to
nespravíte, vá¹ program sa nebude správne linkova» s kni¾nicou Allegro.

<p>A nakoniec, pri linkovaní musíte prilinkova» kni¾nicu Allegro. Spraví sa to
tak, ¾e na <em>koniec</em> vá¹ho linkovacieho príkazu pridáte
<code>-lalleg</code>. (pozn. prekl. V Linuxe treba prida» aj
<code>-lalleg_unsharable</code>) Linkovací príkaz je ten, ktorý vám vyrobí
spustiteµný súbor; mô¾e to by» jediný príkaz, ktorý pou¾ívate. Ale poèas tohto
tutoriálu vás budem povzbudzova», aby ste va¹e projekty rozdelili na viacero
súborov.

<p>Ako príklad tohto v¹etkého si pozrite súbor <code>test.c</code> v podadresári
<code>examples/test/ex_1</code> hlavného adresára tutoriálu.

<p>V ka¾dom prípade dos» u¾ o tom -- poïme sa mrknú» na zaujímavej¹ie veci.

<p><hr>[ Ïal¹í:<a rel=next href="#Introducing%20graphics">Úvod do grafiky</a>
 | Predo¹lý:<a rel=previous href="#Getting%20installing%20and%20using%20Allegro">Ako získa»,
nain¹talova» a pou¾íva» Allegro</a>
 | Hore:<a rel=up href="#Top">Úvod</a>
 ]<p>

<h1><a name="A%20basic%20game%20structure"><a name="TOC_12">3. Základná ¹truktúra hry</a></a></h1>

<ul>
<li><a href="#What%20does%20a%20game%20need%20to%20do">Èo v¹etko musí hra robi»?</a>

<li><a href="#Proposed%20structure">Návrh ¹truktúry</a>

<li><a href="#Multi-file%20projects">Projekt rozdelený do súborov</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Proposed%20structure">Návrh ¹truktúry</a>
 | Hore:<a rel=up href="#A%20basic%20game%20structure">Základná ¹truktúra hry</a>
 ]<p>

<h2><a name="What%20does%20a%20game%20need%20to%20do"><a name="TOC_13">3.1 Èo v¹etko musí hra robi»?</a></a></h2>

<p>Väè¹ina hier je postavená na rovnakom základnom princípe. Sú samozrejme
výnimky a ja nie som profesionály programátor hier, ale podµa mojich skúseností
nasledovný systém funguje veµmi dobre.


<ol type=1 start=1>
</p><li>Inicializácia

<p>Na zaèiatku potrebujeme dosta» hru do nejakého známeho stavu a zaka¾dým sa to
deje tým istým spôsobom. Napríklad mô¾ete chcie», aby hráè zaèínal v¾dy v strede
obrazovky, vytvori» bludisko alebo vygenerova» náhodnú mapu. V¹etko toto sa 
udeje tu.

</p><li>Hlavný cyklus hry

<p>Hra potrebuje zabezpeèi», aby sa veci diali znova a znova kým hráè neumrie,
nevyhrá, nevzdá sa alebo nieèo také. To sa nám deje v hlavnom cykle hry. Ten má
tri hlavné zlo¾ky:

<ol type=A start=1>
</p><li>Vstup -- získanie vstupu od hráèa

<li>Spracovanie -- zmena stavu vecí, odozva na vstup

<li>Výstup -- odoslanie informácií spä» hráèovi, zvyèajne vykreslením na
obrazovku, ale niekedy aj inými spôsobmi, napríklad prehratím zvukov
</ol>

<li>Záver hry

<p>Keï hra skonèí, mô¾me potrebova» urobi» e¹te nejaké ïal¹ie veci ako napríklad
poveda» hráèovi, preèo hra skonèila, zmeni» tabuµku najlep¹ích výsledkov alebo
nieèo na ten spôsob.

</ol>

<p>V skutoènosti je zvyèajne vy¹¹ie uvedená postupnos» súèas»ou väè¹ieho cyklu,
tak¾e hra sa mô¾e hra» znova a znova bez toho, aby ste sa medzitým v¾dy museli 
vraca» do OS a pred vonkaj¹ím cyklom je tie¾ nejaká inicializácia a po òom
nejaký upratovací kód, napr. nahrávanie tabuµky najlep¹ích výsledkov z disku na
zaèiatku a jej znovuulo¾enie na konci. Pre zaèiatok ale budeme robi» len jeden
beh hry za spustenie.

<p><hr>[ Ïal¹í:<a rel=next href="#Multi-file%20projects">Projekt rozdelený do súborov</a>
 | Predo¹lý:<a rel=previous href="#What%20does%20a%20game%20need%20to%20do">Èo v¹etko musí hra robi»?</a>
 | Hore:<a rel=up href="#A%20basic%20game%20structure">Základná ¹truktúra hry</a>
 ]<p>

<h2><a name="Proposed%20structure"><a name="TOC_14">3.2 Návrh ¹truktúry</a></a></h2>

<p>Takto vyzerá vy¹¹ie opísaná ¹truktúra v jazyku C:

<pre>#include &lt;allegro.h&gt;
#include "game.h"

int end_game;                   /* príznak, ktorý nastavíme, ak chceme skonèi» */

int main (void)
{
    allegro_init();             /* inicializuje kni¾nicu Allegro */
    init();                     /* inicializuje hru */

    end_game = 0;               /* príznak, ¾e konèíme */
    do {                        /* cyklus */
        input();                /* vezmi vstup */
        process();              /* spracuj ho */
        output();               /* vyrob výstup */
    } while (end_game == 0);    /* kým je príznak v poriadku */

    shutdown();                 /* zhoï veci, ktoré potrebuje¹ */
    allegro_exit();             /* pre istotu */
    return 0;                   /* povedz operaènému systému, ¾e je v¹etko O.K. */
}
END_OF_MAIN()
</pre>

<p>V uvedenom príklade je <code>game.h</code> hlavièkový súbor, v ktorom sú
deklarácie funkcií <code>init</code>, <code>input</code>, <code>process</code>,
<code>output</code> a <code>shutdown</code>, ktoré musia by» definované niekde
inde v projekte.

<p><hr>[ Predo¹lý:<a rel=previous href="#Proposed%20structure">Návrh ¹truktúry</a>
 | Hore:<a rel=up href="#A%20basic%20game%20structure">Základná ¹truktúra hry</a>
 ]<p>

<h2><a name="Multi-file%20projects"><a name="TOC_15">3.3 Projekt rozdelený do súborov</a></a></h2>

<p>U¾ som spomínal, ¾e vás budem povzbudzova» k tomu, aby ste svoj zdrojový kód
rozdelili na viacero súborov. Mnohým µuïom sa to zo zaèiatku zdá »a¾ké a nevedia
pochopi», na èo je to dobré. V tejto sekcii tutoriálu mám v úmysle vyjasni» to a
ukáza», ako má podµa mòa vyzera» dobrý sytém organizácie projektu.

<h3>Objasnenie</h3>

<p>Tak¾e najprv, preèo je projekt rozdelený do viacerých súborov dobrá vec? Veï
to vyzerá, ¾e len pribúdajú problémy -- vy¾aduje to vytvára» hlavièkové súbory,
robi» externé deklarácie a máte pocit, ¾e musíte prehµada» viacero súborov, kým
nájdete funkciu, ktorú hµadáte.

<p>V skutoènosti má ale tento prístup mnohé pozitíva. Keï vo svojom kóde zmeníte
jeden riadok, gcc, aby vytvorilo nový spustiteµný súbor, prekompiluje v¹etko.
Ale ak je vá¹ projekt rozdelený do viacerých súborov a vy zmeníte jeden z nich,
gcc u¾ má k dispozícii objektové súbory, ktoré vygenerovalo z va¹ich zdrojových
súborov, keï ste ich kompilovali posledne a teraz potrebuje prekompilova» iba
súbor, ktorý ste zmenili. Pri väè¹ích projektoch to mô¾e znamena» rozdiel v
då¾ke (5 minút alebo viac, v závislosti na rýchlosti poèítaèa) rekompilácie a
dvadsa»sekundovou úpravou.

<p>Pri troche organizáce mô¾e rozdelenie projektu do súborov znaène uµahèi»
hµadanie kusu kôdu, ktorý práve zháòate. Je to jednoduché -- rozdeµte kód medzi
súbory podµa toho, èo robí. Ak potom hµadáte funkciu, ktorá kreslí hráèa, viete,
¾e bude v zdrojovom súbore s grafikou.

<p>Okrem toho, ak je vá¹ program dostatoène modulárny a zdieµánie medzi súbormi
je obmedzené na minimum, µah¹ie sa hµádajú chyby. Ak majú k danej premennej
prístup iba niektoré programy, vadná hodnota musí by» spôsobená chybou v jednom
z týchto súborov.

<h3>Navrhovaný systém</h3>

<p>To, èo bude nasledova» je len môj skromný názor; rôzni µudia si mô¾u chcie»
zariadi» veci rôzne. Ale keï¾e som zistil, ¾e nasledujúce pravidlá sú u¾itoèné,
odporúèam vám dodr¾iava» ich.

<ul>
<li>Nerobte hlavièkové súbory, ktoré obsahujú deklarácie z viacerých zdrojových
súborov (výnimka: hlavièkové súbory pre kni¾nice). Je oveµa jednoduch¹ie na
sledovanie a zvyèajne aj oveµa efektívnej¹ie, ak ka¾dý hlavièkový súbor
deklaruje symboly z jediného zdrojového súboru.

<li>Tam, kde je to vhodné, pou¾ite pre jeden zdrojový súbor viacero
hlavièkových.

<li>Neopakujte informáciu vo viacerých hlavièkových súboroch. Ak to potrebujete,
<code>#include</code>-nite jeden do druhého, ale nepí¹te tú istú informáciu do
hlavièkových súborov dvakrát. Ak budete toti¾ informáciu chcie» zmeni», staèí
vám ju zmeni» raz a vyhnete sa zdåhavému hµadaniu duplicít, ktoré majú by»
zmenené tie¾.

<li>Dbajte na to, aby ka¾dý zdrojový súbor naèítal v¹etky hlavièkové súbory,
ktoré obsahujú deklarácie jeho symbolov. Ak to spravíte, kompilátor vám vychytá
chyby spôsobené tým, ¾e deklarácia v hlavièkovom súbore nesedí s definíciou v
zdrojovom súbore.
</ul>

<p>Dúfam, ¾e ste pochopili výhody rozdelenia vá¹ho projektu, ale ak nechcete,
rozhodne ho nechajte v jednom súbore. Príklady, ktoré budem pou¾íva» neskôr,
budú ¹tandardne mnohosúborové, zalo¾ené na odporúèaniach podaných vy¹¹ie a na
skôr diskutovanej ¹truktúre hry (pozri <a href="#Proposed%20structure">Návrh
¹truktúry</a>), tak¾e budete ma» veµá mo¾ností oceni» výhody tohto prístupu.

<p>Ak ste z toho stále zmätení, pozrite sa, prosím, na èlánok, ktorý som napísal
pre elektronický magazín C-Scene:

<pre>http://www.cscene.org/
</pre>

<p>Èlánok je v èasti 2 a volá sa <cite>Multi-file
projects and the GNU Make utility</cite>. Opakuje informácie spomenuté tu, len¾e
podrobnej¹ie a vysvetµuje zaèiatoèníkom v tejto technike niektoré be¾né problémy. 

<p><hr>[ Ïal¹í:<a rel=next href="#Making%20several%20things%20happen%20at%20once">Ako zariadi», aby
sa niekoµko vecí dialo súèasne</a>
 | Predo¹lý:<a rel=previous href="#A%20basic%20game%20structure">Základná ¹truktúra hry</a>
 | Hore:<a rel=up href="#Top">Zaèiatok</a>
 ]<p>

<h1><a name="Introducing%20graphics"><a name="TOC_16">4. Úvod do grafiky</a></a></h1>

<h2>Poznámka</h2>

<p>Táto èas» predpokladá, ¾e ste oboznámení s pojmami programovania v grafike
ako napríklad súradnicový systém, rozlí¹enie atï. Ak nie ste, aj tak si ju
skúste preèíta»; ak nebudete rozumie», mali by ste si pozrie» nejakú kni¾ku o
poèítaèovej grafike.

<ul>
<li><a href="#Selecting%20a%20graphics%20mode">Nastavenie grafického re¾imu</a>

<li><a href="#Drawing%20things">Kreslenie objektov</a>

<li><a href="#Palette%20manipulation">Práca s paletou</a>

<li><a href="#Simple%20animation">Jednoduchá animácia</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Drawing%20things">Kreslenie objektov</a>
 | Hore:<a rel=up href="#Introducing%20graphics">Úvod do grafiky</a>
 ]<p>

<h2><a name="Selecting%20a%20graphics%20mode"><a name="TOC_17">4.1 Nastavenie grafického re¾imu</a></a></h2>


<p>Aby ste dostali poèítaè do grafického re¾imu, pou¾ite túto funkciu:

<pre>int set_gfx_mode (int <var>card</var>, int <var>w</var>, int <var>h</var>, int <var>v_w</var>, int <var>v_h</var>);
</pre>

<p>Miesto <var>card</var> dajte jednu z <code>GFX_*</code> kon¹tánt, be¾ne
<code>GFX_AUTODETECT</code>. <var>w</var> a <var>h</var> je minimálna ¹írka a
vý¹ka obrazovkového priestoru, ktorú po¾adujete; v závislosti na re¾ime, ktorý
zvolíte, mô¾ete dosta» kúsok väè¹iu plochu. Ako <var>v_w</var> a <var>v_h</var>
dajte zatiaµ 0.


<p><hr>[ Ïal¹í:<a rel=next href="#Palette%20manipulation">Práca s paletou</a>
 | Predo¹lý:<a rel=previous href="#Selecting%20a%20graphics%20mode">Nastavenie grafického re¾imu</a>
 | Hore:<a rel=up href="#Introducing%20graphics">Úvod do grafiky</a>
 ]<p>

<h2><a name="Drawing%20things"><a name="TOC_18">4.2 Kreslenie objektov</a></a></h2>

<ul>
<li><a href="#The%20BITMAP%20struct">©truktúra BITMAP</a>

<li><a href="#Plotting%20pixels">Kreslenie pixelov</a>

<li><a href="#Some%20other%20primitives">Nejaké ïal¹ie primitívy</a>

<li><a href="#Writing%20text">Písanie textu</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Plotting%20pixels">Kreslenie pixelov</a>
 | Hore:<a rel=up href="#Drawing%20things">Kreslenie objektov</a>
 ]<p>

<h3><a name="The%20BITMAP%20struct"><a name="TOC_19">4.2.1 ©truktúra BITMAP</a></a></h3>

<p>Grafické funkcie Allegra nie sú obmedzené na zápis na obrazovku; zapisujú do
<dfn>bitmáp</dfn>. Bitmapa mô¾e by» obrazovka, mô¾e to by» blok pamäte alebo to
mô¾e by» <dfn>podbitmapa</dfn> (èas» inej bitmapy). Keï voláte grafické funkcie
Allegra, dáte im ako parameter smerník na ¹truktúru <code>BITMAP</code>, ktorý
obsahuje informácie o bitmape, do ktorej chcete zapisova».

<p>Najlep¹ie bude, keï si zvyknete na vá¹ smerník pozera» jednoducho ako na
<dfn>odkaz</dfn> na bitmapu -- je to nieèo ako identifikaène èíslo. Allegro na
zaèiatku urèí jeho hodnotu a vy ho potom uvádzate grafickým procedúram, aby ste
im dali vedie», kde majú kresli».

<p>Jediné zaujímavé èasti ¹truktúry <code>BITMAP</code> aspoò pokiaµ sme sa
zaujímali sú polia <code>w</code> a <code>h</code> fields; je v nich ulo¾ená
¹írka a vý¹ka bitmapy v pixeloch.

<p>Allegro definuje premennú <code>screen</code> ako smerník na ¹truktúru
<code>BITMAP</code> reprezentujúcu obrazovku, tak¾e napríklad:

<pre>clear_to_color (screen, 5);
</pre>

<p>vyplní obrazovku farbou 5 (èasto fialová).

<p><hr>[ Ïal¹í:<a rel=next href="#Some%20other%20primitives">Nejaké ïal¹ie primitívy</a>
 | Predo¹lý:<a rel=previous href="#The%20BITMAP%20struct">©truktúra BITMAP</a>
 | Hore:<a rel=up href="#Drawing%20things">Kreslenie objektov</a>
 ]<p>

<h3><a name="Plotting%20pixels"><a name="TOC_20">4.2.2 Kreslenie pixelov</a></a></h3>

<p> Na nakreslenie pixelu pou¾ite funkciu Allegra:

<pre>void putpixel (BITMAP *<var>bmp</var>, int <var>x</var>, int <var>y</var>, int <var>color</var>);
</pre>

<p>Toto nastaví pixel bitmapy <var>bmp</var>, ktorý sa nachádza na súradniciach
<var>x</var>,<var>y</var> na farbu <var>color</var>. Jednoduché.

<p> Ako príklad pou¾itia <code>set_gfx_mode</code>, <code>clear_to_color</code>
a <code>putpixel</code> si pozrite uká¾kový program
<code>examples/chap_04/ex_2_2</code>.

<p><hr>[ Ïal¹í:<a rel=next href="#Writing%20text">Písanie textu</a>
 | Predo¹lý:<a rel=previous href="#Plotting%20pixels">Kreslenie pixelov</a>
 | Hore:<a rel=up href="#Drawing%20things">Kreslenie objektov</a>
 ]<p>

<h3><a name="Some%20other%20primitives"><a name="TOC_21">4.2.3 Nejaké ïal¹ie primitívy</a></a></h3>

Funkcie ako putpixel sa volajú grafické <dfn>primitívy</dfn>, preto¾e sú to
základné grafické výstupné funkcie.

<p>Niektoré ïal¹ie jednoduché grafické funkcie sú:

<pre>void vline(BITMAP *bmp, int x, int y1, int y2, int color);
void hline(BITMAP *bmp, int x1, int y, int x2, int color);
void line(BITMAP *bmp, int x1, int y1, int x2, int y2, int color);
void triangle(BITMAP *bmp, int x1, y1, x2, y2, x3, y3, int color);
void rect(BITMAP *bmp, int x1, int y1, int x2, int y2, int color);
void rectfill(BITMAP *bmp, int x1, int y1, int x2, int y2, int color);
void circle(BITMAP *bmp, int x, int y, int radius, int color);
void circlefill(BITMAP *bmp, int x, int y, int radius, int color);
</pre>

<p>Skúste pozmeni» uká¾kový program z predo¹lej sekcie
(<code>examples/chap_04/ex_2_2</code>) tak, aby ste niektoré z nich
pou¾ili. Informácie o nich nájdete v súbore <code>allegro.txt</code> v
podadresári <code>docs</code> vá¹ho adresára obsahujúceho Allegro.

<p>Ak by ste s tým mali problémy, pozrite sa na príklad
<code>examples/chap_04/ex_2_3</code>.

<p><hr>[ Predo¹lý:<a rel=previous href="#Some%20other%20primitives">Nejaké ïal¹ie primitívy</a>
 | Hore:<a rel=up href="#Drawing%20things">Kreslenie objektov</a>
 ]<p>

<h3><a name="Writing%20text"><a name="TOC_22">4.2.4 Písanie textu</a></a></h3>

<p>Na písanie textu na obrazovku pou¾ite nasledovné funkcie:

<pre>void textout(BITMAP *bmp, FONT *f, unsigned char *s, int x, y, int c);
void textout_center(BITMAP *bmp, FONT *f, unsigned char *s, int x, y, int c);
void textprintf(BITMAP *bmp, const FONT *f, int x, y, int c, const char *fmt, ...);
</pre>

<p><code>bmp</code> je samozreme bitmapa, na ktorú chcete písa».

<p>©truktúra <code>FONT</code> je definovaná v <code>allegro.h</code> a pou¾íva
sa na odkazovanie na rôzne fonty naèítané v pamäti. Väè¹inou ju budete pou¾íva»
rovnako, ako pou¾ívate ¹truktúru <code>BITMAP</code> -- poväè¹ine len budete
smerníky na ne dáva» rôznym funkciam ako parametre  a nebudete potrebova» vedie»
niè o tom, èo sa vo vnútri ¹truktúry nachádza.

<p>Mô¾ete si vytvori» vlastné fonty, pou¾i» fonty z distribúcie GRX (iná
grafická kni¾nica), ktoré pôvodne pochádzajú z XFree86 (okienkoidný systém pre
Unix), alebo skonvertova» fonty z Windowsovského TTF formátu. V ka¾dom z týchto
prípadov musíte vedie» pou¾íva» allegrovský Grabber a datasúbory. Ak chcete viac
informácií mô¾ete si pozrie» súbor <code>grabber.txt</code>, ale o práci s
datasúbormi budeme hovori» v tomto tutoriáli a¾ oveµa neskôr. Zatiaµ mô¾ete do
fukcií písa» <code>font</code>; je to <code>FONT *</code> deklarovaný v
<code>allegro.h</code> a odkazuje na 8x8 BIOS font.

<p><code>s</code> je re»azec, ktorý chcete vypísa», <code>x</code> a
<code>y</code> sú súradnice a <code>c</code> je farba. Ak <code>c</code> je -1 a
font je proporcionálny, Allegro pou¾ije informáciu o farbe obsiahnutú vo fonte,
takto sa dajú pou¾i» viacfarebné fonty.

<p>Funkcia <code>textout_center</code> je takmer rovnaká; jediný rozdiel je, ¾e
text bude vycentrovaný na súradnicu <code>x</code>.

<p>Funkcia <code>textprintf</code> je vhodne obalený <code>textout</code>, ktorý
prijíma formátovací re»azec tým istým spôsobom ako <code>printf</code>.
<code>textout</code> je rýchlej¹í, ale <code>textprintf</code> univerzálnej¹í.

<p>Farba pozadia textového výstupu sa dá nastavi» funkciou

<pre>void text_mode(int mode);
</pre>

<p>kde <code>mode</code> je nová farba pozadia. Ak je <code>mode</code> záporný,
pozadie sa nekreslí a bude viditeµný podklad, ktorý tam bol predtým.

<p>Pohrajte sa s tým sami, alebo sa pozrite na
<code>examples/chap_04/ex_2_4</code>, kde nájdete uká¾ku toho, ako sa to
pou¾íva.

<p><hr>[ Ïal¹í:<a rel=next href="#Simple%20animation">Jednoduchá animácia</a>
 | Predo¹lý:<a rel=previous href="#Drawing%20things">Kreslenie objektov</a>
 | Hore:<a rel=up href="#Introducing%20graphics">Úvod do grafiky</a>
 ]<p>

<h2><a name="Palette%20manipulation"><a name="TOC_23">4.3 Práca s paletou</a></a></h2>

<h3>Poznámka</h3>

<p>V prvom rade treba podotknú», ¾e palety majú význam iba v 8-bitových (256
farieb) re¾imoch. Mô¾ete nastavi» re¾imy aj s vy¹¹ími farebnými håbkami; ak to
urobíte, obsah tejto èasti pre vás nebude ma» význam. Ak chcete informáciu o
vy¹¹ích farebných håbkach, pozrite si dokument Pot of Gold od Shawna
Hargreavesa na ktorý je linka z allegrovských webových stránok odkazujúcich 
na dokumentáciu.

<ul>
<li><a href="#Palette%20explanation">Èo je to paleta</a>

<li><a href="#Changing%20a%20palette%20entry">Zmena polo¾ky palety</a>

<li><a href="#Changing%20the%20entire%20palette">Zmena palety</a>

<li><a href="#Fading%20in%20and%20out">Stmievanie a rozsvecovanie</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Changing%20a%20palette%20entry">Zmena polo¾ky palety</a>
 | Hore:<a rel=up href="#Palette%20manipulation">Práca s paletou</a>
 ]<p>

<h3><a name="Palette%20explanation"><a name="TOC_24">4.3.1 Èo je to paleta</a></a></h3>

<p>Keï chcete kresli» na obrazovku v 8-bitovom re¾ime, musíte urèi» èíslo farby
od 0 do 255. Zvyèajne prvých ¹estnás» farieb býva: èierna, modrá, zelená,
tyrkysová, èervená, fialová, hnedá, svetlo¹edá, tmavo¹edá, ..., svetlofialová,
¾ltá, biela (ale nemusí to tak by» v¾dy).

<p>Zvy¹ných 240 farieb nemusí my» v¾dy rovnakých. Pred tým, ne¾ ich pou¾ijete,
mô¾ete poèítaèu poveda», aká farba sa má objavi» na obrazovke, keï nastavíte
pixelom urèité èíslo farby. Najbezpeènej¹ie je nastavi» v¹etky farby, ktoré
budete pou¾íva», vèetne prvých ¹estnástich; tak si budete istí, ¾e skutoène budú
vyzera» tak, ako chcete, aby vyzerali.

<p>Èísla farieb, ktoré budete uvádza» grafickým funkciam budem nazýva»
<dfn>logické</dfn> farby a farby k ním priradené, ktoré sa objavia na obrazovke
<dfn>fyzické</dfn> farby. A teda potrebujeme funkcie, ktoré priradia logickým
farbám fyzické.

<p>Logické farby sú vyjadrené èíslami od 0 do 255. Ka¾dá mo¾ná fyzická farba je
vyjadrená tromi èíslami, ka¾dé z nich z intervalu od 0 do 63. Tieto èísla
reprezentujú veµkos» èervenej, zelenej a modrej zlo¾ky vo farbe. 63 je
samozrejme maximálna veµkos». Na reprezentáciu fyzických farieb sa pou¾íva
¹truktúra RGB definovaná v <code>allegro.h</code>:

<pre>typedef struct RGB
{
    unsigned char r, g, b;
} RGB;
</pre>

<p>Netreba hovori», ¾e <code>r</code>, <code>g</code> and <code>b</code> sú
intenzity èervenej, zelenej a modrej vo farbe, ako je to popísané vy¹¹ie.

<p><hr>[ Ïal¹í:<a rel=next href="#Changing%20the%20entire%20palette">Zmena celej
palety</a>
 | Predo¹lý:<a rel=previous href="#Palette%20explanation">Èo je to paleta</a>
 | Hore:<a rel=up href="#Palette%20manipulation">Práca s paletou</a>
 ]<p>

<h3><a name="Changing%20a%20palette%20entry"><a name="TOC_25">4.3.2 Zmena
fyzického významu jednej logickej farby</a></a></h3>

<p>Ak chcete zmeni» fyzický význam logickej farby, pou¾ite funkciu

<pre>void set_color (int index, RGB *p);
</pre>

<p><code>index</code> je èíslo logickej farby a <code>p</code> je smerník na RGB
záznam, ako je popísané vy¹¹ie.

<p>Uká¾kový program <code>examples/chap_04/ex_3_2</code> ukazuje pou¾itie tejto
funkcie - ako stláèate klávesy, farba 0 (farba pozadia) nadobúda rôzne hodnoty.
Ak chcete  skonèi», stlaète &lt;ESC&gt;.

<p>Pripomeòme, ¾e je tu jedna drobná komplikácia -- ak sa pokú¹ate meni» farby
rýchle za sebou, mali by ste medzi zmenami vola» funkciu Allegra
<code>vsync</code> (ktorá tie¾ pridá isté zdr¾anie). Hlavný dôvod je ten, ¾e
niektoré grafické karty nemajú radi, ak im brnkáte po palete, keï sa sna¾ia
kresli» po obrazovke, niekedy potom zobrazia nesprávne farby a vyzerá to ako
zasne¾ené. <code>vsync</code> poèká, kým monitor dokreslí obrazovku, èo problém
odstráni. O <code>vsync</code> si neskôr e¹te nieèo povieme.

<p><hr>[ Ïal¹í:<a rel=next href="#Fading%20in%20and%20out">Stmievanie a rozsvecovanie</a>
 | Predo¹lý:<a rel=previous href="#Changing%20a%20palette%20entry">Zmena polo¾ky palety</a>
 | Hore:<a rel=up href="#Palette%20manipulation">Práca s paletou</a>
 ]<p>

<h3><a name="Changing%20the%20entire%20palette"><a name="TOC_26">4.3.3 Zmena celej
palety</a></a></h3>

<p>Ak chceme zmeni» celú paletu naraz, mohli by sme opakovane vola»
<code>set_color</code>, ale bolo by to pomalé a ne¹ikovné. Miesto toho
<code>allegro.h</code> definuje typ <code>PALETTE</code> ako pole 256 RGB
záznamov, jeden pre ka¾dú logickú farbu. V tomto poli mô¾ete vytvori» celú
vlastnú paletu a potom ju nastavi» jedným volaním funkcie

<pre>void set_palette (PALETTE p);
</pre>

<p> Príklad <code>examples/chap_04/ex_3_3</code> demon¹truje túto funkciu tak,
¾e nakreslí dúhu farieb a potom prepne paletu na èiernobielu.

<p><hr>[ Predo¹lý:<a rel=previous href="#Changing%20the%20entire%20palette">Zmena celej
palety</a>
 | Hore:<a rel=up href="#Palette%20manipulation">Práca s paletou</a>
 ]<p>

<h3><a name="Fading%20in%20and%20out"><a name="TOC_27">4.3.4 Stmievanie a rozsvecovanie</a></a></h3>

<p>V málofarebných re¾imoch (napr. 256 farieb) je to jednoduché: ak chcete
spravi» stmievanie, spravte paletu tmav¹iu a tmav¹iu a¾ bude v¹etko èierne, pri
rozsvecovaní to urobte naopak.

<p>Allegro má niekoµko funkcií, ktoré to robia; najzákladnej¹ie sú:

<pre>void fade_in (PALETTE p, int speed);
void fade_out (int speed);
</pre>

<p>Poznamenajme, ¾e <code>fade_in</code> chce, aby ste jej povedali, do akej
palety treba rozsvieti»; <code>fade_out</code> to nepotrebuje, preto¾e
predpokladá, ¾e sa bude stmieva» z aktuálnej palety.

<p><code>speed</code> je rýchlos» stmievania v intervale od 1 do 64, kde 64
znamená okam¾itú zmenu.

<p><code>examples/chap_04/ex_3_4</code> ukazuje pou¾itie týchto funkcií.


<p><hr>[ Predo¹lý:<a rel=previous href="#Palette%20manipulation">Práca s paletou</a>
 | Hore:<a rel=up href="#Introducing%20graphics">Úvod do grafiky</a>
 ]<p>

<h2><a name="Simple%20animation"><a name="TOC_28">4.4 Jednoduchá animácia</a></a></h2>

<ul>
<li><a href="#What%20is%20animation">Èo je to animácia</a>

<li><a href="#Making%20things%20appear%20to%20move">Ako urobi», aby veci
vyzerali, ¾e sa hýbu</a>

<li><a href="#Reducing%20flicker">Zní¾enie blikania</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Making%20things%20appear%20to%20move">Ako urobi», aby veci
vyzerali, ¾e sa hýbu</a>
 | Hore:<a rel=up href="#Simple%20animation">Jednoduchá animácia</a>
 ]<p>

<h3><a name="What%20is%20animation"><a name="TOC_29">4.4.1 Èo je to animácia?</a></a></h3>

<p>Animácia je, keï spôsobíte, ¾e to vyzerá, ¾e sa veci hýbu. Mô¾e to 
znamena», ¾e vám po obrazovke pobehuje pixel, ale zvyèajne sa tým myslí, ¾e
dookola meníte výzor nieèoho tak, ¾e vyzerá, ¾e sa to hýbe.

<p>Teraz sa pozrieme iba na to, ako pohybova» po obrazovke s jednoduchými 
vecami; druhá interpretácia bude rozobratá neskôr, keï sa pozrieme na sprity.

<p><hr>[ Ïal¹í:<a rel=next href="#Reducing%20flicker">Zní¾enie blikania</a>
 | Predo¹lý:<a rel=previous href="#What%20is%20animation">Èo je to animácia</a>
 | Hore:<a rel=up href="#Simple%20animation">Jednoduchá animácia</a>
 ]<p>

<h3><a name="Making%20things%20appear%20to%20move"><a name="TOC_30">4.4.2 Ako urobi», aby veci
vyzerali, ¾e sa hýbu</a></a></h3>

<p>Najjednoduch¹í spôsob, ako vytvori» zdanie, ¾e sa nieèo hýbe, je zmaza» to na
tom mieste, kde to je a znovu to vykresli» na obrazovku niekde inde. Je otázkou
pre filozofov, èi to je skutoène pohyb; ale keï¾e to aj tak neexistuje, nie je
veµmi dôvod trápi» sa tým. A tak budeme hovori», ¾e sa to pohlo.

<p>Na to, aby vyplnený kruh pre¹iel cez obrazovku, mô¾ete urobi» nieèo takéto:

<pre>int x;
install_timer();                           /* potrebuje to `rest' */
circlefill (screen, 0, 100, 5, 15);        /* nakreslí prvýkrát */
for (x = 1; x &lt; 320; x++) {               /* cyklus cez obrazovku */
    rest (10);                             /* spomaµ */
    circlefill (screen, x - 1, 100, 5, 0); /* vyma¾ tam, kde to bolo */
    circlefill (screen, x, 100, 5, 15);    /* nakresli na novom mieste */
}
</pre>

<p>Vyskú¾ajte, èi to funguje. Teraz to skúste s väè¹ím polomerom (povedzme 50) a
pozrite sa, èo sa stane.

<p><hr>[ Predo¹lý:<a rel=previous href="#Making%20things%20appear%20to%20move">Ako urobi», aby veci
vyzerali, ¾e sa hýbu</a>
 | Hore:<a rel=up href="#Simple%20animation">Jednoduchá animácia</a>
 ]<p>

<h3><a name="Reducing%20flicker"><a name="TOC_31">4.4.3 Zní¾enie blikania</a></a></h3>

<p>No áno - zaèalo to trochu blika». Ak nezaèalo, skúste to s väè¹ím kruhom. Ak
stále nezaèalo, hmm, zaène ak pou¾ijete re¾im obrazovky s vy¹¹ím rozlí¹ením
(vyskú¹ajte si to). Ak to ani tak nezaèalo blika», potom gratulujem, máte
superpoèítaè.

<p>My, obyèajní smrteµníci, ale s tým blikaním nieèo budeme musie» urobi». Je
viacero mo¾ných prístupov; niektoré sú komplikovanej¹ie ne¾ iné, niektoré
efektívnej¹ie a niektoré sú jednoducho dobré, preto¾e ne¾erú toµko procesorového
èasu (a teda hry mô¾u be¾a» s vy¹¹ou obnovovacou frekvenciou).


<ul>
<li><a href="#Synchronising%20to%20the%20vertical%20retrace">Synchronizácia na
zatemnenie</a>

<li><a href="#Maximising%20drawn%20time">Maximalizácia èasu vykreslenia</a>

<li><a href="#Optimising%20drawing%20order">Optimalizácia poradia vykreslenia</a>

<li><a href="#Double%20buffering">Dvojitý buffering</a>

<li><a href="#Dirty%20rectangles">©pinavé obdå¾niky</a>

<li><a href="#Alternate%20line%20blitting">Striedavé vykreslovanie riadkov</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Maximising%20drawn%20time">Maximalizácia èasu vykreslenia</a>
 | Hore:<a rel=up href="#Reducing%20flicker">Zní¾enie blikania</a>
 ]<p>

<h4><a name="Synchronising%20to%20the%20vertical%20retrace"><a name="TOC_32">4.4.3.1 Synchronizácia na
zatemnenie</a></a></h4>

<p>Toto je najdôle¾itej¹ia vec, ktorú treba urobi». Zatemnenie je èasový úsek,
poèas ktorého sa vá¹ monitor pripravuje na vykreslenie nového rámca. Poèas tohto
èasu sa niè na obrazovke nedeje, tak¾e ak stihneme vymaza» objekt a znovu ho
nakresli», kým monitor  zaène s novým rámom, je po probléme.

<p>Funkcia <code>vsync</code> èaká, kým sa nezaène ïal¹ie zatemnenie. Keï to
nastane, treba prekresli» obrazovku tak rýchlo, ako je to mo¾né. Tak¾e nahraïte
<code>rest(10)</code> funkciou <code>vsync()</code> a skúste to znovu. Oveµa
lep¹ie.

<p>Pripomeòme, ¾e zatemnenie je svojim spôsobom nieèo ako èasovaè. Objavuje sa v
pravidelných intervaloch (pre daný grafický re¾im; medzi jednotlivými re¾imami
sa to lí¹i). Z toho vyplýva, ¾e (okrem toho, ¾e ho aj tak pou¾ívame na
synchronizáciu) to mô¾e by» u¾itoèný spôsob, ako regulova»
rýchlos» hry. V kapitole 9 sa ale dajú nájs» aj lep¹ie spôsoby, ako sa to dá
urobi» - budeme tam hovori» o systéme èasovaèov, ktorý Allegro obsahuje.

<p><hr>[ Ïal¹í:<a rel=next href="#Optimising%20drawing%20order">Optimalizácia poradia vykreslenia</a>
 | Predo¹lý:<a rel=previous href="#Synchronising%20to%20the%20vertical%20retrace">Synchronizácia na
zatemnenie</a>
 | Hore:<a rel=up href="#Reducing%20flicker">Zní¾enie blikania</a>
 ]<p>

<h4><a name="Maximising%20drawn%20time"><a name="TOC_33">4.4.3.2 Maximalizácia èasu vykreslenia</a></a></h4>

<p>Ak toho máme na kreslenie príli¹ veµa, tak to v¹etko nezvládneme poèas
jedného zatemnenia. Potrebujeme teda blikanie zní¾i» nejakým iným spôsobom.
Predstavte si situáciu, ¾e máme mno¾stvo kruhov, a predtým, ne¾ ich prekreslíme,
ich v¹etky vyma¾eme. Budú vymazané pomerne dlhý èas; je preto veµká
ôravdepodobnos», ¾e sa monitor bude sna¾i» zobrazi» èas» obrazovky vtedy, keï
e¹te nebudú vykreslené.

<p>Tento problém mô¾eme vyrie¹i» tak, ¾e ich budeme prekreslova» jeden po
druhom. Mô¾e to pomôc» zní¾i» blikanie, ale mô¾e to vies» k iným problémom. To,
èo je podstatné ale je, ¾e je rozumné sna¾i» sa o to, aby boli veci vykreslené
èo najdlh¹ie.

<p>Ak napríklad zma¾ete v¹etky va¹e objekty a a¾ potom zis»ujete, kde budú
vykreslené, nie sú na obrazovke po celý èas výpoètu. Ak spravíte výpoèty pred
tým, ne¾ ich zma¾ete, budú na obrazovke dlh¹ie a èas, keï sú preè, sa skráti.

<p><hr>[ Ïal¹í:<a rel=next href="#Double%20buffering">Dvojitý buffering</a>
 | Predo¹lý:<a rel=previous href="#Maximising%20drawn%20time">Maximalizácia èasu vykreslenia</a>
 | Hore:<a rel=up href="#Reducing%20flicker">Zní¾enie blikania</a>
 ]<p>

<h4><a name="Optimising%20drawing%20order"><a name="TOC_34">4.4.3.3 Optimalizácia poradia vykreslenia</a></a></h4>

<p>Ako sme poznamenali vy¹¹ie, niekedy nestihneme celé vykreslenie poèas jedného
zatemnenia. Èo sa stane potom? Monitor zaène prekreslova» obrazovku z hora dole.
Tak¾e ak máme nakreslenú iba èas», je lep¹ie, ak je horná èas» obrazovky v
poriadku, keï ju monitor zaène prekreslova».

<p>V podstate ide o to, aby práve nebolo vymazané nieèo, èo sa monitor pokú¹a
zobrazi». ®iaµ, ak nemáme k dispozícii èasovaè s veµmi vysokým rozlí¹ením,
nevieme poveda», ktorá èas» obrazovhy sa práve prekresµuje. A ak taký èasovaè
máme, má to zas iné tienisté stránky.

<p>Rozumné mô¾u by» rôzne poradia vykresµovania. Mô¾ete vykresµova» veci od hora
nadol. Toto okrem iného urýchli prekresµovanie rámcov v re¾imoch s vy¹¹ím
rozlí¹ením/farebnou håbkou zredukovaním prepínaní rozsahu videa. (??? This also
improves the frame redraw speed in higher resolution/colour depth modes by
reducing video bank switches.) Tie¾ mô¾ete zvá¾i», aké zlo¾ité sú jednotlivé
objekty a zaèa» prekresµovanie od jednoduch¹ích.

<p>Iná technika je vykreslovanie <em>zdola nahor</em>. Mô¾e to znie» zvlá¹tne,
ale ak to tak spravíte, zatemnenie stihnete len raz a to na kratuèký moment. Ak
budete pou¾íva» tento systém, dôjde asi k nejakému blikaniu, ale pravdepodobne
to nebude a¾ také tragické.

<p>Mô¾ete si to predstavi» ako rýchlu jazdu autom na diaµnici, poèas ktorej sa
pozeráte boèným oknom. (Uistite sa, ¾e ¹oféruje niekto iný.) Sna¾íte sa ma»
dobrý výhµad na ¾ivý plot. Autá, ktoré idú tým istým smerom ako vy, majú nízku
relatívnu rýchlos» a teda stoja v ceste vá¹mu výhµadu na ¾ivý plot dlh¹iu dobu.
Zato autá ktoré idú v protismere blokujú vá¹ výhµad len veµmi krátko.

<p><hr>[ Ïal¹í:<a rel=next href="#Dirty%20rectangles">©pinavé obdå¾niky</a>
 | Predo¹lý:<a rel=previous href="#Optimising%20drawing%20order">Optimalizácia poradia vykreslenia</a>
 | Hore:<a rel=up href="#Reducing%20flicker">Zní¾enie blikania</a>
 ]<p>

<h4><a name="Double%20buffering"><a name="TOC_35">4.4.3.4 Dvojitý buffering</a></a></h4>

<p>Toto je veµmi populárny a jednoduchý systém, ktorý funguje dobre v rýchlych
grafických re¾imoch (teda tých s nízkym rozlí¹ením). Nov¹ie grafické karty (AGP
a v men¹ej miere PCI) ho mô¾u pou¾i» aj pri vy¹¹ích rozlí¹eniach.

<p>Technika dvojitého bufferingu znamená, ¾e celý grafický výstup sa zapisuje do
doèasnej bitmapy, kým nie je prekreslený celý rámec a výsledný obraz sa potom
skopíruje do reálnej videopamäte ako jeden veµký kus.

<p>Toto mô¾e by» efektívne z viacerých dôvodov. Po prvé, znamená to, ¾e z
obrazovky nemusíme niè maza» -- iba nahradíme jeden obraz (na ktorom je v¹etko
vykreslené) iným (na ktorom je tie¾ v¹etko vykreslené).

<p>Po druhé, videopamä» je o dos» pomal¹ia. Ak mienime poèas vykresµovania rámca
èastokrát prepisova» jednotlivé oblasti, bude rýchlej¹ie, ak to v¹etko zapí¹eme
do (rýchlej) systémovej pamäte a potom to skopírujeme do (pomalej) videopamäte,
ne¾ keby sme zapisovali priamo na obrazovku. Navy¹e èítanie z videopamäte je
dokonca e¹te pomal¹ie; a teda ak budeme chcie» èíta» z obrázka, je oveµa lep¹ie
èíta» z kópie v systémovej pamäti. Je to nieèo podobné ako vyrovnávacia pamä»
disku, kde sa èasti disku uchovávajú v systémovej pamäti aby sa vyhlo priamemu
prístupu na disk.

<p>Tak teda namiesto kreslenia na obrazovku, kreslíme do inej bitmapy v pamäti.
Potom, keï sme hotoví, zavoláme <code>vsync()</code> a potom celý zásobník
(buffer) skopírujeme na obrazovku. V re¾ime 320x200x256 sa to s rezervou vojde
do prekreslovacieho intervalu, tak¾e k ¾iadnemu blikaniu nedôjde. Pri vy¹¹ích
rozlí¹eniach alebo farebných håbkach je treba samozrejme skopírova» viac
obrazových dát a teda to trvá dlh¹ie. Dôsledky mô¾u by» rôzne, poènúc rozdelením
(kde je na hornej èasti obrazovky vykreslený jeden rámec a na dolnej druhý) a
konèiac zní¾ením frekvencie vykresµovania (preto¾e vykresµovanie trvá pridlho,
tak¾e zme¹káme ïal¹iu prekresµovaciu periódu, tak¾e <code>vsync</code> bude
èaka» a¾ na tú, ktorá nasleduje po nej).

<p>Pozrite si uká¾kový prgram <code>examples/chap_04/ex_4</code>. Nechceme
zatiaµ rozobera» príli¹ podrobne pamä»ové bitmapy a funkciu blit; vrátime sa k
tomu podrobnej¹ie v kapitole 7.

<p><hr>[ Ïal¹í:<a rel=next href="#Alternate%20line%20blitting">Striedavé vykreslovanie riadkov</a>
 | Predo¹lý:<a rel=previous href="#Double%20buffering">Dvojitý buffering</a>
 | Hore:<a rel=up href="#Reducing%20flicker">Zní¾enie blikania</a>
 ]<p>

<h4><a name="Dirty%20rectangles"><a name="TOC_36">4.4.3.5 ©pinavé obdå¾niky</a></a></h4>

<p>Toto je varianta dvojitého bufferingu, ktorá nevy¾aduje taký rýchly grafický
re¾im, ale je »a¾¹ia na programovanie. Teoreticky to vyzerá tak, ¾e spravíte
presne to isté, ako pri dvojitom bufferingu, teda v¹etko vykreslíte do pamä»ovej
bitmapy, ale potom na obrazovku skopírujete iba tie oblasti, ktoré sa zmenili.

<p>To ale znamená, ¾e treba sledova», ktoré oblasti sa zmenili; Najjednoduch¹í
spôsob je oznaèi» obdå¾niky ako <dfn>¹pinavé</dfn> keï do nich pí¹ete. Potom
mô¾ete µahko tieto obdå¾niky skopírova» na obrazovku.

<p>Tento prístup je lep¹í ne¾ dvojitý buffering, ak sa toho veµa nezmenilo. Ak
bolo zmien veµa, mô¾e sa ukáza» ako hor¹í, èiastoène preto, lebo jednorázové
prekreslenie veµkej plochy je efektívnej¹ie, ne¾ mnoho prekreslení men¹ích
oblastí a èiastoène preto, ¾e sa jednotlivé ¹pinavé obdå¾niky mô¾u prekrýva»;
pokiaµ sa nepostaráte o to, aby sa tak nestalo, budú sa niektoré èasti obrazu
prekresµova» dvakrát. Av¹ak ak situácie v ktorých bude jednoduch¹ie pou¾i»
dvojitý buffering viete rozpozna», mô¾ete jednoducho skopírova» celý obraz
naraz, ako pri dvojitom bufferingu. Tieto dve techniky majú mnoho spoloèné.

<p>©pinavé obdå¾niky sú nároènej¹ie na realizáciu a ak spravíte malú chybièku,
mô¾ete sa doèka» podivných výsledkov. V kapitole 7 sa vrátime aj k tejto téme.

<p><hr>[  Predo¹lý:<a rel=previous href="#Dirty%20rectangles">©pinavé obdå¾niky</a>
 | Hore:<a rel=up href="#Reducing%20flicker">Zní¾enie blikania</a>
 ]<p>

<h4><a name="Alternate%20line%20blitting"><a name="TOC_37">4.4.3.6 Striedavé vykreslovanie riadkov</a></a></h4>

<p>Toto je ïal¹ia varianta dvojitého bufferingu. Hlavná my¹lienka je kopírova»
na obrazovku iba ka¾dý druhý riadok. Mô¾ete kopírova» iba párne riadky a nepárne
necha» èierne. Dostanete tak trochu tmav¹í obraz s efektívne zní¾eným zvislým
rozlí¹ením. Tie¾ mô¾ete skopírova» párne riadky v jednom rámci a nepárne v
ïal¹om. Takto nestratíte jas obrazu, ale niektoré riadky budú "star¹ie", ne¾
iné, èo spôsobí malé rozmazanie obrazu. Tieto techniky sa uplatòujú najlep¹ie vo
veciach ako video.

<p><hr>[ Ïal¹í:<a rel=next href="#User%20input">U¾ivateµský vstup</a>
| Predo¹lý:<a rel=previous href="#Introducing%20graphics">Úvod do grafiky</a>
 | Hore:<a rel=up href="#Top">Zaèiatok</a>
 ]<p>

<h1><a name="Making%20several%20things%20happen%20at%20once"><a name="TOC_38">5.Ako zariadi», aby sa niekoµko vecí dialo súèasne </a></a></h1>

<ul>
<li><a href="#More%20circles">Ïal¹ie kruhy</a>
	
<li><a href="#Squares%20too">Aj ¹tvorce</a>

<li><a href="#Keeping%20track%20of%20things">Uchovávanie viacerých vecí</a>

<li><a href="#Object%20Oriented%20Programming">Objektovo orientované
programovanie</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Squares%20too">Aj ¹tvorce</a>
 | Hore:<a rel=up href="#Making%20several%20things%20happen%20at%20once"Ako zariadi», aby sa niekoµko vecí dialo súèasne></a>
 ]<p>

<h2><a name="More%20circles"><a name="TOC_39">5.1 Pohyb viacerých kruhov</a></a></h2>

<p>Znie to celkom jednoducho a aj mô¾e by», ale znova uká¾eme viacero spôsobov, ako sa to dá urobi». Na¹im cieµom bude, aby sa to hodilo do ¹truktúry hry, ktorá bola prezentovaná skôr.

<p>Na to, aby sme mali pohromade v¹etky údaje, ktoré popisujú ka¾dý kruh -- jeho
umiestnenie, farbu, polomer, rýchlos», ktorou sa pohybuje v ka¾dom smere, budeme
pou¾íva» ¹truktúru. Tie¾ bude výhodné zapamäta» si, kde bol kruh nakreslený, aby
sme si zjednodu¹ili mazanie. Tak¾e zaènime definíciou ¹truktúry:

<pre>struct circle_t {
    int x,y,r;         /* x, y, polomer */
    int col;           /* farba */
    int xs,ys;         /* x rýchlos», y rýchlos» */
    int dx,dy;         /* nakreslene x, nakreslene y */
};
</pre>

<p>Ïalej, dobrý spôsob, ako písa» modulárny kód ako tento je najprv popremý¹µa»
trochu o rozhraní; rozhodnite sa, èo má vrstva, ktorá bude modul pou¾íva»,
vidie». Potom mô¾ete napísa» funkcie, zatiaµ staèí len zhruba urèi», èo budú
robi» -- alebo mô¾ete napísa» programy, ktoré ich volajú, dokonca bez toho, ¾e
by ste urobili volané funkcie. Výhoda tohto prístupu je, ¾e ak máte viac ne¾
jedného èloveka, ktorý na hre pracuje, jeden z vás mô¾e písa» obslu¾né programy
objektu a druhý program, ktorý ich volá.

<p>Ïal¹ou výhodou, ktorú uvidíme neskôr je, ¾e do tohoto typu systému je
jednoduché prida» nové objekty -- v¹etky objekty budú pou¾íva» tie isté funkcie
rozhrania. A tak èlovek, ktorý pí¹e program, ktorý volá v¹etky obslu¾né
programy objektu mô¾e zaèa» s pou¾itím fiktívnych objektov, ktoré toho veµa
nerobia, aby skontroloval, èi obsluha vlasne funguje; reálne objekty mô¾u by»
pridané neskôr.

<p>Poïme rozhodnú», aké funkcie by ka¾dý objekt mohol ma». V ideálnom prípade
chceme ma» pre kruh k dispozícii nasledovné funkcie: funkciu, ktorá ho nakreslí,
funkciu, ktorá ho zma¾e a funkciu, ktorá upraví vnútorné premenné. Tieto funkcie
budú èasto volané z vnútorného cyklu hry. Okrem toho potrebujeme funkciu, ktorá
ho vytvorí a inicializuje jeho vnútorné premenné, spolu s funkciou, ktorá ho
zlikviduje. Táto funkcia v tomto konkrétnom prípade nebude robi» veµa, ale mohla
by, ak by napríklad bolo nutné uvoµni» dynamicky alokovanú pamä» potrebnú pre
kruh.

<p>Prototypy na¹ich funkcií mô¾u vyzera» nasledovne:

<pre>void circle_draw (struct circle_t *circle, BITMAP *bmp);
void circle_erase (struct circle_t *circle, BITMAP *bmp);
void circle_update (struct circle_t *circle);
struct circle_t *circle_init (int new_x, int new_y, int new_radius, int new_col, int new_xs, int new_ys);
void circle_destroy (struct circle_t *circle);
</pre>

<p>V¹imnite si, ¾e som mená funkcií zvolil tak, aby zaèínali na
<code>circle_</code>. Je u¾itoèné urobi» to, preto¾e tieto funkcie budú globálne
a nechceme, aby dochádzalo ku kolíziam s funkciami, ktoré obsluhujú iné typy
objektov. Zaèiatok názvu nás tie¾ upozorní, ¾e patria do modulu "kruh". Keby sme
si tým neboli istí, mohli by sme sa samozrejme pozrie» do hlavièkového súboru,
aby sme zistili, do ktorého modulu vlastne patria, ale je rýchlej¹ie, keï to
viete zisti» iba pohµadom na meno funkcie.

<p>Budeme ma» pole smerníkov na ¹truktúry <code>circle_t</code> a na¹a hlavná
funkcia <code>init</code> ich v¹etky inicializuje s pomocou volania
<code>circle_init</code> s rôznymi parametrami.

<p>Keï u¾ sú inicializované, tak ich e¹te predtým, ne¾ odídeme z funkcie
<code>init</code> vykreslíme.

<p>Funkcia <code>input</code> zatiaµ nebude robi» niè okrem toho, ¾e nastaví
príznak "koniec hry" (premenná <code>end_game</code>), ak bolo stlaèené
&lt;ESC&gt;. Pou¾itie klávesnice bude vysvetlené v ïal¹ej èasti. 

<p>Vo funkcii <code>process</code> vypoèítame novú polohu v¹etkých kruhov.
Pou¾ijeme na to for cyklus, ktorý prejde pole kruhov a zavolá
<code>circle_update</code> pre ka¾dý z nich.

<p>Vo funkcii <code>output</code> budeme potrebova» podobný cyklus, ktorý pre
ka¾dý kruh zavolá <code>circle_draw</code>. Vo väè¹ine prípadov (zále¾í od toho,
ktorú animaènú techniku pou¾ijeme) budeme najprv musie» zavola» funkciu
<code>circle_erase</code>.

<p>Na záver, keï skonèíme, je slu¹né uvoµni» z pamäte kruhy vytvorené s pomocou
<code>circle_init</code> funkciou <code>circle_destroy</code>.

<p>Teraz by som vám navrhol, aby ste sa pokúsili naprogramova» to sami pre
jeden kruh a potom program roz¹íri» tak, aby sa ich hýbalo viacero. Uká¾kové
programy <code>examples/chap_05/1_a</code> a <code>examples/chap_05/1_b</code>
demon¹trujú, ako sa to robí. Ak by ste mali problémy s vytvorením programu,
ktorý hýbe len jedným kruhom, navrhujem vám pozrie» si prvý príklad a pokúsi» sa
ho upravi» tak, aby hýbal s viacerými kruhmi.

<p>V¹imnite si, ¾e v prípade, ¾e hýbete viacerými kruhmi, ak ich ma¾ete a
vykreslujete jeden po druhom, mazanie ïal¹ích mô¾e vygumova» kúsok z u¾
vykreslených. Rie¹i sa to tak, ¾e vyma¾ete v¹etky kruhy naraz a potom ich v¹etky
nakreslíte. Toto ale mô¾e zväè¹i» blikanie obrazovky (pamätáte sa na
maximalizáciu èasu vykreslenia?), ak nepou¾ívate dvojitý buffering.

<p><hr>[ Ïal¹í:<a rel=next href="#Keeping%20track%20of%20things">Uchovávanie viacerých vecí</a>
 | Predo¹lý:<a rel=previous href="#More%20circles">Ïal¹ie kruhy</a>
 | Hore:<a rel=up href="#Making%20several%20things%20happen%20at%20once">Ako zariadi», aby sa niekoµko vecí dialo súèasne</a>
 ]<p>

<h2><a name="Squares%20too"><a name="TOC_40">5.2 Ako prida» pohyb ¹tvorcov</a></a></h2>

<p>Vy¹¹ie opísaná technika je vhodná, ak máme mnoho podobných objektov. Ale v
reálnej hre je zvyèajne mnoho rôznych typov objektov. Tak sa teda pozrime na
nejaké spôsoby, ako narába» napríklad so ¹tvorcami súèasne s kruhmi.

<p>Jedno rie¹enie je prida» do ¹truktúry informácie, ktoré jej umo¾nia popísa»,
èi sa jedná o kruh alebo o ¹tvorec tak, ¾e pridáme premennú, ktorá to rozlí¹i.
Potom mô¾eme modifikova» funkcie tak, aby rozli¹ovali oba prípady a kreslili ich
róznym spôsobom. Niektoré funkcie dokonca nebude treba meni».

<p>Iné rie¹enie je vytvori» novú ¹truktúru pre ¹tvorce a nový súbor funkcií,
ktoré s nimi budú narába».

<p>Obe tieto techniky majú svoje výhody. Prvá je vhodná vtedy, keï sú dva typy
objektov veµmi podobné; v takýchto prípadoch nebude nutné mnoho funkcií meni».
V¹etky objekty mô¾u by» ulo¾ené v jednom poli a bude staèi» jeden cyklus na to,
aby boli vykreslené, aby sa pohli atï. Navy¹e podobnos» mô¾e by» vyu¾itá tak, ¾e
mô¾eme vytvori» spoloèné procedúry pre veci ako zis»ovanie kolízie.

<p>Druhá technika je vhodná, ak sú objekty úplne rôzne. V takom prípade je
ne¹ikovné robi» ¹truktúru, ktorá bude udr¾iava» dáta pre v¹etky z niekoµkých
objektov a funkcie nebudú ma» príli¹ veµa kódu spoloèného. Pri pou¾ití tejto
techniky potrebujete zvlá¹tne pole pre ka¾dý typ objektu a ak chcete
vykresµova»/maza»/meni» objekty, musíte prezera» polia jedno po druhom.

<p>V praxi sada viacerých rôznych typov objektov mô¾e by» rozdelená do tried
typov objektov. Kritériom napríklad mô¾e by» správanie, výzor alebo to, ktorému
hráèovi objekt patrí. S ka¾dou triedou sa potom mô¾e zaobchádza» prvým zo
zmienených systémov a bude ma» spoloènú ¹truktúru, ktorá bude schopná popísa»
ka¾dý objekt v tejto triede. Rozdielne triedy sú potom spravované ako rôzne
objekty druhým systémom.

<p>Ak ste tomu porozumeli, pokúste sa vy¹¹ie uvedený program na pohyb viacerých
kruhov upravi» tak, aby sa tam hýbali aj ¹tvorce s pou¾itím ka¾dej z uvedených
dvoch metód. V prípade, ¾e zatuhnete, sú tu uká¾ky, na ktoré sa mô¾ete pozrie»:
<code>examples/chap_05/ex_2_a</code> a <code>examples/chap_05/ex_2_b</code>. Ak
sa vám nepodarí urobi» to vlastným spôsobom, pozrite si ich a pokúste sa do
ka¾dej prida» ïal¹í typ objektov.

<p>Ako cvièenie zalo¾ené na zmie¹anej technike sa pokúste urobi» program, kde sa
budú hýba» ¹tvorce, obdå¾niky a<small>...</small> hmmm<small>...</small>
trojuholníky (ktoré budú prechádza» hranicu!), prièom ¹tvorce a obdå¾niky sa
budú hýba» tak, ako predtým, ale trojuholníky sa nebudú odrá¾a»; spravte to tak,
¾e sa vrátia na plochu z opaènej strany, ne¾ je tá, kadiaµ odi¹li. Príklad
tohoto programu je <code>examples/chap_05/ex_2_c</code>; mô¾ete ho spusti», aby
ste videli, èo to robí a potom sa pokúste napodobni» jeho správanie va¹im
vlastným programom.

<p><hr>[ Ïal¹í:<a rel=next href="#Object%20Oriented%20Programming">Objektovo orientované
programovanie</a>
 | Predo¹lý:<a rel=previous href="#Squares%20too">Aj ¹tvorce</a>
 | Hore:<a rel=up href="#Making%20several%20things%20happen%20at%20once">Ako zariadi», aby sa niekoµko vecí dialo súèasne</a>
 ]<p>

<h2><a name="Keeping%20track%20of%20things"><a name="TOC_41">5.3 Uchovávanie viacerých vecí</a></a></h2>

<p>Predpokladajme, ¾e chceme poèas behu programu meni» poèet útvarov. Vo
v¹etkých predo¹lých príkladoch bol poèet útvarov jednotlivých tvarov dopredu
daný. Mô¾eme poèet útvarov zní¾i» tak, ¾e skrátime cyklus, ale takto v¾dy
odstránime posledný útvar v zozname a okrem toho nemáme mo¾nos» útvary prida»
(pokiaµ predtým nejaké neznièíme). Skrátka to, èo hra mô¾e robi», je limitované v
èase kompilácie veµkos»ou polí.

<p>Sú dve techniky, ktoré by som tu chcel predstavi»: dynamická alokácia a
zre»azené zoznamy. Zre»azené zoznamy závisia od dynamickej alokácie, tak¾e túto
sekciu budete pravdepodobne èíta» ako prvú.

<ul>
<li><a href="#Dynamic%20allocation">Dynamická alokácia</a>

<li><a href="#Linked%20lists">Zre»azené zoznamy</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Linked%20lists">Zre»azené zoznamy</a>
 | Hore:<a rel=up href="#Keeping%20track%20of%20things">Uchovávanie viacerých vecí</a>
 ]<p>

<h3><a name="Dynamic%20allocation"><a name="TOC_42">5.3.1 Dynamická alokácia</a></a></h3>

<p>V tejto sekcii uvidíme, èo to dynamická alokácia je a pozrieme sa, ako ju
mô¾eme pou¾i» na roz¹írenie systému lineárnych polí, ktorý sme pou¾ívali
doteraz.

<p>Dynamická alokácia nám dovoµuje vy¾iada» si pamä» poèas behu programu (teda
keï u¾ program be¾í, ako protiklad k èasu kompilácie). To napríklad znamená, ¾e
sa na zaèiatku behu programu mô¾eme spýta» u¾ívateµa, koµko kusov z ka¾dého
útvaru budeme animova» a potom si vytvoríme polia také dlhé, ako potrebujeme. A
e¹te lep¹ie je, ¾e mô¾eme meni» veµkos» polí poèas behu hry, tak¾e ak by sme
mali ma» málo miesta, tak ich len trochu zväè¹íme.

<p>Na to, aby sme to urobili, pou¾ijeme funkciu <code>malloc</code>. Táto
¹tandardná funkcia jazyka C dostane parameter typu <code>size_t</code> (v
podstate èíslo) a alokuje daný poèet bytov pamäte. Návratová hodnota je
<code>void *</code>, ktorá ukazuje na blok alokovanej pamäte.

Tak¾e chceme vytvori» pole kruhov då¾ky <code>num_circles</code>.  Ka¾dý kruh
bude reprezentovaný <code>struct circle_t</code>. Mô¾eme pou¾i» kµúèové slovo
<code>sizeof</code>, s pomocou ktorého zistíme, koµko bytov potrebujeme pre
ka¾dú ¹truktúru a alokova» pamä» takto:

<pre>struct circle_t *circles;
...
circles = (struct circle_t *) malloc (num_circles * sizeof (struct circle_t));
</pre>

<p>Pretypovanie na <code>struct circle_t *</code> v jazyku C nie je nutné;
kompilátor C++ si ale bude s»á¾ova», ak ho nepou¾ijete. Jeho pou¾itie je
väè¹inou vecou vkusu.

<p>Ak alokácia zlyhá (napr. pre nedostatok pamäte), <code>malloc</code> vráti
<code>NULL</code>. Za urèitých okolností to mô¾ete chcie» zisti» a informova»
u¾ívateµa. Je dobrý zvyk robi» to, ale µudia sa o to èasto nestarajú, preto¾e
nemusí existova» zmysluplný spôsob, ako z toho von. Ak pou¾ívate djgpp s nejakým
robustným DPMI klientom (napr. CWSDPMI), tento ukonèí vá¹ program, kedykoµvek sa
pokúsite pou¾i» smerník NULL. Niektorí iní DPMI klienti nechajú program be¾a»,
èo pred vami problém skryje; najlep¹ie je tomu vyhnú» sa poèas vývoja, alebo
aspoò obèas pou¾i» CWSDPMI (teda z èistého DOSu, nie z Windows), aby ste
skontrolovali, èi veci vyzerajú by» v poriadku.

<p>Po alokácii sa mô¾eme na kruhy odvoláva» spôsobom circles[0], circles[1],
atï., ako keby sme mali skutoèné pole. To, èo máme, nie je celkom presne pole v
jazyku C; je to len smerník na blok pamäte. Predsa sa to ale v mnohých ohµadoch
správa ako pole.

<p>Na záver, ak sme s pou¾ívaním pamäte skonèili, mali by sme ju uvoµni», aby ju
malloc mohol ak to bude potrebné znovu pou¾i»:

<pre>free (circles);
</pre>

<p>Teraz sa pokúste zmeni» vá¹ program z èasti 5.1 (iba kruhy, ¹tvorce a
trojuholníky netreba) tak, aby si u¾ívateµ mohol na zaèiatku programu zvoli»
poèet kruhov. Ak zatuhnete, pozrite sa na <code>examples/chap_05/ex_3_1</code>.

<p>Zmeni» príklad <code>examples/chap_05/ex_2_a</code> tým istým spôsobom bude
celkom jednoduché. Zmena <code>examples/chap_05/ex_2_b</code> bude vy¾adova»
viac mallocov.

<p>A èo takto dovoli» hre zväè¹ova» pole poèas behu? To pri skutoèných poliach
nie je mo¾né, ale ako sme spomenuli predtým, na¹e "pole" nie je skutoèné pole.
Bolo alokované dynamicky, tak¾e mô¾eme pou¾i» funkciu realloc(), aby sme ho
realokovali s inou veµkos»ou. Údaje, ktoré v òom boli predtým, tam budú stále aj
potom, keï alokáciu roz¹írime. Ak ho skracujeme, údaje, ktoré sú aj v novom
bloku budú samozrejme zachované, ale dáta, ktoré sú na konci odrezané sa
stratia. Dokonca ak blok pamäte znovu zväè¹íte, nedá sa spolieha» na to, ¾e
dáta znovu získate.

<p>Problém so znovualokovaním takýchto blokov je, ¾e ak je oblas» pamäti, ktorá
sa nachádza za na¹im blokom u¾ obsadená, realloc potrebuje skopírova» celý blok
niekde inde. Toto nie je zvlá¹» pomalé (operácie kopírovania pamäte sú skutoène
celkom rýchle) ale nie je to vec, ktorú by ste chceli, aby sa vám diala príli¹
èasto.

<p>Väè¹ina implementácií <code>malloc</code> nechávajú nejaké voµné miesto na
konci ka¾dého bloku, ale nemô¾eme sa na to príli¹ spolieha». Je lep¹ie zní¾i»
poèet realokácií nejakým iným spôsobom. Najjednoduch¹í spôsob, ako to spravi» je
v¾dy si zapýta» veµa miesta navy¹e --- potom nemusíme vola» <code>realloc</code>
veµmi èasto.

<p>Tak¾e potrebujeme sledova» niekoµko vecí:

<pre>int num_objs;      /* koµko je ich aktívnych */
int alloced_objs;  /* koµko je ich alokovaných */
int block_size;    /* koµko ich budeme na jeden krát alokova» */
</pre>

<p>Keï potom chceme prida» nový objekt, najprv skontrolujeme, èi máme dos»
miesta (je <code>alloced_objs &gt; num_objs</code>?). Ak áno, zväè¹íme iba
<code>num_objs</code> a pou¾ijeme ten priestor. Inak musíme zväè¹i»
<code>alloced_objs</code> o <code>block_size</code> a znovualokova» blok
napríklad takto:

<pre>objects = (struct obj_t *) realloc (objects, alloced_objs * sizeof (stuct obj_t));
</pre>

<p>V¹imnite si, ¾e syntax realloc je podobná ako malloc a¾ na to, ¾e musíte
zada» starú hodnotu smerníka. Po zavolaní realloc u¾ nemô¾ete pou¾íva» jeho
starú hodnotu -- funkcia realloc blok presunula, stará hodnota je teraz
neplatná. Ak ste nastavili iný smerník na hodnotu <code>objects</code> a realloc
posunula blok niekde inde, druhý smerník bude ukazova» na nesprávny blok.

<p>Po znovualokovaní novej veµkosti bloku mô¾eme samozrejme zväè¹i»
<code>num_objs</code> a pou¾i» novoalokované objekty.

<p><hr>[ Predo¹lý:<a rel=previous href="#Dynamic%20allocation">Dynamická alokácia</a>
 | Hore:<a rel=up href="#Keeping%20track%20of%20things">Uchovávanie viacerých vecí</a>
 ]<p>

<h3><a name="Linked%20lists"><a name="TOC_43">5.3.2 Zre»azené zoznamy</a></a></h3>

<p>Zre»azené zoznamy sú extrémne u¾itoènou dátovou ¹truktúrou. Nane¹»astie sú z
istých dôvodov pre mnohých µudí »a¾ko pochopiteµné. Ak si v¹ak o nich vytvoríte
správnu predstavu, sú skutoène veµmi jednoduché a keï ich niekoµkokrát
pou¾ijete, získate intuitívny vhµad do toho, ako ich pou¾íva».

<p>V tejo èasti sa pozrieme na tri typy zre»azených zoznamov a vyskú¹ame pou¾i»
ich v krú¾kovo/¹tvorèekovo/trojuholníkových programoch vytvorených predtým.

<ul>
<li><a href="#Singly%20linked%20lists">Jednoducho zre»azené zoznamy</a>
	
<li><a href="#Doubly%20linked%20lists">Dvojmo zre»azené zoznamy</a>

<li><a href="#Circularly%20linked%20lists">Kruhovo zre»azené zoznamy</a>

<li><a href="#Using%20linked%20lists">Pou¾itie zre»azených zoznamov</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Doubly%20linked%20lists">Dvojmo zre»azené zoznamy</a>
| Hore:<a rel=up href="#Linked%20lists">Zre»azené zoznamy</a>
 ]<p>

<h4><a name="Singly%20linked%20lists"><a name="TOC_44">5.3.2.1 Jednoducho zre»azené zoznamy</a></a></h4>

<p>V prvom rade potrebujete by» dôverne oboznámení so smerníkmi. Smrníky sú
jednoducho objekty, ktoré mô¾u ukazova» na iné objekty. Sna¾te sa nemyslie» na
ne presne ako na adresy v pamäti; je to be¾ná analógia, ale nemusí by» nutne
správna a ak o nich budete uva¾ova» takto, smerníková aritmetika sa bude zda»
mätúcou.

<p>Tak¾e smerníky mô¾u ukazova» na iné dátové objekty. Väè¹inou sú smerníky
navrhnuté tak, aby ukazovali na istý konkrétny typ dát. Konkrétne mô¾u ukazova»
na u¾ívateµom definované ¹truktúry:

<pre>struct little_struct {
    int number;
} *ptr;
</pre>

<p>Smerník <code>ptr</code> mô¾e ukazova» na µubovoµný objekt typu <code>struct
little_struct</code>. Ak chceme pristupova» k poµu <code>number</code> objektu,
na ktorý <code>ptr</code> ukazuje, mô¾eme písa» <code>(*ptr).number</code> alebo
pou¾i» skrátený zápis <code>ptr-&gt;number</code>, ktorý znamená to isté.
V¹imnite si, ¾e definícia uvedená vy¹¹ie nevytvára hneï objekt, na ktorý by
<code>ptr</code> ukazoval; vytvorí len objekt <code>ptr</code>, ktorý má mo¾nos»
ukazova» na objekty typu <code>struct little_struct</code> ale na zaèiatku
neukazuje nikam (smozrejme niekam ukazuje, ale kam presne zále¾í na iných
okolnostiach; a teda sa nemô¾ete spolieha», ¾e je to platný smerník). Teraz sa
pozrite na toto:

<pre>struct linked_list_node {
    int number;
    struct linked_list_node *next;
} *ptr;
</pre>

<p>Tu ¹truktúra <code>linked_list_node</code> neobsahuje len celé èíslo
<code>number</code>, ale aj smerník <code>next</code>, ktorý mô¾e ukazova» na
objekt typu <code>struct linked_list_node</code>. Tak¾e ak vytvoríme objekt
tohto typu a nasmerujeme na neho <code>ptr</code>, smerník
<code>ptr-&gt;next</code> mô¾e ukazova» na iný objekt tohto typu. A
<code>ptr-&gt;next-&gt;next</code> mô¾e ukazova» na ïal¹í<small>...</small> ako
vidíte, mô¾eme ma» celý zoznam takýchto ¹truktúr, prièom alokujeme ka¾dú zvlá¹»
(rad¹ej ako v jednom veµkom bloku) a mô¾eme k nemu pristupova» s pou¾itím
jediného smerníka na zaèiatok zoznamu. Aby sme oznaèili koniec zoznamu, mô¾eme
nastavi» smerník <code>next</code> posledného uzla na NULL.

<pre>
ptr --&gt; +------------+    +------------+    +---------------+
        | number : 7 |    | number : 3 |    | number : 285  |
        | next   :  ----&gt; | next   :  ----&gt; | next   : NULL |
        +------------+    +------------+    +---------------+
</pre>

<p>Na diagrame vy¹¹ie vidíte <code>ptr</code>, ktorý ukazuje na prvú zo zoznamu
troch polo¾iek. Prvá polo¾ka s hodnotou <code>number</code> 7 má svoj smerník
<code>next</code> nastavený na druhú s hodnotou <code>number</code> 3. Smerník
<code>next</code> tejto polo¾ky ukazuje na tretiu polo¾ku, ktorá má hodnotu
<code>number</code> 285, a smerník <code>next</code> tretej polo¾ky je NULL,
preto¾e je to posledný prvok v zozname. Celý zoznam obsahuje èísla 7, 3 a 285 v
uvedenom poradí.

<p>Pravdepodobne sa èudujete, preèo sme sa trápili s takýmto systémom. Ak ho
porovnáme s lineárnym dynamickým blokovým zásobníkom zmieneným vy¹¹ie, má
niekoµko výhod a niekoµko nevýhod.

<p>V prvom rade narába» s vecami v zre»azenom zozname je veµmi jednoduché. Nové
polo¾ky mô¾u by» pridané kdekoµvek do zoznamu, staré polo¾ky vymazané,
existujúce plo¾ky mô¾u by» preusporiadané alebo presúvane zo zoznamu do zoznamu
a zoznamy sa mô¾u deli» alebo spája» s minimálnou námahou. Staèí zmeni» hodnoty
niektorých smerníkov <code>next</code>. Ka¾dá z týchto operácií by bola
nepríjemná a zdåhavá, keby mala by» vykonaná v lineárnom bloku -- museli by sme
presúva» veµké mno¾stvo dát.

<p>Predstavte si napríklad vymazanie druhej dátovej polo¾ky v dlhom sekvenènom
zozname -- museli by sme posunú» celý zvy¹ok zoznamu o jedno miesto. V
zre»azených zoznamoch staèí len nastavi» smerník <code>next</code> prvej polo¾ky
na to, na èo ukazuje smerník <code>next</code> druhej polo¾ky (teda buï na
tretiu polo¾ku, alebo na NULL, ak ¾iadna tretia polo¾ka neexistuje) a potom
mô¾eme druhú polo¾ku funkciou <code>free</code> uvoµni».

<p>Podobne je jednoduché prida» novú polo¾ku. Predpokladajme, ¾e máme smerník na
polo¾ku v zozname pred miestom, kde chceme na¹u novú polo¾ku prida». Staèí
nastavi» smerník <code>next</code> na¹ej polo¾ky na rovnakú hodnotu ako má
smerník <code>next</code> polo¾ky zo zoznamu a potom nastavi» smerník
<code>next</code> polo¾ky zo zoznamu na na¹u novú polo¾ku.

<p>Nevýhodami zre»azených zoznamov je vyu¾itie pamäte a neefektívnos»
vyhµadávania
polo¾iek podµa èísla. Pou¾itá pamä» je väè¹ia kvôli v¹etkým smerníkom v zozname
a preto¾e je väè¹inou alokované veµké mno¾stvo malých kúskov (konkrétne v èase
písania tohto textu bola minimálna veµkos» bloku alokovaného funkciou
<code>malloc</code> v kompilátore djgpp 4096 bajtov). Vyhµadávanie podµa èísla
je neefektívne, preto¾e musíme prejs» celý zoznam od zaèiatku, aby sme danú
polo¾ku na¹li, zatiaµ èo v sekvenènom zozname mô¾eme skoèi priamo na òu
jednoduchým pripoèítaním.

<p>Ako v¾dy, ktorý spôsob pou¾ijete, zále¾í na tom, na èo ho chcete pou¾i».

<p>Èasto kód zjednodu¹í, ak prvá polo¾ka v zre»azenom zozname je
<dfn>atrapa</dfn> (niekedy sa nazýva aj <dfn>hlavièka zoznamu</dfn>), ktorej
dáta nemajú ¾iadny význam. Robí sa to preto, aby manipulácia s prázdnymi
zoznamami bola jednoduch¹ia -- stanú sa zoznamami s jedinou polo¾kou, s atrapou.

<p>Teraz by som vám navrhol, aby ste sa pozreli do
<code>examples/chap_05/ex_3_2a</code> na nejaké príklady vkladania, mazania a
vyhµadávania polo¾iek v zre»azených zoznamoch.

<p>Myslím, ¾e teraz pravdepodobne rozumiete, preèo zre»azené zoznamy mô¾u by»
veµmi u¾itoèné -- mô¾eme vytvori» toµko útvarov koµko chceme, kedy chceme a
pridáva» ich do zoznamu veµmi efektívnym spôsobom. V skutoènosti sa nestaráme o
to, koµko ich je v zozname; ak sa potrebujeme z nejakých dôvodov odkazova» na
istú konkrétnu polo¾ku, pou¾ijeme miesto jeho poradového èísla smerník.

<p><hr>[ Ïal¹í:<a rel=next href="#Circularly%20linked%20lists">Kruhovo zre»azené zoznamy</a>
 | Predo¹lý:<a rel=previous href="#Singly%20linked%20lists">Jednoducho zre»azené zoznamy</a>
 | Hore:<a rel=up href="#Linked%20lists">Zre»azené zoznamy</a>
 ]<p>

 <h4><a name="Doubly%20linked%20lists"><a name="TOC_45">5.3.2.2 Dvojmo zre»azené zoznamy</a></a></h4>

<p>Ak predpokladáme, ¾e ste pochopili predo¹lú lekciu, toto bude zvládnuteµné
jednoducho. V jednoducho zre»azených zoznamoch vy¹¹ie má ka¾dá polo¾ka jeden
smerník na ïal¹iu polo¾ku v zozname. V dvojmo zre»azených zoznamoch má ka¾dá
polo¾ka dva smerníky -- jeden na ïal¹iu polo¾ku v zozname a jeden na
<em>predo¹lú</em> polo¾ku v zozname.

<pre>struct dllnode {
    struct dllnode *next;
    struct dllnode *prev;
    int number;
} *ptr;
</pre>

<pre>
ptr --&gt; +--------+     +--------+     +--------+
        |  next -----&gt; |  next -----&gt; |  next ---&gt; NULL
 NULL &lt;--- prev  | &lt;----- prev  | &lt;----- prev  |
        | number |     | number |     | number |
        +--------+     +--------+     +--------+
</pre>

<p>Teraz staèí ma» smerník na µubovoµný prvok zoznamu a je mo¾né pristupova» ku
ka¾dému prvku. Stále je èasto u¾itoèné ma» ako prvý prvok v zozname (ten, ktorý
má <code>prev == NULL</code>) atrapu, ktorej dáta sa nepou¾ívajú. Dôvody sú
rovnaké ako predtým. Mô¾e slú¾i» ako <dfn>rukovä»</dfn> k zoznamu -- nieèo, èoho
sa dá zachyti», èo bude stále súèas»ou zoznamu. Pamätajte, ¾e ostatné prvky sa
budú priebe¾ne pridáva» a maza»; hlavièka je jediný prvok o ktorom bude
zaruèené, ¾e je tam celý èas.

<p>Jednou z výhod dvojmo zre»azeného zoznamu je to, ¾e mô¾ete zmaza» prvok
zoznamu bez toho, ¾e by ste potrebovali vedie», v ktorom zozname sa vlastne
nachádza. Dal¹ou výhodou je, ¾e ak nejaký prvok zoznamu potrebuje prejs» celý
zoznam, mô¾e to urobi» bez toho, ¾e by poznal smerník na hlavièku zoznamu. Okrem
toho ak máte daný µubovoµný prvok zoznamu, mô¾ete prida» prvok na obe jeho
strany bez toho, aby ste museli celý zoznam prejs». Dvojité zoznamy sa vo
v¹eobecnosti jednoduch¹ie (a efektívnej¹ie) spravujú, ale samozrejme za cenu
trocha vy¹¹ích re¾ijných nákladov.

<p><code>examples/chap_05/ex_3_2b</code> je príklad dvojmo zre»azeného zoznamu a
funkcií, ktoré s ním narábajú.

<p><hr>[ Ïal¹í:<a rel=next href="#Using%20linked%20lists">Pou¾itie zre»azených zoznamov</a>
| Preo¹lý:<a rel=previous href="#Doubly%20linked%20lists">Dvojmo zre»azené zoznamy</a>
 | Hore:<a rel=up href="#Linked%20lists">Zre»azené zoznamy</a>
 ]<p>

<h4><a name="Circularly%20linked%20lists"><a name="TOC_46">5.3.2.3 Kruhovo zre»azené zoznamy</a></a></h4>

<p>Znovu, ak ste porozumeli zre»azeným zoznamom a¾ potiaµto, toto nebude príli¹
nároèné. V na¹om jednoducho zre»azenom zozname sme mali smerník
<code>next</code> posledného prvku nastavený na NULL, aby sme tak oznaèili
koniec zoznamu. V kruhovo zre»azenom zozname smerník <code>next</code>
posledného prvku ukazuje spä» na zaèiatok zoznamu -- teda to nie je v
skutoènosti posledný prvok. Predstavte si to ako kruh prvkov, kde ka¾dý ukazuje
na nasledujúci.

<p>Ak je kruhový zoznam dvojmo zre»azený, smerník <code>prev</code> prvého prvku
ukazuje na posledný prvok.

<p>Prázdne kruhové zoznamy sú tie¾ problematické; pou¾itie atrapového prvku je
u¾itoèné aj tu, ale musíte pamäta» na to, ¾e ho treba preskoèi», keï budete
prechádza» okolo kruhu. Mô¾ete to spravi» aj tak, ¾e ak je zoznam úplne prázdny,
vá¹ smerník na neho bude NULL (ako to mô¾ete spravi» aj s ostatnými zre»azenými
zoznamami), ale stále budete musie» o¹etrova» nejaké ¹peciálne prípady.

<p>Kruhové zoznamy sú u¾itoèné na iné veci, ne¾ lineárne zre»azené zoznamy; ak
programujete hru, vo v¹eobecnosti chcete poèas herného cyklu spravit nieèo s
ka¾dým prvkom zoznamu a na tieto úèely sa èasto viac hodia lineárne zoznamy.
Kruhové zoznamy som tu spomenul pre úplnos» a preto¾e sa od lineárnych príli¹
nelí¹ia. Ako príklad si pozrite <code>examples/chap_05/ex_3_2c</code>.

<p><hr>[ Predo¹lý:<a rel=previous href="#Circularly%20linked%20lists">Kruhovo zre»azené zoznamy</a>
 | Hore:<a rel=up href="#Linked%20lists">Zre»azené zoznamy</a>
 ]<p>

<h4><a name="Using%20linked%20lists"><a name="TOC_47">5.3.2.4 Pou¾itie zre»azených zoznamov</a></a></h4>

<p>Pokúste sa prerobi» vá¹ program na pohyb útvarov tak, ¾e útvary ulo¾íte do
zre»azeného zoznamu a animujete ich odtiaµ. Tie¾ mô¾ete ka¾dých 100 herných
cyklov prida» nový útvar, alebo niektorý zmaza». Pozrite si
<code>examples/chap_05/ex_3_2d</code> ako uká¾ku toho v¹etkého.
 
<p>Táto metóda, keï v¹etky objekty hry vlo¾íte do zre»azeného zoznamu, je veµmi
u¾itoèná. Mô¾ete tam tie¾ vlo¾i» hráèovu raketu/postavu/potvoru; ak hráèova
postava vykonáva podobné akcie ako nepriatelia, mô¾e to fungova» celkom dobre.

<p><hr>[ Predo¹lý:<a rel=previous href="#Keeping%20track%20of%20things">Uchovávanie viacerých vecí</a>
 | Hore:<a rel=up href="#Making%20several%20things%20happen%20at%20once">Ako zariadi», aby sa niekoµko vecí dialo súèasne</a>
 ]<p>

<h2><a name="Object%20Oriented%20Programming"><a name="TOC_48">5.4 Objektovo orientované programovanie</a></a></h2>

<p>Táto èas» zatiaµ nebola napísaná, sorry.

<p><hr>[ Ïal¹í:<a rel=next href="#More%202D%20graphics">Nieèo viac z 2D grafiky</a>
 | Predo¹lý:<a rel=previous href="#Making%20several%20things%20happen%20at%20once">Ako zariadi», aby sa niekoµko vecí dialo súèasne</a>
 | Hore:<a rel=up href="#Top">Zaèiatok</a>
 ]<p>

<h1><a name="User%20input"><a name="TOC_49">6. U¾ivateµský vstup</a></a></h1>

<p>Vstupné zariadenie je èokoµvek, èo pou¾ijete, aby ste dali poèítaèu
informácie. U ¹tandardných PC je to najmä klávesnica, aj keï väè¹ina má my¹ a
mnohé joystick. Podµa uvedenej definície disketová jednotka je tie¾ istým druhom
vstupného zariadenia rovnako ako mikrofóny, skenery a modemy, ale to väè¹inou
nie sú tie najlep¹ie veci na ovládanie hry.

<p>Pozrieme sa na ka¾dé z hlavných troch zariadení podrobnej¹ie, potom
premyslíme abstrakciu ná¹ho vstupného systému. Nakoniec sa pozrieme na rôzne
spôsoby pou¾itia vstupnej informácie.

<ul>
<li><a href="#Keyboard%20input">Vstup z klávesnice</a>

<li><a href="#Joystick%20input">Vstup z joysticku</a>

<li><a href="#Mouse%20input">Vstup z my¹i</a>

<li><a href="#Generic%20input">Vstup v¹eobecne</a>

<li><a href="#Ways%20to%20interpret%20input%20data">Spôsoby interpretácie vstupných dát</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Joystick%20input">Vstup z joysticku</a>
 | Hore:<a rel=up href="#User%20input">U¾ivateµský vstup</a>
 ]<p>

<h2><a name="Keyboard%20input"><a name="TOC_50">6.1 Vstup z klávesnice</a></a></h2>

<ul>
<li><a href="#Why%20the%20standard%20keyboard%20routines%20are%20useless">Preèo
sú ¹tandardné klávesnicové funkcie nepou¾iteµné</a>

<li><a href="#Allegro%20keyboard%20routines">Klávesnicové funkcie allegra</a>

<li><a href="#Moving%20something%20using%20the%20keyboard">Ako nieèím pohnú» s pomocou klávesnice</a>

<li><a href="#Letting%20the%20user%20choose%20which%20keys%20to%20use">Ako necha» u¾ívateµa vybra» si klávesy</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Allegro%20keyboard%20routines">Klávesnicové funkcie allegra</a>
 | Hore:<a rel=up href="#Keyboard%20input">Vstup z klávesnice</a>
 ]<p>

<h3><a name="Why%20the%20standard%20keyboard%20routines%20are%20useless"><a name="TOC_51">6.1.1 Preèo sú ¹tandardné klávesnicové funkcie nepou¾iteµné</a></a></h3>

<p>©tandardné rozhranie PC klávesnice je takmer, aj keï nie celkom, úplne
nepou¾iteµné ako zariadenie na ovládanie hry. Je na to niekoµko dôvodov; v prvom
rade kedykoµvek stlaèíte klávesu alebo len na òu klepnete, hra urèitý èas
(zvyèajne ¹tvrtinu sekundy) bude vidie» len jednu stlaèenú klávesu. Potom, ak
dr¾íte klávesu stlaèenú, naplníte zásobník mnohými stlaèeniami, èo znamená, ¾e
hra ich stále bude èíta» aj potom, èo klávesu pustíte. Navy¹e ak stlaèíte jednu
klávesu a klepnete na inú, bude to vyzera», ako by ste prvú pustili.

<p>Toto v¹etko dohromady robí ¹tandardné PC klávesnicové funkcie nepou¾iteµné
pre riadenie akèných hier. Na¹»astie Allegro poskytuje sadu oveµa lep¹ích
funkcií.

<p><hr>[ Ïal¹í:<a rel=next href="#Moving%20something%20using%20the%20keyboard">Ako nieèím pohnú» s pomocou klávesnice</a>
 | Predo¹lý:<a rel=previous href="#Why%20the%20standard%20keyboard%20routines%20are%20useless">Preèo sú ¹tandardné klávesnicové funkcie nepou¾iteµné</a>
 | Hore:<a rel=up href="#Keyboard%20input">Vstup z klávesnic</a>
 ]<p>

<h3><a name="Allegro%20keyboard%20routines"><a name="TOC_52">6.1.2 Klávesnicové funkcie allegra</a></a></h3>

<p>Vo va¹ich allegrovských programoch treba poèas inicializácie zavola»
<code>install_keyboard()</code>. Potom mô¾ete pou¾íva» klávesnicové funkcie
Allegra.

<p>Predov¹etkým je tam pole charov nazvané <code>key</code> ktoré obsahuje jeden
prvok pre ka¾dú klávesu na klávesnici. Je indexované podµa scankódov (nie ASCII
kódov). Jednotlivé scankódy mô¾ete získa» s pou¾itím <code>KEY_*</code> kon¹tánt
definovaných v <code>allegro.h</code>.  Napríklad, ak chcete zisti», èi je práve
stlaèený medzerník, zistite, èi je <code>key[KEY_SPACE]</code> nenulové.
Pravdepodobne si pamätáte, ¾e ste vstupnú funkciu u¾ videli, keï bolo potrebné
skontrolova», èi bola alebo nebola stlaèená klávesa &lt;ESC&gt;.

<p>Potom, èo in¹talujete klávesnicový ovládaè Allegra, funkcie BIOSu prestanú
fungova». To sa týka <code>getch</code> z conio, <code>getchar</code>,
<code>gets</code>, <code>scanf</code> z stdio a v¹etko ïal¹ie, èo pou¾íva stdin.
Allegro poskytuje náhradu za <code>getch</code> nazvanú <code>readkey</code>,
ktorá èaká, kým bude stlaèená klávesa a vráti celé èíslo zlo¾ené zo scankódu
klávesy a ASCII hodnoty. Aby ste ich rozdelili, musíte urobi» nieèo takéto:

<pre>int value, scancode, ascii;
value = readkey();
scancode = value &gt;&gt; 8;
ascii = value &amp; 0xff;
</pre>

<p>Podobne <code>keypressed</code> je náhrada coniovskej funkcie
<code>kbhit</code>, ktorá vracia nenulovú hodnotu, ak je vo vstupnom zásobníku
stlaèená klávesa.

<p>Ïal¹ie informácie nájdete v dokumentácii k Allegru.

<p><hr>[ Ïal¹í:<a rel=next href="#Letting%20the%20user%20choose%20which%20keys%20to%20use">Ako necha» u¾ívateµa vybra» si klávesy</a>
 | Predo¹lý:<a rel=previous href="#Allegro%20keyboard%20routines">Klávesnicové funkcie allegra</a>
 | Hore:<a rel=up href="#Keyboard%20input">Vstup z klávesnice</a>
 ]<p>

<h3><a name="Moving%20something%20using%20the%20keyboard"><a name="TOC_53">6.1.3 Ako nieèím pohnú» s pomocou klávesnice</a></a></h3>

<p>Je niekoµko spôsobov, ktorými mô¾u objekty v hre reagova» na vstup. Nateraz
budeme objektami hýba» kon¹tantnou rýchlos»ou v smere, ktorý u¾ívateµ urèí. Iné
modely spomenieme neskôr.

<p>Tak¾e èo chceme je nieèo takéto: 
<pre>if (key[KEY_LEFT]) x--;  /* ak u¾ívateµ stlaèí µavú ¹ipku, ideme vµavo */
if (key[KEY_RIGHT]) x++; /* to isté vpravo */
if (key[KEY_UP]) y--;    /* to isté hore; pozn. aby sa i¹lo hore, y sa zmen¹uje */
if (key[KEY_DOWN]) y++;  /* to isté dole (y sa zväè¹uje) */
</pre>

<p>kde <code>x</code> a <code>y</code> sú súradnice objektu.

<p>Pokúste sa pozmeni» (jednoduchý) kolieskový program, aby u¾ívateµ mohol
kolieskom hýba». Pokúste sa urobi» program tak, aby vyhovoval navrhnutej
¹truktúre. Uká¾kový program <code>examples/chap_06/ex_1_3</code> demon¹truje,
ako sa to má spravi».

<p><hr>[ Predo¹lý:<a rel=previous href="#Moving%20something%20using%20the%20keyboard">Ako nieèím pohnú» s pomocou klávesnice</a>
 | Hore:<a rel=up href="#Keyboard%20input">Vstup z klávesnice</a>
 ]<p>

<h3><a name="Letting%20the%20user%20choose%20which%20keys%20to%20use"><a name="TOC_54">6.1.4 Ako necha» u¾ívateµa vybra» si klávesy</a></a></h3>

<p>S pou¾itím explicitných <code>KEY_*</code> kon¹tánt vo va¹ej hre je niekoµko
problémov. Vo v¹eobecnosti je najlep¹ie pou¾i» pole <code>key</code> vtedy, keï
sa nestaráte, èo klávesa normálne znaèí. Ak od niekoho chcete, aby zadal
&lt;Q&gt; potom na testovanie toho, èi to spravil nemô¾ete pou¾i» pole
<code>key</code>, preto¾e mapovanie kon¹tánt <code>KEY_*</code> na fyzickú
klávesnicu je nezávislé od softwarového mapovania klávesnice. <code>KEY_Q</code>
odkazuje na klávesu vedµa &lt;TAB&gt;, ale inojazyèné a alternatívne mapovania
klávesnice tam nemusia ma» &lt;Q&gt;. To znamená, ¾e mô¾ete <code>KEY_*</code>
kon¹tanty pou¾i» na výber pohodlnej rozlohy ovládacích kláves, ale nemô¾ete ich
pou¾i», ak je symbol na klávese dóle¾itý (napr. Q ako Quit)

<p>Keï¾e klávesnica na PC nebola v skutoènosti navrhnutá ako zariadenie na
ovládanie hier, nemô¾e sledova» ka¾dú klávesu nezávisle. Dokonca sa k tomu ani
nepribli¾uje. Existujú isté kombinácie kláves, ktorých stlaèenie spôsobí, ¾e iné
klávesy u¾ nebudú snímané -- dokonca aj keï máte dobré klávesnicové funkcie ako
v Allegre. Je to hardwarové obmedzenie. Príklad
<code>examples/chap_06/ex_1_4</code> je jednoduchý program, ktorý opakovane
vypisuje zoznam v¹etkých kláves, ktoré Allegro registruje ako stlaèené; spustite
ho a vyskú¹ajte stláèa» klávesy, kým nezistíte, ¾e ïal¹ie stlaèenie nie je
detekované. Na mojej klávesnici spôsobí súèasné stlaèenie kláves  &lt;Z&gt;,
&lt;X&gt; a &lt;C&gt; to, ¾e ak sa s nimi stlaèí &lt;F&gt;, zostane
nepov¹imnuté.

<p>Èo je e¹te väè¹ia smola, nie v¹etky klávesnice majú takéto
<dfn>prekrytia</dfn> na tých
istých miestach. Ako potom chcete vybra» klávesy, ktorými budete ovláda» hru, ak
nie je isté, ¾e budú fungova» na v¹etkých systémoch?

<p>Odpoveïou je samozrejme necha» na u¾ívateµoch, nech si definujú svoje vlastné
klávesy. Ak dôjde ku klávesovému prekrytiu, mô¾u si zvoli» iné klávesy.

<p>Ak to budete chcie» spravi», bude treba kon¹tanty <code>KEY_*</code> vo
va¹ich vstupných procedúrach nahradi» premennými, ktoré inicializujete na nejaké
vstupné hodnoty a potom u¾ívateµom dovoli» meni» ich ak to budú chcie».
Prirodzene nemô¾ete oèakáva», ¾e u¾ívatelia budú vedie», èo sú to scankódy;
mali by ste napísa» procedúru, ktorá to pre nich zistí.

<p>Pou¾itie poµa <code>key</code> je celkom jednoduché; jednoducho necháte be¾a»
cyklus od 1 do <code>KEY_MAX</code>, najvy¹¹ieho scankódu a zistíte si, ktorá
klávesa je stlaèená. Vlo¾íte ju do va¹ej premennej <code>klavesa_vlavo</code>,
poèkáte, kým u¾ívateµ pôjde ïalej, spýtate sa na klávesu "vpravo" atï. Mô¾ete
predpoklada», ¾e prvá stlaèená klávesa, ktorú nájdete, je jediná; ktorý pra¹tený
idiot by stláèal dve klávesy naraz, keï je po¾iadaný o to, aby stlaèil jednu? :)

<p>Uká¾kový program, ktorý u¾ívateµovi dovolí predefinova» ovládacie klávesy
uvidíme neskôr.

<p><hr>[ Ïal¹í:<a rel=next href="#Mouse%20input">Vstup z my¹i</a>
| Predo¹lý:<a rel=previous href="#Keyboard%20input">Vstup z klávesnice</a>
| Hore:<a rel=up href="#User%20input">U¾ivateµský vstup</a>
 ]<p>

<h2><a name="Joystick%20input"><a name="TOC_55">6.2 Vstup z joysticku</a></a></h2>

<ul>
<li><a href="#Digital%20readings">Digitálne snímanie</a>
	
<li><a href="#The%20fire%20buttons">Tlaèítka na streµbu</a>

<li><a href="#Analogue%20readings%20and%20calibration">Analógové snímanie a kalibrácia</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#The%20fire%20buttons">Tlaèítka na streµbu</a>
 | Hore:<a rel=up href="#Joystick%20input">Vstup z joysticku</a>
 ]<p>

<h3><a name="Digital%20readings"><a name="TOC_56">6.2.1 Digitálne snímanie</a></a></h3>

<p>Digitálne snímanie joysticku je jednoduché. Uistite sa, èi je joystick
centrovaný (t.j. povedzte im, aby dali joystick do stredu a poèkajte, kým vám
dajú vedie», ¾e to spravili) a potom zavolajte
<code>initialise_joystick()</code>. Teraz kedykoµvek chcete sníma» stav
joysticku, zavolajte <code>poll_joystick()</code>. Táto funkcia zistí stav
joysticku a popri iných veciach obnoví stav globálnych premenných <code>joy_left</code>, <code>joy_right</code>,
<code>joy_up</code> a <code>joy_down</code>, z ktorých ka¾dá ukazuje, èi je
alebo nie je joystick tlaèený v danom smere.

<p>Príklad vstupného kódu uvedený v klávesnicovej sekcii vy¹¹ie bude teraz
vyzera»:

<pre>poll_joystick();
if (joy_left) x--;  /* if the joystick is pushed to the left, go left */
if (joy_right) x++; /* same for right */
if (joy_up) y--;    /* same for up; note that y _decreases_ to go up */
if (joy_down) y++;  /* and for down y _increases_ */
</pre>

<p>Predsa len sa uistite, ¾e joystick je centrovaný, keï ho inicializujete.
Funkcia <code>initialise_joystick</code> vráti nulu iba vtedy, keï je joystick
pripojený, tak¾e to mô¾ete skontrolova», potom po¾iada» u¾ívateµa, aby joystick
vycentroval a nakoniec znovu zavola» funkciu <code>initialise_joystick</code>,
aby sa správne nastavila stredová pozícia.

<p>Pokúste sa zmeni» predo¹lý príklad tak, aby èítal vstup z joysticku miesto z
klávesnice. Ak zatuhnete, pozrite sa na uká¾kový program <code>examples/chap_06/ex_2_1</code>.

<p><hr>[ Ïal¹í:<a rel=next href="#Analogue%20readings%20and%20calibration">Analógové snímanie a kalibrácia</a>
 | Predo¹lý:<a rel=previous href="#Digital%20readings">Digitálne snímanie</a>
 | Hore:<a rel=up href="#Joystick%20input">Vstup z joysticku</a>
 ]<p>

<h3><a name="The%20fire%20buttons"><a name="TOC_57">6.2.2 Tlaèítka na streµbu</a></a></h3>

<p>Je jednoduché èíta» ich; priemerný joystick ich má dve a ich stav je ulo¾ený
v premenných <code>joy_b1</code> a <code>joy_b2</code> ako TRUE (nenulová
hodnota), kéï sú tlaèidlá stlaèené. Ako pri v¹etkých premenných typu
<code>joy_*</code>, ich hodnota sa obnovuje iba vtedy, keï zavoláte funkciu
<code>poll_joystick</code>. Ak ju nikdy nezavoláte, ich hodnota bude stále
rovnaká; nemusíte ju ale vola» príli¹ èasto. Raz za herný cyklus úple staèí, ak
náhodou nekontrolujete nasledujúci prípad<small>...</small>

<p>Podµa v¹etkého väè¹ina joystickov má palebné tlaèidlá s odskokom, tak¾e by
ste mali vedie», ¾e stlaèenie palebného tlaèidla vyvolá niekoµko zmien z
"vypnyté" na "zapnuté" a spä»; mne to nikdy nespôsobilo ¾iadne problémy, ale
mo¾no sa môj joystick skrátka o to nestará. Vo väè¹ine hier, ktorých sa to týka,
je problém v nastavení maximálnej palebnej rýchlosti (t.j. u¾ívateµ nemô¾e
streli» druhýkrát, kým povedzme neprejde 20 herných cyklov.) Jediná vec, v
ktorej odskakovanie spôsobí skutoène veµký chaos sú dvojkiky na tlaèítku
joysticku; jedno stlaèenie mô¾e vyzera» ako dve (prípadne viac) stlaèení.
Poznamenajme, ¾e to je problém iba vtedy, ak èas medzi odozvami z joysticku je
veµmi krátky.

<p>Pokúste sa zmeni» príklad z digitálneho snímania tak, aby ktuh smenil farbu,
keï stlaèíte palebné tlaèidlo. Pokúste sa to urobi» tak, aby pri ka¾dom stlaèení
zmenil farbu len raz (tak, ¾e budete zaka¾dým èaka» a¾ dovtedy, kým sa joystick
neuvoµní -- nezabudnite naèíta» stav joysticku v ka¾dom cykle, inak v prenemmých
ostanú staré hodnoty). Ak sa farby nemenia správnym spôsobom, tlaèidlo mô¾e ma»
odskakovanie, pokúste sa to zru¹i». Teraz (»a¾¹ie) urobte, aby sa mohol kruh
pohybova», aj keï je ltaèidlo stlaèené.

<p>Príklady na v¹etko uvedené vy¹¹ie sú v <code>examples/chap_06/ex_2_2</code>;
pozrite sa ¹peciálne na techniku pou¾itú v poslednom prípade.

<p><hr>[ Predo¹lý:<a rel=previous href="#The%20fire%20buttons">Tlaèítka na streµbu</a>
 | Hore:<a rel=up href="#Joystick%20input">Vstup z joysticku</a>
 ]<p>

<h3><a name="Analogue%20readings%20and%20calibration"><a name="TOC_58">6.2.3 Analógové snímanie a kalibrácia</a></a></h3>

<p>[Poznámka: táto informácia je zastaralá. Stále to bude fungova» ale pre
Allegro 4 to chce zmenu.]

<p>Predpokladá sa, ¾e PC joystick je analógové zariadenie; inými slovami, mô¾ete
zisti» nielen ktorým smerom páka ukazuje, ale aj ako ïaleko tým smerom je
naklonená. Ale ako zdôrazòuje Shawn v <code>allegro.txt</code>:

<blockquote>
<small>...</small>presné pravidlá sa mô¾u lí¹i» v závislosti na type joysticku,
rýchlosti vá¹ho poèítaèa, teplote v miestnosti a fáze mesiaca. Ak chcete získa»
zmysluplný vstup, musíte joystick pred pou¾itím kalibrova», èo je trest za
programátorove hriechy.
</blockquote>

<p>Kalibrácia nie je v skutoènosti taká »a¾ká, len trocha irituje u¾ívateµov. Aj
keï väè¹ina PC hráèov je na klaibráciu joysticku zvyknutá.

<p>V kalibrácii ide o to, ¾e joystickovské procedúry potrebujú vedie», aký
rozsah hodnôt v smere X aj Y joystick vracia. Allegro to robí s pou¾itím troch
funkcií: <code>initialise_joystick</code>, ako sme povedali vy¹¹ie, zaznaèí
hodnoty v strede; <code>calibrate_joystick_tl</code> zaznaèí hodnoty, keï je
páka èo najïalej vµavo hore a <code>calibrate_joystick_br</code> robí to isté,
keï je páka vpravo dole.

<p>Znova, obyèajne budete vola» <code>initialise_joystick</code> raz na
zaèiatku, aby ste zistili, èi je alebo nie je joystick pripojený. Ak je a vy ho
chcete neskôr kalibrova», postupujte takto:

<ol type=1 start=1>
</p><li>Po¾iadajte u¾ívateµa, nech vycentruje joystick a poèkajte, kým vám
oznámi, ¾e to urobil (napríklad stlaèením klávesy)
<li>Zavolajte funkciu <code>initialise_joystick</code>, aby si poznaèila
stredovú pozíciu.
<li>Po¾iadajte u¾ívateµa, aby dal joystick do µavého horného rohu a oznámil vám
to
<li>Zavolajte funkciu <code>calibrate_joystick_tl</code>
<li>Po¾iadajte u¾ívateµa, aby dal joystick vpravo dole a oznámil to
<li>Zavolajte funkciu <code>calibrate_joystick_br</code>
</ol>

<p>Teraz má Allegro v¹etko, èo potrebuje vedie», aby vám bolo schopné da»
analógovú pozíciu. Z estetických dôvovdov je vhodné teraz joystick vráti» do
stredovej pozície; inak mô¾ete spusti» nieèo dôle¾ité s joystickom, ktorý je
stále nastavený vpravo dole. Buï u¾ívateµa po¾iadajte aby joystick vycentroval a
potvrdil to e¹te raz, alebo sledujte stav joysticku, kým to neurobí (pozrite
ni¾¹ie).

<p>Ako uká¾ku takéhoto kódu si pozrite <code>examples/chap_06/ex_2_3a</code>.

<p>Keï máme joystick zkalibrovaný, mô¾eme koneène jeho pozíciu èíta»
detailnej¹ie. Premenné <code>joy_x</code> a <code>joy_y</code> vrátia jeho X a Y
súradnice od -128 do 128, kde (-128,-128) je µavý horný roh, (0,0) je stred a
(128,128) je pravý dolný roh.

<p>Teraz zmeòte program na pohyb kruhom tak, aby sa kruh hýbal tak rýchlo, ako
ïaleko potiahnete páku. <code>examples/chap_06/ex_2_3b</code> ukazuje ako na to
v prípade, ¾e to nezvládnete. V¹imnite si <code>#define</code> neïaleko
zaèiatku; ovláda maximálnu rýchlos» kruhu, ktorá zodpovedá úplnému nakloneniu
páky. Pou¾itie <code>#define</code> alebo premennej typu <code>constant</code>
namiesto èísla zjednodu¹í zmenu rýchlosti v budúcnosti.

<p><hr>[ Ïal¹í:<a rel=next href="#Generic%20input">Vstup v¹eobecne</a>
 | Predo¹lý:<a rel=previous href="#Joystick%20input">Vstup z joysticku</a>
 | Hore:<a rel=up href="#User%20input">U¾ivateµský vstup</a>
 ]<p>

<h2><a name="Mouse%20input"><a name="TOC_59">6.3 Vstup z my¹i</a></a></h2>

<p>Na my¹ mô¾ete pozera» jedným z dvoch spôsobov -- buï je to "uká¾ a klikni"
zariadenie, alebo èosi ako analógový joystick, ktorý poskytuje priamu kontrolu
nad postavou.

<ul>
<li><a href="#Point%20and%20click">Uká¾ a klikni</a>

<li><a href="#Direct%20mouse%20control">Priama kontrola my¹ou</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Direct%20mouse%20control">Priama kontrola my¹ou</a>
 | Hore:<a rel=up href="#Mouse%20input">Vstup z my¹i</a>
 ]<p>

<h3><a name="Point%20and%20click"><a name="TOC_60">6.3.1 Uká¾ a klikni</a></a></h3>

<p>Prístup "uká¾ a klikni" znamená, ¾e na obrazovke je nejaký druh ukazovátka a
s pomocou my¹i sa ním pohybuje. Keï sa stlaèí tlaèítko, spravíte nieèo, èo
zále¾í od toho, kam ukazovátko ukazovalo. Príkladom takého nieèoho sú WIMP
GUIèka (ako Windows), Dune 1 a 2, Warcraft 1 a 2, spústa rozhraní (rôzne menu)
atï. Je to veµmi populárna technika.

<ul>
<li><a href="#Initialising%20the%20mouse">Inicializácia my¹i</a>

<li><a href="#Reading%20the%20mouse">Èítanie my¹i</a>

<li><a href="#Displaying%20the%20mouse%20pointer">Zobrazenie ukazovateµa my¹i</a>

<li><a href="#Controlling%20the%20mouse%20pointer">Ovládanie ukazovateµa my¹i</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Reading%20the%20mouse">Èítanie my¹i</a>
 | Hore:<a rel=up href="#Point%20and%20click">Uká¾ a klikni</a>
 ]<p>

<h4><a name="Initialising%20the%20mouse"><a name="TOC_61">6.3.1.1 Inicializácia my¹i</a></a></h4>

<p>Na inicializáciu my¹i zavolajte <code>install_mouse()</code>. Ako sa pí¹e v
allegro.txt, funkcia vráti -1, ak inicializácia zlyhá alebo vráti poèet
tlaèidiel na my¹i, ak uspeje.

<p><hr>[ Ïal¹í:<a rel=next href="#Displaying%20the%20mouse%20pointer">Zobrazenie ukazovateµa my¹i</a>
 | Predo¹lý:<a rel=previous href="#Initialising%20the%20mouse">Inicializácia my¹i</a>
 | Hore:<a rel=up href="#Point%20and%20click">Uká¾ a klikni</a>
 ]<p>

<h4><a name="Reading%20the%20mouse"><a name="TOC_62">6.3.1.2 Èítanie my¹i</a></a></h4>

<p>Teraz mô¾ete získa» X-ovú a Y-ovú súradnicu ukazovateµa my¹i v premenných
<code>mouse_x</code> a <code>mouse_y</code> (kde sú ulo¾ené súradnice na 
obrazovke) a stav tlaèidiel my¹i ulo¾ený v premennej <code>mouse_b</code>,
ktorá je bitovým poµom s týmto významom:


<pre>Bity:  2 1 0
       . . X = príznak µavého tlaèidla
       . X . = príznak pravého tlaèidla
       X . . = príznak stredného tlaèidla
</pre>

<p>Ostatné bity sú v súèasnosti nepou¾ité. Príznakové bity troch tlaèidiel
sú nastavené, ak je zodpovedajúce tlaèidlo stlaèené, nulové, ak stlaèené 
nie je. Ak my¹ nemá stredné tlaèidlo, patrièný príznak je stále nulový.

<p>Tak¾e na zistenie stavu jednotlivých tlaèidiel pou¾ijete na premennú 
<code>mouse_b</code> binárne AND (&amp;) s èíslami 1, 2 alebo 4 nasledujúcim
spôsobom:

<pre>if (mouse_b &amp; 1) printf ("¥avé ");
if (mouse_b &amp; 2) printf ("Pravé ");
if (mouse_b &amp; 4) printf ("Stredné ");
printf ("\n");
</pre>

<p>Poznamenajme, ¾e hodnota premennej <code>mouse_b</code> sa mô¾e meni»
(a aj sa mení) "vám za chrbtom"; nasledujúci spôsob testovania mô¾e vráti»
pochybné výsledky:

<pre>if (mouse_b) {
    printf ("Stlaèené tlaèidlá: ");
    if (mouse_b &amp; 1) printf ("¥avé ");
    if (mouse_b &amp; 2) printf ("Pravé ");
    if (mouse_b &amp; 4) printf ("Stredné ");
    printf ("\n");
}
</pre>

<p>Predstavte si, èo sa stane, ak je na zaèiatku stlaèené jedno tlaèidlo,
tak¾e prvá podmienka <code>if</code> sa vyhodnotí, ale potom sa tlaèidlo 
uvoµní; re»azec "Stlaèené tlaèidlá: " sa vypí¹e, ale preto¾e u¾ ¾iadne 
tlaèidlo stlaèené nie je, ¾iadna z mo¾ností "¥avé ", "Pravé ", "Stredné "
sa nevypí¹e.

<p>Ak by podobná nekalos» mala robi» problémy, mô¾ete si vytvori» kópiu
premennej <code>mouse_b</code> a pracova» potom s òou; mimochodom je to 
nieèo podobné, ako èítanie z joysticku.

<pre>my_mouse_b = mouse_b;
if (my_mouse_b) {
    printf ("Stlaèené tlaèidlá: ");
    if (my_mouse_b &amp; 1) printf ("¥avé ");
    /* atï */
}
</pre>


<p><hr>[ Ïal¹í:<a rel=next href="#Controlling%20the%20mouse%20pointer">Ovládanie ukazovateµa my¹i</a>
 | Predo¹lý:<a rel=previous href="#Reading%20the%20mouse">Èítanie my¹i</a>
 | Hore:<a rel=up href="#Point%20and%20click">Uká¾ a klikni</a>
 ]<p>

<h4><a name="Displaying%20the%20mouse%20pointer"><a name="TOC_63">6.3.1.3 Zobrazenie ukazovateµa my¹i</a></a></h4>

<p>Ak chcete zobrazi» ukazovateµ na obrazovke, jednoducho zavolajte funkciu
<code>show_mouse</code> ktorej poviete, na ktorú bitmapu ho chcete ktesli»,
napríklad:

<pre>show_mouse (screen);
</pre>

<p>Kedykoµvek sa my¹ pohne, Allegro obnoví ukazovateµ my¹i (leda¾e by ste 
mu povedali, aby to nerobilo -- pozrite si dokumentáciu k Allegru). Preto
predtým, ne¾ do bitmapy èokoµvek zapí¹ete, treba my¹ skry», inak sa na
monitore budú dia» zlé veci. Spraví sa to tak, ¾e zavoláte
<code>show_mouse(NULL)</code>.

<p>Poznamenajme, ¾e funkcie, ktoré priamo vykresµujú ukazovateµ my¹i 
(podobne ako niektoré iné èasti Allegra) vy¾adujú, aby boli nain¹talované 
procedúry èasovaèa -- je to èiastoène vecou toho, ako veci fungujú na 
pozadí. Kvôli ïal¹ím informáciam si pozrite <a href="#Timers">èasovaèe</a> 
a èiastoène aj 
<a href="#Initialising%20the%20timer%20system">Inicializácia systému èasovaèov</a>. 

<p><hr>[ Predo¹lý:<a rel=previous href="#Displaying%20the%20mouse%20pointer">Zobrazenie ukazovateµa my¹i</a>
 | Hore:<a rel=up href="#Point%20and%20click">Uká¾ a klikni</a>
 ]<p>

<h4><a name="Controlling%20the%20mouse%20pointer"><a name="TOC_64">6.3.1.4 Ovládanie ukazovateµa my¹i</a></a></h4>

<p>Ak potrebujete upravi» oblas» my¹i, mô¾ete zavola»:

<pre>set_mouse_range (min_x, min_y, max_x, max_y);
</pre>

<p>kde <code>min_x</code> a <code>min_y</code> je minimálna hodnota X a Y
a <code>max_x</code> a <code>max_y</code> sú maximálne hodnoty.

<p>Ak z nejakého dôvodu chcete posunú» ukazovateµ my¹i na urèité miesto 
na obrazovke, zavolajte funkciu <code>position_mouse</code>, ktorej 
odovzdáte ako parametre novú X-ovú a Y-ovú súradnicu.

<p>Uká¾kový program <code>examples/chap_06/ex_3_1</code> demon¹truje
prístup "uká¾ a klikni".

<p><hr>[ Predo¹lý:<a rel=previous href="#Point%20and%20click">Uká¾ a klikni</a>
 | Hore:<a rel=up href="#Mouse%20input">Vstup z my¹i</a>
 ]<p>

<h3><a name="Direct%20mouse%20control"><a name="TOC_65">6.3.2 Priama kontrola my¹ou</a></a></h3>

<p>Táto technika znamená, ¾e zistíme, ako ïaleko sa v ka¾dom hernom cykle
v jednotlivých smeroch pohla my¹ a potom s údajmi zaobchádzame ako 
s analógovými dátami z joysticku. Príklady takýchto hier sú:

<ul>
<li>V¹etky súèasné hry od id Software == teda Wolfenstein 3D a v¹etky
hry ako Doom, Heretic a Quake.

<li>Ïal¹ie strieµaèky v prvej osobe. Áno, id Software si zaslú¾i samostatnú
kategóriu, preto¾e (aspoò zatiaµ) v¾dy vynikali, èo sa týka hrateµnosti
a atmosféry. Napríklad: séria Descent, Duke Nukem 3D, Dark Forces.

<li>Letové simulátory -- napr. Jetfighter II, hry Wing Commander, X-Wing, 
Tie Fighter, atï. 
</ul>

<p>Nemyslím si, ¾e je zákonitos» v tom, ¾e v tomto zozname sú iba hry
v prvej osobe (teda hry, kde je zobrazená situácia z pohµadu hráèa).
Nehovorím, ¾e je táto metóda nepou¾iteµná v iných hrách; myslím si, ¾e
je be¾nej¹ie, ¾e sa v tomto type hier daný prístup vyu¾íva.

<p>Keï pou¾ívate tento systém, my¹ inicializujete rovnako ako v systéme
"uká¾ a klikni" (pozrite <a href="#Initialising%20the%20mouse">Inicializácia my¹i</a>).

<p>Pri pou¾ití tohto spôsobu ovládania ¾iadate ovládaè my¹i o obnovu 
hodnoty mickey. <dfn>Mickey</dfn> je veµmi jemná miera pohybu my¹i a je
urèovaná relatívne k momentu, kedy ste ju poslednýkrát zis»ovali. Allegro
má na to funkciu <code>get_mouse_mickeys</code>:

<pre>void get_mouse_mickeys (int *mickeyx, int *mickeyy);
</pre>

<p>Dajte funkcii dva smerníky na premenné typu <code>int</code> a ona
naplní premenné, na ktoré ukazujú hodnotami, o ktoré sa zmenila X-ová a 
Y-ová súradnica my¹i odvtedy èo sme naposledy volali túto funkciu. 
Napríklad, ak <code>dx</code> a <code>dy</code> sú premenné typu 
<code>int</code>, tak volanie funkcie

<pre>get_mouse_mickeys (&amp;dx, &amp;dy);
</pre>

<p>vlo¾í mickey rozdiely do <code>dx</code> a <code>dy</code>. 
Poznamenajme, ¾e jednotky nie sú rovnaké, ako jednotky 
v <code>mouse_x</code> and <code>mouse_y</code> --
mickey má oveµa jemnej¹ie jednotky.

<p>Uká¾ka k tejto èasti, <code>examples/chap_06/ex_3_2</code>, pou¾íva 
túto techniku na pohyb ná¹ho skvelého kruhu, prièom pohyb my¹i spôsobuje
zrýchµovanie. Ako je [ed: bude] zmienené neskôr, toto je v¹eobecný model
aj pre realistickej¹ie hry -- pohyb my¹i je zviazaný so silou, ktorá 
pôsobí na objekt. Pozrite sa na uká¾ku, aspoò aby ste vedeli, ako to 
funguje.

<p><hr>[ Ïal¹í:<a rel=next href="#Ways%20to%20interpret%20input%20data">Spôsoby interpretácie vstupných dát</a>
 | Predo¹lý:<a rel=previous href="#Mouse%20input">Vstup z my¹i</a>
 | Hore:<a rel=up href="#User%20input">U¾ivateµský vstup</a>
 ]<p>

<h2><a name="Generic%20input"><a name="TOC_66">6.4 Vstup v¹eobecne</a></a></h2>

<p>Keï máme k dispozícii uvedené typy vstupov, mô¾eme písa» programy, 
v ktorých mô¾eme ovláda» veci ktorýmkoµvek z nich. Ako ale napísa» hru,
ktorá dovoµuje u¾ívateµovi pou¾i» zariadenie, ktoré si vyberie?

<p>Mô¾eme napísa» verzie reagujúceho kódu, ktoré budú interpretova» ka¾dý
typ informácie a potom pou¾ijeme ten, ktorý kore¹ponduje so zariadením, 
ktoré vybral u¾ívateµ, ale bolo by lep¹ie minimalizova» poèet styèných
bodov medzi vstupným kódom a reagujúcim kódom. Príklad 
<code>examples/chap_06/ex_4</code> ukazuje spôsob, ako sa to dá spravi»;
odporúèam vám pozera» sa do neho, kým budete èíta» túto èas». Pozrite sa
hlavne na <code>input.c</code> a <code>input.h</code>.

<p>Potrebujeme v¹eobecný formát, ktorý budeme posiela» reagujúcemu kódu.
Potrebujeme informáciu o tom, ako ïaleko je vstupné zariadenie v ka¾dom
smere, a aký je stav palebných tlaèidiel. Na uschovanie týchto informácií 
som vytvoril nasedovnú ¹truktúru:

<pre>struct input_t {
    int dx, dy;
    int fire1, fire2;
};
</pre>

<p>Nech sú <code>dx</code> a <code>dy</code> èísla z rozsahu od -128 do 128
(ako pri joystickových procedúrach), ktoré ukazujú, ktorým smerom zariadenie
ukazuje a ako ïaleko. <code>fire1</code> a <code>fire2</code> budú nenulové,
ak je stlaèené zodpovedajúce palebné tlaèidlo. Ich poèet sme obmedzili na
dve, preto¾e väè¹ina joystickov má iba dve palebné tlaèidlá; ak pí¹ete kód,
ktorý má fungova» pod viacerými systémami, èasto je rozumné obmedzi» sa na 
to, èo je sploèné.

<p>Vstupná procedúra bude musie» získa» informáciu zaka¾dým, keï ju 
zavolajú. Pre vstup z joysticku je to jednoduché; staèí skopírova» patrièné
hodnoty, keï¾e rozsah je rovnaký. Ak je joystick digitálny, budeme ale 
musie» skontrolova» <code>joy_left</code>, <code>joy_right</code>, atï.
prièom pou¾ijeme rovnaký systém, aký opí¹eme o chvíµu pre klávesnicu.

<p>Pre klávesnicu musíme nejakým spôsobom urèi», kde vlastne <dfn>ukazuje</dfn>.
Ak máme urèené klávesy <code>left_key</code> a <code>right_key</code>,
mô¾eme urèi» vychýlenie vpravo (<dfn>rightness</dfn>) nasledovne:

<pre>rightness = (key[left_key] ? -1 : 0) + (key[right_key] ? 1 : 0);
</pre>

<p>Pozrite sa, èo to spraví v jednotlivých situáciach: Ak ¾iadna z kláves
nie je stlaèená, hodnota oboch zátvoriek je nulová a výsledok je 0. Ak sú
stlaèené obe, prvá zátvorka vráti -1 a druhá 1; tak¾e výsledok je znovu 0.
Ak je stlaèená iba µavá klávesa, prvá zátvorka bude -1 a druhá 0, ak¾e 
dokopy -1 a ak je stlaèená iba pravá klávesa, výsledok bude 0+1, èo je 1.
Teraz to mô¾eme prispôsobi» na¹ej ¹truktúre napríklad takto:

<pre>dx = (key[left_key] ? -128 : 0) + (key[right_key] ? 128 : 0);
dy = (key[up_key]   ? -128 : 0) + (key[down_key]  ? 128 : 0);
fire1 = key[fire1_key];
fire2 = key[fire2_key];
</pre>

<p>Ka¾dý vstup z klávesnice tu má rovnaký úèinok ako úplné vychýlenie 
joysticku.

<p>Èo sa týka my¹i, pou¾ijeme priame ovládanie; ak by sme chceli pou¾i»
rozhranie "uká¾ a klikni", boli by sme príli¹ závislí na u¾ívateµovi,
ktorý my¹ pou¾íva. Tento systém mô¾ete simulova» s pomocou vstupných 
procedúr na µubovoµnom vstupnom zariadení, ale na tomto 
mieste to nechceme rozobera».

<p>Aby sme mohli zobrazi» premenné <code>dx</code> a <code>dy</code>
z my¹ieho kódu do rozsahu [-128,128] ktorý tu pou¾ívame, potrebujeme ich
vydeli» <code>max_mousespeed</code> a vynásobi» 128, prièom
<code>max_mousespeed</code> je premenná ovládajúca citlivos» my¹i. Spravíme
to ale v opaènom poradí, lebo potom to mô¾e zosta» ako výpoèet v celoèíselnej
aritmetike. Pretypovaniu medzi celoèíselnými a desatinnými typmi by sme
sa mali vyhnú» v¹ade, kde je to mo¾né -- je pomalé.

<p>Celý kód obsahujúci to, o èom sme sa a¾ doteraz bavili je vo funkcii
<code>input_getinput</code>.

<p>Predtým, ne¾ to zaèneme pou¾íva», je ale potrebné vstupnému modulu 
poveda», aký druh vstupu oèakávame. To mô¾ete spravi» zavolaním funkcie
<code>input_create_*</code>, ktorá mô¾e ma» nejaké parametre (v závislosti 
na tom, èo <code>*</code> v skutoènosti je). Táto funkcia musí by» urobená
tak, aby vytvorila vstupnú ¹truktúru a vrátila smerník na òu. Vstupná 
funkcia joysticku ¾iadnu informáciu naviac nepotrebuje, ale vstupná funkcia
my¹i potrebuje vedie», akú hodnotu pou¾i» pre <code>max_mousespeed</code>, 
a vstupná funkcia klávesnice potrebuje vedie», ktoré klávesy pou¾i». Mohli
by sme pou¾i» jedinú funkciu s premenlivým poètom parametrov, ale to je pre
potreby tohto tutoriálu trocha komplikované.

<p>Tak¾e definujme funkcie"

<pre>input_t *input_create_joystick ();
input_t *input_create_mouse (int max_mousespeed);
input_t *input_create_keybd (int left_key, int right_key,
                             int up_key, int down_key,
                             int fire1_key, int fire2_key);
</pre>

<p>Tie¾ budeme potrebova» funkcie pre inicializáciu vstupného modulu,
funkciu, ktorá ho zru¹í a funkciu, ktorá zru¹í u¾ zaregistrované
vstupné zariadenie (napr. ak zmeníte klávesy); ich deklarácia mô¾e
vyzera» takto:

<pre>void input_init ();
void input_shutdown ();
void input_destroy (input_t *what);
</pre>

<p>Tak¾e ak to zhrnieme, programy na zaèiatku zavolajú <code>input_init</code> 
aby nastavili modul. Potom zavolajú niektoré z <code>input_create_*</code> 
funkcií, aby zaregistrovali vstupné zariadenia hráèov; <code>input_create_keybd</code> 
sa mô¾e vola» viac ne¾ raz s rôznymi klávesami, aby mohol hra» na klávesnici 
viac ne¾ jeden hráè. Funkcie <code>input_create_*</code> vrátia smerníky na
¹truktúry <code>input_t</code>, ktorých èlenské premenné budú obnovené 
pri ka¾dom zavolaní <code>input_getinput</code>. Zaregistrované zariadenia
sa mô¾u odregistrova» zavolaním funkcie <code>input_destroy</code>, ktorá
ako parameter dostane smerník na <code>struct input_t</code>; táto funkcia
súèasne dealokuje ¹truktúru, na ktorú smerník ukazuje. Funkcia
<code>input_shutdown</code> odregistruje v¹etky zariadenia a uvoµní v¹etku
pamä», ktorá je e¹te alokovaná.

<p>©truktúra <code>input_t</code> obsahuje polia <code>dx</code>, <code>dy</code>,
<code>fire1</code> a <code>fire2</code>. <code>dx</code> and <code>dy</code>
nadobúdajú hodnoty od -128 do 128, ktoré ukazujú mno¾stvo pohybu v jednotlivých 
smeroch a <code>fire1</code> a <code>fire2</code> sú nenulové, ak je stlaèené
zodpovedajúce palebné tlaèidlo.

<p>E¹te raz, pozrite si program <code>examples/chap_06/ex_4</code>, aby ste 
videli, ako tento systém pou¾íva».

<p><hr>[ Predo¹lý:<a rel=previous href="#Generic%20input">Vstup v¹eobecne</a>
 | Hore:<a rel=up href="#User%20input">U¾ivateµský vstup</a>
 ]<p>

<h2><a name="Ways%20to%20interpret%20input%20data"><a name="TOC_67">6.5 Spôsoby interpretácie vstupných dát</a></a></h2>

<p>Táto èas» zatiaµ nie je napísaná. Keï bude, bude obsahova» informácie
o fyzikálnych modeloch (nie, nie je to taká nuda, ako to znie!) a ako
mô¾ete vstupné dáta pou¾i».

<p><hr>[ Ïal¹í:<a rel=next href="#Sound">Zvuk</a>
 | Predo¹lý:<a rel=previous href="#User%20input">U¾ivateµský vstup</a>
 | Hore:<a rel=up href="#Top">Zaèiatok</a>
 ]<p>

<h1><a name="More%202D%20graphics"><a name="TOC_68">7. Nieèo viac z 2D grafiky</a></a></h1>

<p>Táto èas» zatiaµ nie je napísaná. Keï bude, bude hovori» o:

<ul>
<li>pamä»ových bitmapách

<li>spritoch

<li>pohybe vecí bez naru¹enia pozadia

<li>znova o dvojitom bufferingu a ¹pinavých obdå¾nikoch a úvod do prepínania
stránok

</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Timers">Èasovaèe</a>
 | Predo¹lý:<a rel=previous href="#More%202D%20graphics">Nieèo viac z 2D grafiky</a>
 | Hore:<a rel=up href="#Top">Zaèiatok</a>
 ]<p>

<h1><a name="Sound"><a name="TOC_69">8. Zvuk</a></a></h1>

<ul>
<li><a href="#Sound%20configuration">Konfigurácia zvuku</a>

<li><a href="#Digital%20sound">Digitálny zvuk</a>

<li><a href="#MIDI%20music">MIDI súbory</a>
</ul>

<p><hr>[ Next:<a rel=next href="#Digital%20sound">Digitálny zvuk</a>
 | Up:<a rel=up href="#Sound">Zvuk</a>
 ]<p>

<h2><a name="Sound%20configuration"><a name="TOC_70">8.1 Konfigurácia zvuku</a></a></h2>

<ul>
<li><a href="#Initialising%20sound%20drivers">Inicializácia ovládaèov zvuku</a>

<li><a href="#Config%20file%20for%20sound">Konfiguraèný súbor pre zvuk</a>
</ul>

<p><hr>[ Next:<a rel=next href="#Config%20file%20for%20sound">Konfiguraèný súbor pre zvuk</a>
 | Up:<a rel=up href="#Sound%20configuration">Konfigurácia zvuku</a>
 ]<p>

<h3><a name="Initialising%20sound%20drivers"><a name="TOC_71">8.1.1 Inicializácia ovládaèov zvuku</a></a></h3>

<p>Aby ste nain¹talovali ovládaèe zvuku, treba zavola» funkciu:

<pre>install_sound (digi_driver, midi_driver, NULL);
</pre>

<p>kde na miesto parametra <code>digi_driver</code> vlo¾íte kon¹tantu
<code>DIGI_*</code> a na miesto parametra <code>midi_driver</code> 
kon¹tantu <code>MIDI_*</code>. Tretí parameter je zastaralý, dajte
tam skrátka NULL.

<p>Ak je funkcia úspe¹ná, vráti nulu. Nenulová návratová hodnota
pravdepodobne znamená, ¾e ovládaè, ktorý po¾adujete, nie je prístupný.
Ak pre niektorý ovládaè pou¾ívate <code>*_AUTODETECT</code>, mô¾e
to znamena», ¾e konfiguraèný súbor ¹pecifikuje, ktorý ovládaè presne
treba pou¾i» a tento ovládaè je nepou¾iteµný.

<p>Myslím si, ¾e sa málokedy vyskytne rozumný dôvod nepou¾i» 
<code>DIGI_AUTODETECT</code> a <code>MIDI_AUTODETECT</code>. Moje dôvody
sú také, ¾e ak urèíte zariadenie explicitne, hra nebude fungova», ak toto
zariadenie nie je dostupné a nebude schopná pou¾i» lep¹ie zariadenie,
ak toto dostupné bude. Dokonca ak máte v poèítaèi nejaký hardwarový 
konflikt, ktorý spôsobuje, ¾e táto voµba normálne zlyháva, nie je to dôvod
na to, aby ste zru¹ili funkènos» va¹ej hry na poèítaèoch iných µudí -- 
mô¾ete si vytvori» konfiguraèný súbor (pozrite ni¾¹ie). Konfiguraèné súbory
majú v¾dy prednos» pred autodetekciou, tak¾e konflikt zmizne -- mô¾ete sa 
spoµahnú» na to, ¾e rovnako to bude fungova» aj u koncových u¾ívateµov; 
ak sa vyskytnú problémy, mô¾u ich odstráni». Ak parametre zadáte napevno,
µudia nebudú môc» nastavenia zmeni», kým si to neprekompilujú -- èo je 
zlá novinka!

<p>Tak¾e ak nemáte veµmi dobrý dôvod (¾iaden ma nenapadá), pou¾ívajte 
kon¹tanty <code>*_AUTODETECT</code>. Dokonca uká¾kový program 
<code>play.exe</code> v adresári <code>tests</code> Allegra je pre mòa
hranièným prípadom -- pou¾íva pevne urèenú tabuµku èísel a mien ovládaèov.
To je dos» zlé; výhoda tohto prístupu (aspoò myslím) spoèíva v tom, 
¾e sa ovládaèe otestujú rýchlo. Nie ktovieaká výhoda<small>...</small>

<p>Treba poznamena» e¹te jednu vec -- MIDI prehrávaè Allegra pouèíva 
pre svoju èinnos» procedúry èasovaèa, tak¾e predtým, ako budete prehráva»
MIDI súbory ho musíte in¹talova». Viac podrobností nájdete v kapitole
<a href="#Initialising%20the%20timer%20system">Inicializácia systému èasovaèa</a>.

<p><hr>[ Predo¹lý:<a rel=previous href="#Initialising%20sound%20drivers">Inicializácia ovládaèov zvuku</a>
 | Hore:<a rel=up href="#Sound%20configuration">Konfigurácia zvuku</a>
 ]<p>

<h3><a name="Config%20file%20for%20sound"><a name="TOC_72">8.1.2 Konfiguraèný súbor pre zvuk</a></a></h3>

<p>Allegro v konfiguraèných súboroch podporuje ¹iroký okruh oblastí; 
konfigurácia zvuku je len èas»ou ¹tandardných dát a vy mô¾ete pridáva»
pre vnútornú potrebu va¹ej hry dáta podµa vlastného výberu. Èo sa v¹etkých
detailov pou¾itia konfiguraèných súborov týka, pozrite si dokumentáciu
k Allegru (ak pou¾ívate info, napí¹te v príkazovom riadku 
<code>info allegro config</code>). Tu bude zmienka iba o tom, èo sa týka
ovládaèov zvuku.

<p>Ak nepoviete inak, program skontroluje vo svojom domovskom adresári
súbory <code>allegro.cfg</code> a <code>sound.cfg</code>. Ak chcete pou¾i»
iné meno súboru, dajte ho ako parameter funkcii <code>set_config_file</code>.

<p>Informácia o konfigurácii zvuku je v èasti <code>[sound]</code>
súboru a obsahuje okrem iného informácie o tom, ktoré ovládaèe 
s akými nastaveniami sa majú pou¾i», ak za¾iadate o autodetekciu.
Allegro potom autodetekciu spracuje tak, ¾e ak je ovládaè explicitne urèený
v konfiguraènom súbore, tak sa ten ovládaè pou¾ije. Ak ¾iaden ovládaè
neurèíte, Allegro sa vám zaène hraba» v ma¹ine, aby zistilo, èo tam 
vlastne je; toto <em>mô¾e</em> ma» vedµaj¹ie efekty a navy¹e z technických 
dôvodov niektoré veci (ako napr. externé MIDI zariadenie) nikdy nebudú 
zistené

<p>Najbezpeènej¹ia a najjednoduch¹ia cesta, ako vytvori» konfiguraèné 
súbory je program <code>setup</code>. Je navrhnutý tak, aby sa dal pribali»
k va¹im hrám a aby si s jeho pomocou mohol u¾ívateµ vybra» (alebo 
si necha» zisti») a vyskú¹a» nastavenia. Setup potom ulo¾í nastavenia do 
konfiguraèného súboru, ktorý mô¾e vá¹ program èíta».

<p>Teda najjednoduch¹í spôsob ako to distribuova», je pribali» súbor 
<code>setup.exe</code> do toho istého adresára, ako spustiteµný súbor
vá¹ho programu, tak¾e výstup z programu setup bude presne tam, kde ho
vá¹ program bude oèakáva». Je veµa vecí, ktoré s pomocou programu 
setup mô¾ete nastavi» (alebo necha» tak). Úplnú informáciu nájdete 
v súbore <code>setup.txt</code> (je v tom istom adresári ako zvy¹ok 
programu setup).

<p><hr>[ Ïal¹í:<a rel=next href="#MIDI%20music">MIDI súbory</a>
 | Predo¹lý:<a rel=previous href="#Sound%20configuration">Konfigurácia zvuku</a>
 | Hore:<a rel=up href="#Sound">Zvuk</a>
 ]<p>

<h2><a name="Digital%20sound"><a name="TOC_73">8.2 Digitálny zvuk</a></a></h2>

<ul>
<li><a href="#Loading%20sound%20files">Naèítanie zvukových súborov</a>

<li><a href="#Playing%20samples">Prehrávanie zvukov</a>

<li><a href="#Adjusting%20sample%20parameters">Úprava parametrov zvuku</a>

<li><a href="#Unloading%20samples">Uvoµnenie zvukov z pamäti</a>

<li><a href="#Voice%20functions">Hlasové funkcie</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Playing%20samples">Prehrávanie zvukov</a>
 | Hore:<a rel=up href="#Digital%20sound">Digitálny zvuk</a>
 ]<p>

<h3><a name="Loading%20sound%20files"><a name="TOC_74">8.2.1 Naèítanie zvukových súborov</a></a></h3>

<p>Allegro vie èíta» digitálny zvuk z WAV a VOC súborov. Oba typy súborov 
musia by» mono. WAV súbory mô¾u by» 8 alebo 16 bitové; VOC súbory musia by»
8 bitové.

<p>Naèítanie súboru nemô¾e by» jednoduch¹ie -- meno WAV alebo VOC súboru
(musí ma» správnu koncovku) dáte ako parameter funkcii <code>load_sample</code> 
a ona vráti <code>SAMPLE *</code> ktorý ukazuje na zvuk alebo NULL, ak sa zvuk
nepodarilo nahra» (teda nebola rozlí¹ená koncovka, nebol nájdený súbor alebo
formát súboru je nesprávny alebo nepodporovaný).

<p>Mô¾ete tie¾ rovnakým spôsobom priamo zavola» <code>load_voc</code> alebo
<code>load_wav</code>. Výhodou tohto prístupu mô¾e by», ¾e sa spracuje aj 
súbor, ktorý nemá koncovku .WAV alebo .VOC.

<p><hr>[ Next:<a rel=next href="#Adjusting%20sample%20parameters">Úprava parametrov zvuku</a>
 | Previous:<a rel=previous href="#Loading%20sound%20files">Naèítanie zvukových súborov</a>
 | Up:<a rel=up href="#Digital%20sound">Digitálny zvuk</a>
 ]<p>

<h3><a name="Playing%20samples"><a name="TOC_75">8.2.2 Prehrávanie zvukov</a></a></h3>

<p>Allegrovský prehrávè zvukov mô¾e poèas prehrávania narába» so zvukmi 
rôznymi spôsobmi. Parametre, ktoré na základnej úrovni mô¾ete nastavi»
sú hlasitos», balanc a frekvencia. Zvukovému prehrávaèu tie¾ mô¾ete poveda»,
èi chcete alebo nechcete v¾dy spusti» zvuk od zaèiatku, keï sa dohrá do konca.

<p>Keï chcete prehra» zvuk, treba zavola» funkciu <code>play_sample</code>.
Má nasledujúce parametre:

<ul>
<li>zvuk, ktorý chcete prehra» (<code>SAMPLE *</code>)

<li>hlasitos» zvuku od 0 (min) do 255 (max)

<li>balanc -- smer odkiaµ zvuk vychádza od 0 (vµavo) do 255 (vpravo)

<li>frekvencia zvuku vzhµadom k originálnej frekvencii -- pri hodnote 1000
bude prehratý s pôvodnou frekvenciou, pri hodnote 2000 s dvojnásobnou
(hudobník by povedal "o oktávu vy¹¹ie") a pri hodnote 500 s poloviènou
(o oktávu ni¾¹ie).

<li>príznak cyklenia; 1 = cykli», 0 = necykli»
</ul>

<p>Poznamenajme, ¾e zmena frekvencie mô¾e vies» k nesprávnemu prehraniu
-- Allegro je kni¾nica na programovanie hier, nie súbor rafinovaných 
programov na úpravu zvukov. Tie¾ prehrávanie zvukov na ni¾¹ej hlasitosti,
ale s ovládaèom hlasitosti na va¹ej stereosúprave vytoèeným nadoraz doprava
bude vies» k skresleniu, nehovoriac o ¹ume ;). Sna¾te sa, pokiaµ je to mo¾né, 
vyu¾íva» celý rozsah hodnôt a pou¾íva» zvuky, ktoré tie¾ vnútorne pou¾ívajú
celý prípustný rozsah.

<p>Typické volanie funkcie play_sample potom bude vyzera» takto:

<pre>play_sample (gun_sound, 255, 128, 1000, 0);
</pre>

<p>èo prehrá <code>gun_sound</code> (ktorý ste predtým naèítali) na 
maximálnej hlasitosti, zo stredu, s jeho pôvodnou frekvenciou a bez
cyklenia.

<pre>play_sample (some_sound, 192, 96, 1200, 1);
</pre>

<p>bude hra» <code>some_sound</code> na 3/4 hlasitosti, posunutý jemne vµavo,
trochu vy¹¹ie ako obyèajne a v¾dy, keï príde na koniec, zaène sa hra» od 
zaèiatku.

<p>Na zastavenie prehrávania zvuku slú¾i funkcia <code>stop_sample</code>:

<pre>stop_sample (some_sound);
</pre>

<p>To je zvlá¹» u¾itoèné pri zacyklených zvukoch.

<p><hr>[ Ïal¹í:<a rel=next href="#Unloading%20samples">Uvoµnenie zvukov z pamäti</a>
 | Predo¹lý:<a rel=previous href="#Playing%20samples">Prehrávanie zvukov</a>
 | Hore:<a rel=up href="#Digital%20sound">Digitálny zvuk</a>
 ]<p>

<h3><a name="Adjusting%20sample%20parameters"><a name="TOC_76">8.2.3 Úprava parametrov prehrávaného zvuku</a></a></h3>

<p>Tieto parametre mô¾ete upravi» aj poèas prehrávania súboru. Pou¾íva
sa na to funkcia <code>adjust_sample</code>. Má rovnaké parametre ako
<code>play_sample</code> a v zozname prehrávaných zvukov hµadá ten, 
ktorý ste zadali. Tak¾e ak u¾ spomínaný zvuk <code>some_sound</code> stále
hrá, mô¾ete zru¹i» cyklenie takto:

<pre>adjust_sample (some_sound, 192, 96, 1200, 0);
</pre>

<p>Samozrejme mô¾eme zmeni» aj iné parametre. Ak chcete upravova» zvuky,
kým sú prehrávané, dbajte na to, aby súèasne nebolo prehrávaných viacero
kópií daného zvuku -- <code>adjust_sample</code> zmení iba prvú kópiu,
ktorú nájde a ostatné sa nezmenia.

<p>Rafinovanej¹í spôsob, ako prehráva» a ovláda» zvuky, ktorý nemá 
spomínané problémy nájdete v kapitole 
<a href="#Voice%20functions">Hlasové funkcie</a>.

<p><hr>[ Ïal¹í:<a rel=next href="#Voice%20functions">Hlasové funkcie</a>
 | Predo¹lý:<a rel=previous href="#Adjusting%20sample%20parameters">Úprava parametrov zvuku</a>
 | Hore:<a rel=up href="#Digital%20sound">Digitálny zvuk</a>
 ]<p>

<h3><a name="Unloading%20samples"><a name="TOC_77">8.2.4 Uvoµnenie zvukov z pamäti</a></a></h3>

<p>Keï u¾ zvuk nepotrebujete, mô¾ete ho odstráni» z pamäti funkciou 
<code>destroy_sample</code> nasledujúcim spôsobom:

<pre>destroy_sample (some_sound);
</pre>

<p>Ak zvuk e¹te stále hrá, bude automaticky zastavený.

<p><hr>[ Predo¹lý:<a rel=previous href="#Unloading%20samples">Uvoµnenie zvukov z pamäti</a>
 | Hore:<a rel=up href="#Digital%20sound">Digitálny zvuk</a>
 ]<p>

<h3><a name="Voice%20functions"><a name="TOC_78">8.2.5 Hlasové funkcie</a></a></h3>

<p>Táto èas» e¹te nebola napísaná. Bude obsahova» informácie o tom, ako
pou¾íva» hlasové funkcie priamo, aby ste získali nad zvukmi väè¹iu kontrolu.

<p>Je tu ale uká¾kový program: <code>examples/chap_08/ex_2_5</code>

<p><hr>[ Predo¹lý:<a rel=previous href="#Digital%20sound">Digitálny zvuk</a>
 | Hore:<a rel=up href="#Sound">Zvuk</a>
 ]<p>

<h2><a name="MIDI%20music"><a name="TOC_79">8.3 MIDI súbory</a></a></h2>

<ul>
<li><a href="#Loading%20MIDI%20music">Naèítanie MIDI súborov</a>

<li><a href="#Playing%20MIDI%20music">Prehrávanie MIDI súborov</a>

<li><a href="#Controlling%20MIDI%20music">Ovládanie MIDI súborov</a>

<li><a href="#Unloading%20MIDI%20music">Uvoµnenie MIDI súborov z pamäti</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Playing%20MIDI%20music">Prehrávanie MIDI súborov</a>
 | Hore:<a rel=up href="#MIDI%20music">MIDI súbory</a>
 ]<p>

<h3><a name="Loading%20MIDI%20music"><a name="TOC_80">8.3.1 Naèítanie MIDI súborov</a></a></h3>

<p>V súèasnosti podporuje Allegro iba MIDI súbory, z ktorých mô¾e nahra»
buï typ 0 alebo 1 (teda väè¹inu).

<p>Na naèítanie MIDI súboru do pamäti zavolajte funkciu <code>load_midi</code>,
ktorá ako parameter dostane meno súboru a vráti <code>MIDI *</code> alebo
NULL, ak sa naèítanie nepodarí. 

<p><hr>[ Ïal¹í:<a rel=next href="#Controlling%20MIDI%20music">Ovládanie MIDI súborov</a>
 | Predo¹lý:<a rel=previous href="#Loading%20MIDI%20music">Naèítanie MIDI súborov</a>
 | Hore:<a rel=up href="#MIDI%20music">MIDI súbory</a>
 ]<p>

<h3><a name="Playing%20MIDI%20music"><a name="TOC_81">8.3.2 Prehrávanie MIDI súborov</a></a></h3>

<p>Ak chcete zaèa» s prehrávaním MIDI objektu, jednoducho zavolajte
<code>play_midi</code>:

<pre>play_midi (title_theme, 0);
</pre>

<p>Druhý parameter je príznak cyklenia; 0 znamená necykli», èokoµvek iné
spôsobí, ¾e keï sa súbor dohrá, spustí sa od zaèiatku. Ak chcete, aby sa
vá¹ súbor opakoval od iného miesta (napríklad ak má úvod, ktorý chcete pri
opakovaní preskoèi»), mô¾ete zavola»:

<pre>play_looped_midi (background_music, loop_start, loop_end);
</pre>

<p>Keï je dosiahnutá pozícia <code>loop_end</code>, prehrávaè skoèí spä»
na <code>loop_start</code>. Ak je <code>loop_end</code> -1, návratový bod
bude a¾ na konci skladby. Jednotky pre <code>loop_start</code> a 
<code>loop_end</code> sú takty, tak ako sú odmeriavané premennou
<code>midi_pos</code> zmienenou ni¾¹ie.

<p>Inak mô¾ete hudbu zastavi» volaním <code>stop_midi</code>:

<pre>stop_midi();
</pre>

<p>Keï¾e Allegro mô¾e naraz prehráva» iba jednu hudbu, táto funkcia 
nepotrebuje parametre. Zaèiatok prehrávania hudby zatiaµ, èo hrá nejaká 
iná, spôsobí zastavenie prehrávania predo¹lej. Volanie funkcie 
<code>stop_midi</code> má rovnaký efekt ako volanie <code>play_midi</code> 
s prvým parametrom NULL.

<p><hr>[ Next:<a rel=next href="#Unloading%20MIDI%20music">Uvoµnenie MIDI súborov z pamäti</a>
 | Previous:<a rel=previous href="#Playing%20MIDI%20music">Prehrávanie MIDI súborov</a>
 | Up:<a rel=up href="#MIDI%20music">MIDI súbory</a>
 ]<p>

<h3><a name="Controlling%20MIDI%20music"><a name="TOC_82">8.3.3 Ovládanie MIDI súborov</a></a></h3>

<p>Poèas prehrávania MIDI súboru Allegro zväè¹uje raz za takt globálnu 
premennú <code>midi_pos</code>. Ak sa ¾iaden MIDI súbor neprehráva
(alebo necyklický súbor u¾ skonèil), je nastavená na -1.

<p>Poznamenajme, ¾e zväè¹enie nemusí nutne nasta» v ka¾dom takte -- ak 
sa v nejakom takte niè nehrá, premenná sa zmení a¾ pri hraní najbli¾¹ej 
noty. Ak chcete s premennou synchronizova» udalosti, uistite sa, èi je 
v ka¾dom takte nejaká nota; mô¾ete napríklad vlo¾i» notu s nulovou 
hlasitos»ou, ktorá bude slú¾i» len na spustenie udalosti.

<p>Prehrávanie mô¾ete zastavi» a znovu spusti» s pomocou funkcii
<code>midi_pause</code> a <code>midi_resume</code>. Mô¾ete skoèi» na urèitú
pozíciu v súbore ak cieµovú <code>midi_pos</code> hodnotu odovzdáte
ako parameter funkcii <code>midi_seek</code>. Pamätajte na to, ¾e 
vyhµadávanie dozadu  spôsobí previnutie súboru na zaèiatok a potom 
hµadanie dopredu; teda nebude dobrý nápad robi» za sebou niekoµko malých
vyhµadávaní dozadu.

<p>Nakoniec, ak sa súbor prehráva cyklicky, mô¾ete za jazdy zmeni» miesta
cyklenia. Dve premenné, ktoré ich urèujú, sú <code>midi_loop_start</code>
a <code>midi_loop_end</code> a sú merané v <code>midi_pos</code> jednotkách.
Hodnota -1 pre <code>midi_loop_start</code> alebo <code>midi_loop_end</code>
znamená zaèiatok resp. koniec súboru.

<p>Spomenul som u¾ predtým, ¾e èas» MIDI súboru mô¾e tvori» predohru
ktorú v cykle nechcete hra» zaka¾dým a funkcia <code>play_looped_midi</code> 
tento problém rie¹i; nastavenie bodov cyklenia vám dovoµuje spravi»
podobnú vec, ak MIDI súbor obsahuje záver, ktorý nechcete hra» poèas
opakovania -- teda chcete raz zahra» úvod, potom nekoµkokrát cykli» hlavnú 
èas» a nakoniec zahra» záver.

<p>Aby ste to dosiahli, zaènete prehráva» hudbu s pou¾itím funkcie
<code>play_looped_midi</code> kde ako parameter zaèiatku cyklu uvediete 
zaèiatok hlavnej èasti a ako koniec cyklu koniec hlavnej èasti. Potom
necháte hudbu hra»; zaka¾dým, keï hlavná èas» skonèí, spustí sa znovu 
od zaèiatku. Neskôr mô¾ete parameter konca cyklu nastavi» na koniec skladby.

<p>Sú tam ale niektoré zádrhele:

<ul>
<li><code>midi_loop_start</code> musí by» v¾dy skôr, ne¾ 
<code>midi_loop_end</code>; ak je va¹a nová ¹tartovacia hodnota väè¹ia, ne¾
stará koncová, musíte najprv zmeni» koncovú hodnotu a ak je va¹a nová
koncová hodnota men¹ia ne¾ stará ¹tartovacia, treba najprv zmeni»
¹tartovaciu.

<li>Okrem prípadov uvedených vy¹¹ie je vo v¹eobecnosti lep¹ie meni» najprv
<code>midi_loop_end</code> a a¾ potom <code>midi_loop_start</code> ak sa 
koncový bod posúva dozadu a v opaènom poradí, ak sa koncový bod posúva
dopredu. To zmen¹uje pravdepodobnos» skokov poèas zmeny.
</ul>

<p>Pravdepodobnos», ¾e niektorá z uvedených vecí  bude robi» vá¾ne problémy 
je pomerne malá, ale je lep¹ie to zabezpeèi», ne¾ µutova». (Týka sa to najmä
prvej.)

<p><hr>[ Predo¹lý:<a rel=previous href="#Controlling%20MIDI%20music">Ovládanie MIDI súborov</a>
 | Hore:<a rel=up href="#MIDI%20music">MIDI súbory</a>
 ]<p>

<h3><a name="Unloading%20MIDI%20music"><a name="TOC_83">8.3.4 Uvoµnenie MIDI súborov z pamäti</a></a></h3>

<p>Na uvoµnenie MIDI súboru z pamäti pou¾ite funkciu <code>destroy_midi</code>:

<pre>destroy_midi (background_music);
</pre>

<p>Ak je súbor práve prehrávaný, hudba sa najprv zastaví.

<p><hr>[ Ïal¹í:<a rel=next href="#Datafiles">Datasúbory</a>
 | Predo¹lý:<a rel=previous href="#Sound">Zvuk</a>
 | Hore:<a rel=up href="#Top">Zaèiatok</a>
 ]<p>

<h1><a name="Timers"><a name="TOC_84">9. Èasovaèe</a></a></h1>

<ul>
<li><a href="#Uses%20of%20timers">Pou¾itie èasovaèov</a>

<li><a href="#Setting%20up%20timer%20callbacks">Nastavenie obslu¾ných funkcií èasovaèa</a>

<li><a href="#Limitations%20of%20timers">Obmedzenia èasovaèov</a>

<li><a href="#Examples%20of%20timers">Príklady èasovaèov</a>
</ul>

<p><hr>[ Next:<a rel=next href="#Setting%20up%20timer%20callbacks">Nastavenie obslu¾ných funkcií èasovaèa</a>
 | Up:<a rel=up href="#Timers">Èasovaèe</a>
 ]<p>

<h2><a name="Uses%20of%20timers"><a name="TOC_85">9.1 Pou¾itie èasovaèov</a></a></h2>

<p>V tomto zozname nájdete rôzne pou¾itie èasovaèov. Samozrejme nie je úplný
-- jeho cieµom je poskytnú» vám predstavu, na èo sa väè¹inou èasovaèe 
pou¾ívajú. Niektoré, prípadne v¹etky z nich sa neskôr objavia v príkladoch.

<ul>
<li>Èasomiera hry

<p>Toto je pravdepodobne najbe¾nej¹ie pou¾itie. Èasovaè mô¾ete pou¾i» na to,
aby ste zistili, ako dlho hráè zotrváva v jednej úrovni aby ste mu pridali
body, ak to zvládne rýchlo, alebo ho zamordovali, ak je tam pridlho.

</p><li>Zis»ovanie obnovovacej frekvencie hry

<p>Ak zväè¹íte globálnu premennú zaka¾dým, keï prekreslíte obrazovku, mô¾ete
nastavi» èasovaè tak, aby túto hodnotu niekam raz za sekundu skopíroval. 
Miesto, kde to skopírujete, bude potom ukazova» poèet prekreslení za poslednú
sekundu -- je to skrátka èíslo FPS (frames per second, rámcov za sekundu)
alebo obnovovacia frekvencia hry. Toto je veµmi u¾itoèné, keï zis»ujete,
ako dobre hra funguje na poèítaèoch iných µudí; ak je èíslo vysoké, majú 
peknú hladkú grafiku; ak nie, grafika je trhaná.

</p><li>Ovládanie rýchlosti hry

<p>Mo¾no sa pamätáte, ¾e keï sme sa kedysi skôr pokú¹ali získa»
kon¹tantné zdr¾anie pri pohybe kruhom krí¾om cez obrazovku, tak sme na
ovládanie rýchlosti pou¾ili <code>vsync</code>.

<p>Predo¹lý systém mal zásadný nedostatok v tom, ¾e rýchlos» cyklu stále závisí
od rýchlosti poèítaèa -- ak èakáme 10 ms medzi vykresleniami a vykreslenie 
trvá 5 ms, budeme vykresµova» raz za 15 ms; ale ak vykreslenie trvá 10 ms,
budeme vykresµova» raz za 20 ms. Na reguláciu rýchlosti priveµký rozdiel.

<p>Pou¾itie <code>vsync</code> je lep¹ie; vertikálne zatemnenie prichádza 
v pravidelných intervaloch, tak¾e ak zariadime, ¾e na¹e prekreslovane a
pohyb zaberie menej èasu, ne¾ jeden zatemòovací cyklus (alebo presnej¹ie,
v¾dy zaberie rovnaký poèet zatemòovacích cyklov), dosiahneme kon¹tantnú 
rýchlos». Ak ale ostaneme na niektorom rámci trocha dlh¹ie, hra bude
vyzera», akoby na zlomok sekundy zastala, preto¾e <code>vsync</code> 
zme¹ká jeden VBI (interval vertikálneho zatemnenia) a musí èaka» na ïal¹í.
To sa deje pomerne èasto pod urèitými polo-viacúlohovými operaènými 
systémami, kde systém prevezme kontrolu nad poèítaèom tesne pred VBI
-- <code>vsync</code> potom ten VBI zme¹ká a musí èaka» na ïal¹í.
Výsledný efekt je pekne drsný (hra je stra¹ne trhaná a podµa mòa najhor¹ie
je ome¹kávanie sa v èase).

<p>Lep¹í spôsob na udr¾anie kon¹tantnej rýchlosti hry sú èasovaèe. Aby sa 
zní¾ilo blikanie, prekreslovanie musí by» stále ovládané s pomocou 
<code>vsync</code>, ale ná¹ èasovaè vie efektívne zisti», ako dlho musel
<code>vsync</code> èaka» a zdr¾anie mô¾eme neskôr vyrovna» tak, ¾e 
patrièný poèet krát prejdeme cez logiku hry.

<p>Ako presne sa to spraví, uvidíme potom, ako sa pozrieme, ako èasovaèe
fungujú. Alebo mô¾ete rovno skoèi» na danú èas» teraz -- to je na vás.
Pozrite sa na <a href="#Regulating%20game%20speed">Ovládanie rýchlosti hry</a>.

</p><li>Získavanie vstupu v pravidelných intervaloch

<p>Ak nastavíme èasovaè tak, aby behal dos» èasto, mô¾eme získa» vstup 
v pravidelných intervaloch. Naèo je to dobré? Nu¾, niektoré herné
systémy (ako napríklad ten  opísaný vy¹¹ie) majú sklon prebehnú» 
niekoµkokrát za sebou cez herný cyklus a potom zbehnú» dlhú funkciu na
obnovovanie grafiky. Strávia veµkú èas» svojho èasu kreslením a keï
s tým skonèia, znova sa rýchlo niekoµkokrát pre¾enú herným cyklom.
Ak by sme èítali vstup v¾dy poèas herného cyklu, tak by sme preèítali
zaka¾dým ten istý stav.

<p>Ako extrémny príklad si skúste predstavi», ¾e vykonanie vykresµovacej
funkcie zaberie celú sekundu a funkcia herného cyklu sa za ten èas má
vykona» desa»krát. Ak u¾ívateµ stlaèí tlaèidlo poèas behu grafickej funkcie,
alebo ho dokonca väè¹inu èasu dr¾í stlaèené, funkcia herného cyklu si to
nev¹imne, preto¾e vstup kontroluje, preto¾e vstup sa kontroluje a¾ po
skonèení grafickej funkcie. Ale ak u¾ívateµ stlaèí klávesu po skonèení
grafickej funkcie, v¹etkých 10 obnovovaní pozície bude vidie» tlaèidlo 
stlaèené, èo je tie¾ zle. To, èo potrebujeme je, aby ka¾dé obnovenie stavu
hry videlo iný stav vstupu, získaný v pravidelných intervaloch.
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Limitations%20of%20timers">Obmedzenia èasovaèov</a>
 | Predo¹lý:<a rel=previous href="#Uses%20of%20timers">Pou¾itie èasovaèov</a>
 | Hore:<a rel=up href="#Timers">Èasovaèe</a>
 ]<p>

<h2><a name="Setting%20up%20timer%20callbacks"><a name="TOC_86">9.2 Nastavenie obslu¾ných funkcií èasovaèa</a></a></h2>

<ul>
<li><a href="#Initialising%20the%20timer%20system">Inicializácia systému èasovaèov</a>

<li><a href="#Locking%20and%20volatility">Zamykanie a volatilita</a>

<li><a href="#Installing%20timer%20callbacks">In¹talovanie obslu¾ných funkcií</a>

<li><a href="#Removing%20timer%20callbacks">Odin¹talovanie obslu¾ných funkcií</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Locking%20and%20volatility">Zamykanie a volatilita</a>
 | Hore:<a rel=up href="#Setting%20up%20timer%20callbacks">Nastavenie obslu¾ných funkcií èasovaèa</a>
 ]<p>

<h3><a name="Initialising%20the%20timer%20system"><a name="TOC_87">9.2.1 Inicializácia systému èasovaèov</a></a></h3>

<p>Pred tým, ne¾ mô¾ete pou¾i» niektorú z funkcií èasovaèa, musíte 
inicializova» systém èasovaèov Allegra. Ako u¾ bolo povedané, potrebujú
to aj mnohé iné èasti Allegra (ako napríklad kód na vykreslovanie
ukazovateµa my¹i alebo prehrávaè MIDI súborov), tak¾e ho u¾ pravdepodobne 
budete ma» nain¹talovaný.

<p>Na inicializáciu systému èasovaèov zavolajte:

<pre>install_timer();
</pre>

<p>Po tomto volaní vám prestane fungova» funkcia <code>delay</code> 
z kni¾nice libc; mô¾ete pou¾i» funkciu <code>rest</code> z Allegra,
ktorá robí takmer to isté.

<p><hr>[ Ïal¹í:<a rel=next href="#Installing%20timer%20callbacks">In¹talovanie obslu¾ných funkcií</a>
 | Predo¹lý:<a rel=previous href="#Initialising%20the%20timer%20system">Inicializácia systému èasovaèov</a>
 | Hore:<a rel=up href="#Setting%20up%20timer%20callbacks">Nastavenie obslu¾ných funkcií èasovaèa</a>
 ]<p>

<h3><a name="Locking%20and%20volatility"><a name="TOC_88">9.2.2 Zamykanie a volatilita</a></a></h3>

<p>Allegrovské funkcie èasovaèa sú ovládané cez preru¹enia. Preru¹enia sú
vyvolávané istými udalos»ami a <dfn>preru¹ia</dfn> vykonávanie vá¹ho 
programu. V tomto momente procesor zaène vykonáva» kód ISR (interrupt service 
routine - funkcia obsluhy preru¹enia). Allegro má rôzne mechanizmy, s pomocou
ktorých sa dozvie o tom, ¾e sa urèité preru¹enie vyskytlo -- v tomto prípade
preru¹enie od èasovaèa.

<p>Allegrovský ovládaè preru¹enia volá rôzne funkcie, ktoré urèíte, 
nazývané <dfn>obslu¾né funkcie</dfn> (anglicky <dfn>callbacks</dfn>), 
v intervaloch, ktoré tie¾ mô¾ete urèi». Dôle¾ité je, ¾e tieto funkcie
sa volajú <dfn>vo vnútri</dfn> preru¹enia.

<p>Z rôznych technických dôvodov je veµmi ne¹»astný nápad pokú¹a» sa
poèas preru¹enia presúva» veci na disk a z disku. To znamená, ¾e sa
musíte uisti», ¾e va¹e obslu¾né funkcie nesmú by» poèas behu programu 
doèasne odlo¾ené z pamäte na disk -- ak by boli, museli by sa poèas 
preru¹enia naèítava» spä» do pamäte. Tie¾ sa musíte uisti», ¾e v¹etky dáta,
ktoré menia -- globálne premenné atï. -- sa nikdy neocitnú v swapovacom
priestore na disku. Toto urobíte <dfn>zamknutím</dfn> pamäte, kde sú
ulo¾ené. Djgpp má funkcie, ktoré to vedia urobi» a Allegro ich má pekne
zabalené vo forme nasledovných makier:

<pre>END_OF_FUNCTION (function_name);
LOCK_FUNCTION (function_name);
LOCK_VARIABLE (variable_name);
</pre>

<p><code>LOCK_VARIABLE</code> zamyká statickú alebo globálnu premennú
a <code>LOCK_FUNCTION</code> zamyká funkciu. <code>LOCK_VARIABLE</code> 
funguje aj sama o sebe, ale <code>LOCK_FUNCTION</code> potrebuje,
aby ste koniec zamykanej funkcie oznaèili s pomocou 
<code>END_OF_FUNCTION</code>. Ak <code>END_OF_FUNCTION</code> uvies»
zabudnete, dostanete spústu nebezpeène vyzerajúcich (ale celkom slu¹ne
vysvetµujúcich) varovaní kompilátora a chýb linkera. 

<p>Ïal¹ia vec, s ktorou sa stretneme, keï je reè o preru¹eniach, je
volatilita (premenlivos»). Ka¾dý slu¹ný kompilátor sa sna¾í optimalizova»
kód, ktorý generuje. Obyèajne pri tom predpokladá, ¾e premenná, do ktorej 
nezapisujete, sa nemení. To je väè¹inou pravda, ale ak niektorá funkcia
volaná cez preru¹enie túto premennú zmení, o tejto zmene nemusí 
kompilátor niè vedie». Aby ste tento problém vyrie¹ili, musíte v¹etky
premenné, ktorých sa to týka deklarova» ako <dfn>volatile</dfn>.
<code>volatile</code> je kµúèové slovo jazyka C, ktoré povie kompilátoru,
aby nerobil ¾iadne predpoklady ohµadom obsahu premennej -- a navy¹e
nebude doèasne uchováva» obsah premennej v registri.

<p>Samozrejme nedeklarujte v¹etky va¹e premenné ako volatile. Keby ste
to spravili, znaène by ste tým obmedzili schopnos» kompilátora optimalizova»
vá¹ kód a výsledný program by pravdepodobne be¾al pomal¹ie. Ako volatile
oznaète len tie premenné, do ktorých zapisujete alebo z ktorých èítate
v súvislosti s preru¹ením (teda vo vnútri obslu¾nej funkcie èasovaèa alebo
iného preru¹enia).


<p><hr>[ Ïal¹í:<a rel=next href="#Removing%20timer%20callbacks">Odin¹talovanie obslu¾ných funkcií</a>
 | Predo¹lý:<a rel=previous href="#Locking%20and%20volatility">Zamykanie a volatilita</a>
 | Hore:<a rel=up href="#Setting%20up%20timer%20callbacks">Nastavenie obslu¾ných funkcií èasovaèa</a>
 ]<p>

<h3><a name="Installing%20timer%20callbacks"><a name="TOC_89">9.2.3 In¹talovanie obslu¾ných funkcií</a></a></h3>

<p>Keï ste nain¹talovali systém èasovaèov, zamkli obslu¾né funkcie a
v¹etky dáta s ktorými narábajú a oznaèili v¹etky takéto dáta ako
<code>volatile</code>, mô¾ete koneène poveda» Allegru aby obslu¾né
funkcie zaèalo vola».

<pre>install_int (callback, msecs);
</pre>

<p>Nahraïte <code>callback</code> menom funkcie, ktorá vracia void a nemá
parametre (v jazyku C) alebo neurèený poèet parametrov (v jazyku C++).
<code>msecs</code> je interval, v akom sa bude funkcia vola».

<p>Tu je príklad funkcie pre C:

<pre>volatile int counter = 0;      /* Budeme to v obslu¾nej funkcii meni»,
                                  tak¾e to musí by» volatile. */
void my_callback_func()
{
    counter++;                 /* Pekné a jednoduché */
}
END_OF_FUNCTION (my_callback_func);   /* V¹imnite si syntax */
</pre>

<p>Poznamenajme, ¾e obslu¾ná funkcia musí by» veµmi jednoduchá. Nesmie trva»
príli¹ dlho, nesmie vola» ¾iadne kni¾nièné funkcie jazyka C, nesmie si
dovoli» ¾iadny prepych ako napr. volanie funkcií DOSu. Ak volá procedúry
Allegra, musia spåòa» rovnaké pravidlá.

<p>Ak pou¾ivame C++, musíme zmeni» definíciu funkcie na:

<pre>void my_callback_func(...)
</pre>

<p>inak dostaneme chybu.

<p>Ïalej je tu kód, ktorý pou¾ijeme na zamknutie vecí zmienených vy¹¹ie:

<pre>LOCK_FUNCTION (my_callback_func);    /* Zamkneme funkciu */
LOCK_VARIABLE (counter);             /* Mení sa v obslu¾nej funkcii,
                                        tak¾e ju zamkneme tie¾. */
</pre>

<p>Nakoniec nasledujúci riadok povie Allegru, aby na¹u funkciu volalo 
desa»krát za sekundu (raz za sto milisekúnd):

<pre>install_int(my_callback_func, 100);
</pre>

<p>V¹imnite si, ¾e aj keï <code>my_callback_func</code> je funkcia, za jej
menom nepí¹eme zátvorky (<code>(</code> a <code>)</code>) -- keby sme to 
spravili, funkcia by sa zavolala a jej (neexistujúca) návratová hodnota
by sa zadala <code>install_int</code>. My ale potrebujeme zada» miesto, kde
v pamäti zaèína kód funkcie, tak¾e zátvorky nepí¹eme.

<p>Mimochodom, ak chcete zmeni» interval volania funkcie, mô¾ete zavola»
<code>install_int</code> neskôr znova.

<p>Ak chcete ma» lep¹iu kontrolu nad obslu¾nými funkciami, mô¾ete pou¾i»
funkciu <code>install_int_ex</code>. Parameter tejto funkcie sa zadáva
v tikoch hardwarových hodín, ale mô¾ete pou¾i» makrá, ktoré na tento formát
vedia skonvertova» be¾nej¹ie jednotky -- sekundy alebo milisekundy na jedno
volanie, alebo poèet volaní za sekundu alebo minútu. Èo sa týka detailov
k tejto funkcii a ïal¹ích informácií o tom, èo obslu¾né funkcie mô¾u alebo 
nemô¾u urobi», pozrite si Allegrovkú dokumentáciu.

<p><hr>[ Predo¹lý:<a rel=previous href="#Installing%20timer%20callbacks">In¹talovanie obslu¾ných funkcií</a>
 | Hore:<a rel=up href="#Setting%20up%20timer%20callbacks">Nastavenie obslu¾ných funkcií èasovaèa</a>
 ]<p>

<h3><a name="Removing%20timer%20callbacks"><a name="TOC_90">9.2.4 Odin¹talovanie obslu¾ných funkcií</a></a></h3>

<p>Odin¹talovanie obslu¾nej funkcie je jednoduché -- staèí zavola» funkciu:

<pre>remove_int(my_callback_proc);
</pre>

<p>Teoreticky by ste teraz mohli odomknú» pamä», ktorú funkcia zaberá,
ale prakticky to nehrá ¾iadnu rolu.

<p><hr>[ Ïal¹í:<a rel=next href="#Examples%20of%20timers">Príklady èasovaèov</a>
 | Predo¹lý:<a rel=previous href="#Setting%20up%20timer%20callbacks">Nastavenie obslu¾ných funkcií èasovaèa</a>
 | Hore:<a rel=up href="#Timers">Èasovaèe</a>
 ]<p>

<h2><a name="Limitations%20of%20timers"><a name="TOC_91">9.3 Obmedzenia èasovaèov</a></a></h2>

<p>Tu je zoznam niektorých vecí, ktoré musíte a ktoré nesmiete, keï 
pí¹ete a pou¾ívate obslu¾né funkcie èasovaèov (a vo v¹eobecnosti aj 
iných preru¹ení).

<p>Musíte:

<ul>
<li>Musíte zamknú» v¹etku pamä», ktorej sa obslu¾né funkcie dotýkajú --
zamknú» samotné obslu¾né funkcie a aj premenné, ktoré pou¾ívajú. Ak
volajú iné funkcie, musíte zamknú» aj tie ako aj v¹etko, èoho sa dotýkajú; 
ak tie volajú ïal¹ie funkcie, musíte zamknú» aj tie, atï.

<li>Musíte pou¾i» volatile premenné. Ak to nespravíte, budú sa dia»
divné veci. Poèas kompilácie nedostanete varovanie ani chybovú správu
a niè ¹pecifické sa neudeje ani pri spustení programu, ale zistíte,
¾e program nerobí, èo má. Typickým príznakom je, ¾e cyklus, ktorý èaká
na to, ¾e èasovaè zmení premennú, nikdy neskonèí.
</ul>

<p>Nesmiete:

<ul>
<li>Z va¹ich obslu¾ných funkcií nevolajte funkcie DOSu. DOS vo v¹eobecnosti
nie je reentrantný a mô¾e to vo väè¹ine prípadov spôsobi» vá¾ne problémy.

<li>Nevolajte kni¾nièné funkcie jazyka C -- pokiaµ naozaj neviete, èo robíte.
Kni¾nièné funkcie Cèka mô¾u vola» DOS a ako u¾ bolo povedané vy¹¹ie, 
v súvislosti s preru¹eniami je to veµmi ne¹»astný nápad.

<li>Nerobte niè príli¹ prepychové. Va¹e obslu¾né funkcie by sa mali
vykona» veµmi rýchlo. To, ¾e sú vykonávané mimo hlavného toku programu
neznamená, ¾e neza»a¾ujú procesor. Èím dlh¹ie budú trva» va¹e obslu¾né
funkcie, tým menej èasu bude na vykonanie vá¹ho hlavného programu. Nie je
náhoda, ¾e v¹etky uká¾ky len zmenia niekoµko premenných a skonèia
-- to je zhruba úroveò, na akej by ste mali uva¾ova». Nastavi» pár 
premenných a potom necha» vá¹ hlavný kód, aby spravil »a¾kú robotu.

<li>Nechcite, aby sa va¹e obslu¾né funkcie volali èastej¹ie, ne¾ 
potrebujete. Poznamenajme, ¾e pod Windowsami musí by» èas medzi
jednotlivými volaniami násobkom 5 milisekúnd; tak¾e ak chcete, aby
va¹a hra fungovala správne pod rôznymi operaènými problémami, mali
by by» vami pou¾ité èasy násobkami 5 milisekúnd.

<li>Nein¹talujte priveµa obslu¾ných funkcií. Maximálny poèet je 16
a majte na pamäti, ¾e Allegro nejaké potrebuje pre seba.
</ul>

<p><hr>[ Predo¹lý:<a rel=previous href="#Limitations%20of%20timers">Obmedzenia èasovaèov</a>
 | Hore:<a rel=up href="#Timers">Èasovaèe</a>
 ]<p>

<h2><a name="Examples%20of%20timers"><a name="TOC_92">9.4 Príklady èasovaèov</a></a></h2>

<ul>
<li><a href="#Timing%20a%20game">Èasomiera hry</a>

<li><a href="#Measuring%20the%20frame%20rate">Zis»ovanie obnovovacej frekvencie hry</a>

<li><a href="#Regulating%20game%20speed">Ovládanie rýchlosti hry</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Measuring%20the%20frame%20rate">Zis»ovanie obnovovacej frekvencie hry</a>
 | Hore:<a rel=up href="#Examples%20of%20timers">Príklady èasovaèov</a>
 ]<p>

<h3><a name="Timing%20a%20game"><a name="TOC_93">9.4.1 Èasomiera hry</a></a></h3>

<p>Tento príklad je celkom jednoduchý. Nastavíme globálnu premennú tak, aby 
obsahovala uplynulý poèet sekúnd. Na¹a obslu¾ná funkcia bude toto èíslo
zväè¹ova». Zamkneme poèítadlo aj obslu¾nú funkciu. Potom, keï chceme spusti»
hodiny, nechháme obslu¾nú funkciu vola» raz za sekundu. Potom mô¾eme 
z (volatile!) premennej zisti», koµko èasu uplunulo.

<p>Keï èas, ktorý stopujeme uplynie, mô¾eme si poèítadlo skopírova», alebo 
len odin¹talova» obslu¾nú funkciu. Ak ju odin¹talujeme, poèítadlo sa u¾ meni» 
nebude.

<p>Ako variáciu mô¾eme naprogramova» èasový limit. V tomto prípade
nastavíme poèítadlo na poèet sekúnd, ktoré sú k dispozícií (napríklad
na uhratie levelu). Obslu¾ná funkcia bude túto hodnotu zmen¹ova».
V hlavnom cykle hry budeme kontrolova», èi je v poèítadle kladná hodnota.
Ak nie je, hráèovi vypr¹al èas. V tomto momente mô¾ete obslu¾nú funkciu 
odin¹talova», aby ste zastavili ïal¹ie zmen¹ovanie poèítadla.

<p>Pozrite si <code>examples/chap_09/ex_4_1</code>.

<p><hr>[ Ïal¹í:<a rel=next href="#Regulating%20game%20speed">Ovládanie rýchlosti hry</a>
 | Predo¹lý:<a rel=previous href="#Timing%20a%20game">Èasomiera hry</a>
 | Hore:<a rel=up href="#Examples%20of%20timers">Príklady èasovaèov</a>
 ]<p>

<h3><a name="Measuring%20the%20frame%20rate"><a name="TOC_94">9.4.2 Zis»ovanie obnovovacej frekvencie hry</a></a></h3>

<p>Toto je tie¾ celkom jednoduché

<p>Najprv si urobíme dve volatile globálne premenné -- jednu nazvanú 
<code>last_fps</code> a druhú <code>frame_counter</code>. Potom spravíme
obslu¾nú funkciu èasovaèa, ktorá jednoducho skopíruje <code>frame_counter</code>
do <code>last_fps</code> a potom nastavíte <code>frame_counter</code>
na nulu. Zamkneme obe premenné a obslu¾nú funkciu a potom obslu¾nú funkciu
necháme vyvola» raz za sekundu. 

<p>Teraz mô¾eme premennú <code>last_fps</code> zobrazi» na monitore
alebo zapísa» do logu alebo èokoµvek. Na chvíµu to bude nula. V¹etko, èo
musíme urobi», aby sme získali poèet vykreslených rámcov za sekundu je,
aby vykresµovacia funkcia po ka¾dom vykreslení rámca premennú 
<code>frame_counter</code> zväè¹ila o 1.

<p>Funguje to preto, lebo obslu¾ná funkcia sa volá ka¾dú sekundu a kopíruje
hodnotu do <code>last_fps</code>, prièom vynuluje <code>frame_counter</code>.
Potom vykreslíme nejaké rámce a kým to robíme, zväè¹uje sa premenná
<code>frame_counter</code>. Sekundu po predo¹lom volaní sa obslu¾ná funkcia
zavolá znovu a skopíruje poèet vykreslených rámcov z <code>frame_counter</code>
do <code>last_fps</code>.

<p>Pozrite si <code>examples/chap_09/ex_4_2</code>.

<p><hr>[ Predo¹lý:<a rel=previous href="#Measuring%20the%20frame%20rate">Zis»ovanie obnovovacej frekvencie hry</a>
 | Hore:<a rel=up href="#Examples%20of%20timers">Príklady èasovaèov</a>
 ]<p>

<h3><a name="Regulating%20game%20speed"><a name="TOC_95">9.4.3 Ovládanie rýchlosti hry</a></a></h3>

<p>Táto téma je mojou nomináciou na "èasto pýtanú otázku" roka 
v mailingliste Allegra. Je veµmi dôle¾itá.  Hry, ktoré nebe¾ia rovnako 
rýchlo na rôznych poèítaèoch alebo za rôznych podmienok ma ¹tvú.
Nemyslím tým, ¾e obnovovacia frekvencia musí by» na v¹etkých poèítaèoch 
rovnaká -- to samozrejme nie je mo¾né. Hovorím o rýchlosti hry --
napríklad o rýchlosti pohybu postáv.

<p>Aby ste to dosiahli, mohli by ste v ideálnom prípade chcie» hýba»
postavami v pravidelných intervaloch. ®eby vo vnútri obslu¾nej funkcie
èasovaèa? V ¾iadnom prípade. Je to príli¹ komplikované; pamätajte, ¾e
obslu¾né funkcie musia by» jednoduché. Mimochodom, predstavte si, koµko
problémov by narobilo sna¾i» sa zamknú» v¹etko, èoho sa takáto obslu¾ná
funkcia dotkne!

<p>Najlep¹ia vec, ktorú mô¾eme reálne urobi» je èasovaè zväè¹ujúci premennú,
ktorá obsahuje poèet herných cyklov, ktoré <em>by mali</em> doteraz uplynú».
Potom mô¾eme upravi» herný cyklus tak, aby túto premennú porovnával s poètom
herných cyklov, ktoré skutoène uplynuli. Ak sa ome¹kávame, musíme zavola»
funkciu obsluhujúcu logiku hry e¹te raz (prípadne niekoµkokrát), kým to 
nezrovnáme. Inak herným cyklom momentálne prejs» netreba.

<p>Ak sme patrièný poèet cyklov pre¹li, mô¾eme si da» pohov a robi» iné
veci, ako zobrazi» jeden rámec grafiky. Zobrazovanie grafiky je èasto 
pomalá vec, èiastoène preto, lebo vykreslenie nejaký èas trvá a èiastoène 
preto, lebo sa s pou¾itím <code>vsync</code> èaká na VBI. Pokiaµ kreslíme 
grafiku a èakáme na VBI, na¹a obslu¾ná funkcia èasovaèa je stále 
v pravidelných intervaloch volaná. Samozrejme s tým momentálne nerobíme niè;
ono to poèká, kým s grafikou skonèíme. Ale keï sme s grafikou hotoví, vieme 
presne, koµko herných cyklov musíme prebehnú», aby sme sa opä» dostali tam,
kde chceme by».

<p>Tak¾e ak to zhrnieme -- treba si spravi» dve poèítadlá. Jedno sa bude
zväè¹ova» v pravidelných intervaloch (cieµový interval cyklu hry) s pomocou
obslu¾nej funkcie èasovaèa a druhé bude zväè¹ova» raz za aktuálny herný
cyklus funkcia, ktorá ho vykonáva. Na zaèiatku tieto poèítadlá nastavíme na 
nulu. Pri ka¾dom prechode cez hlavný herný cyklus najprv nakreslíme jeden
rámec grafiky. To vo väè¹ine hier zaberie relatívne dlhý èas. Potom zistíme,
èi je cieµový poèet herných cyklov väè¹í, ne¾ aktuálny (to pravdepodobne 
bude) a robíme herné cykly, kým to nedo¾enieme. Potom zaèneme od zaèiatku.

<p>Pozrite si <code>examples/chap_09/ex_4_3</code>.

<p><hr>[ Predo¹lý:<a rel=previous href="#Timers">Èasovaèe</a>
 | Hore:<a rel=up href="#Top">Zaèiatok</a>
 ]<p>

<h1><a name="Datafiles"><a name="TOC_96">10. Datasúbory</a></a></h1>

<p>Súbor <code>grabber.txt</code> v podadresári <code>tools</code> Allegra
obsahuje dobrý popis takmer v¹etkých aspektov datasúborov. Ak je niektorý
tu zmienený bod nejasný, ak chcete viac informácií alebo ak tu nie je nieèo
popísané do podrobností, je to miesto, kde by ste mali hµada» ïal¹ie 
informácie.

<ul>
<li><a href="#Concept">Koncept</a>

<li><a href="#Creating%20a%20datafile">Vytvorenie datasúboru</a>

<li><a href="#Using%20a%20datafile">Pou¾itie datasúboru</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Creating%20a%20datafile">Vytvorenie datasúboru</a>
 | Hore:<a rel=up href="#Datafiles">Datasúbory</a>
 ]<p>

<h2><a name="Concept"><a name="TOC_97">10.1 Koncept</a></a></h2>

<p>Doteraz ste mohli vidie», ¾e hra vy¾aduje mnoho rôznych súborov; je
tam spustiteµný súbor, ktorý spú¹»ajú pou¾ívatelia, potom grafika buï 
v niekoµkých veµkých súboroch z ktorých ka¾dý jej obsahuje spústu, alebo
ka¾dý obrázok vo svojom vlastnom súbore (ja rad¹ej pou¾ívam prvý prístup).
Tie¾ máme zvukové efekty (jeden súbor pre ka¾dý) a hudbu (jeden súbor pre
ka¾dú èas»).

<p>To sú len ¹tandardné súbory, ktoré potrebujú takmer v¹etky hry. Okrem 
toho mô¾e ka¾dá hra obsahova» súbory s popisom levelov, umelej inteligencie
protivníkov a iné potrebné dáta. Dohromady to mô¾e by» znaèný poèet súborov.

<p>Vïaka spôsobu clusteringu pod DOSom musí by» ka¾dý súbor uchovávaný
v blokoch urèitej då¾ky. Na partíciach men¹ích, ne¾ 1Gb majú tieto
<dfn>clustre</dfn> (èíta» "klastre") veµkos» 16K. Väè¹ina súborov nezaplní 
úplne posledný cluster a zostávajúci priestor je premrhaný -- v priemernom
prípade je strata 8K na súbor, ale v praxi to pravdepodobne býva viac.
Takto premrhaný priestor mô¾e narasta», zvlá¹» ak pou¾ívate veµa súborov,
z ktorých ka¾dý je oveµa men¹í ne¾ veµkos» jedného clustra. Ak máte 
Windows 95, skúste napísa» vo va¹om adresári <code>djgpp\zoneinfo</code> 
príkaz <code>dir /s/v</code> a porovnajte "bytes" a "bytes allocated".
Keï to spravíte, mo¾no sa rozhodnete adresár vymaza», alebo aspoò zozipova»
-- pravdepodobne ho nebudete potrebova».

<p>Mno¾stvo súborov s koncovkami <code>.PCX</code>, <code>.WAV</code> 
alebo <code>.MID</code> tie¾ µudí zvádza k tomu, aby si ich "po¾ièali"
pre svoje vlastné úèely, alebo ich modifikovali a tak zmenili hru.
Ak im to nechcete dovoli», je rozumné nenecha» tam tie súbory le¾a» len tak.

<p>Odhliadnuc od predo¹lých dvoch dôvodov, je celkom chaos, ak máte v¹etky 
súbory ulo¾ené jednotlivo a va¹a hra ich má na zaèiatku v¹etky nahra». 
Datasúbory poskytujú spôsob, ako zabali» v¹etky alebo niektoré va¹e súbory do
jedného veµkého datasúboru, ktorý mô¾e by» naèítaný naraz, prípadne 
mô¾e by» skomprimovaný a dáta v òom za¹ifrované. 

<p><hr>[ Ïal¹í:<a rel=next href="#Using%20a%20datafile">Pou¾itie datasúboru</a>
 | Predo¹lý:<a rel=previous href="#Concept">Koncept</a>
 | Hore:<a rel=up href="#Datafiles">Datasúbory</a>
 ]<p>

<h2><a name="Creating%20a%20datafile"><a name="TOC_98">10.2 Vytvorenie datasúboru</a></a></h2>

<p>Datasúbory sa vytvárajú zo súborov na disku. Allegro na narábanie s nimi 
poskytuje dva hlavné prostriedky: Grabber a nástroj DAT. Oba sú dobre 
zdokumentované v súbore <code>grabber.txt</code>, v adresári <code>tools</code>
Allegra, ale spravím tu aspoò struèný popis.

<ul>
<li><a href="#The%20grabber">Grabber</a>

<li><a href="#The%20DAT%20utility">Nástroj DAT</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#The%20DAT%20utility">Nástroj DAT</a>
 | Hore:<a rel=up href="#Creating%20a%20datafile">Vytvorenie datasúboru</a>
 ]<p>

<h3><a name="The%20grabber"><a name="TOC_99">10.2.1 Grabber</a></a></h3>

<p>(nebolo zatiaµ napísané)

<p><hr>[ Predo¹lý:<a rel=previous href="#The%20grabber">Grabber</a>
 | Hore:<a rel=up href="#Creating%20a%20datafile">Vytvorenie datasúboru</a>
 ]<p>

<h3><a name="The%20DAT%20utility"><a name="TOC_100">10.2.2 Nástroj DAT</a></a></h3>

<p>(nebolo zatiaµ napísané)

<p><hr>[ Predo¹lý:<a rel=previous href="#Creating%20a%20datafile">Vytvorenie datasúboru</a>
 | Hore:<a rel=up href="#Datafiles">Datasúbory</a>
 ]<p>

<h2><a name="Using%20a%20datafile"><a name="TOC_101">10.3 Pou¾itie datasúboru vo va¹om programe</a></a></h2>

<p>Je viacero spôsobov, ako mô¾ete preèíta» dáta z datasúboru. V prvom rade
mô¾ete preèíta» celý datasúbor, v¹etko naraz. Za druhé mô¾ete preèíta» jednu
zlo¾ku datasúbosu zvlá¹». A nakoniec mô¾ete otvori» zlo¾ku datasúboru, ako 
keby to bol normálny súbor.

<ul>
<li><a href="#Loading%20an%20entire%20datafile">Naèítanie celého datasúboru</a>

<li><a href="#Individually%20loading%20datafile%20components">Jednotlivé naèítanie zlo¾ky datasúboru</a>

<li><a href="#Reading%20a%20datafile%20component%20as%20a%20normal%20packfile">Èítanie zlo¾ky datasúboru ako normálneho súboru</a>
</ul>

<p><hr>[ Ïal¹í:<a rel=next href="#Individually%20loading%20datafile%20components">Jednotlivé naèítanie zlo¾ky datasúboru</a>
 | Hore:<a rel=up href="#Using%20a%20datafile">Pou¾itie datasúboru</a>
 ]<p>

<h3><a name="Loading%20an%20entire%20datafile"><a name="TOC_102">10.3.1 Naèítanie celého datasúboru</a></a></h3>

<p>Toto je zvyèajný spôsob, akým sa veci robia. Pri tomto prístupe staèí
zavola» jednu funkciu a Allegro naèíta v¹etky objekty, ktoré ste ulo¾ili
v datasúbore. Funkcia, ktorú treba zavola» je <code>load_datafile</code>:

<pre>DATAFILE *load_datafile(char *filename);
</pre>

<p>Dáte jej meno vá¹ho datasúboru a vráti smerník na pole ¹truktúr DATAFILE,
pre ka¾dý objekt je tam jedna. Tak¾e ak <code>data</code> je 
<code>DATAFILE *</code> a vy napí¹ete:

<pre>data = load_datafile("datafile.dat");
</pre>

<p>potom <code>data[0]</code> bude prvý objekt datasúboru, <code>data[1]</code> 
druhý, atï.

<p>Najdôle¾itej¹ia polo¾ka v ¹truktúre DATAFILE je polo¾ka <code>dat</code>.
Je to smerník, ktorý ukazuje na aktuálne dáta objektu. Ak je objekt bitmapa,
potom toto pole ukazuje na ¹truktúru BITMAP -- tak¾e mô¾ete písa»:

<pre>blit(data[0].dat, screen, <small>...</small>);
</pre>

<p>Ak je objekt zvuk, tak je to ¹truktúra SAMPLE:

<pre>play_sample(data[1].dat, 255, 128, 1000, 0);
</pre>

<p>Rovnako to funguje pre MIDI súbory, palety, animácie a niektoré 
ïal¹ie veci. V grabberi alebo nástroji DAT mô¾ete vidie», akého typu
dát sú jednotlivé objekty, je to uvedené v zozname vµavo od mena objektu
(napí¹te <code>dat -l &lt;filename&gt;</code>, alebo sa pozrite na µavú 
stranu obrazovky grabbera).

<p>Tie¾ sa dá poveda», aký typ dát sa v objekte nachádza podµa polo¾ky
<code>type</code>. Táto je nastavená na kon¹tantu ako 
<code>DAT_BITMAP</code>, <code>DAT_SAMPLE</code> or <code>DAT_MIDI</code>.  
Ak dáta nie sú v zvlá¹tnom formáte, je to <code>DAT_DATA</code> --
znamená to, ¾e <code>dat</code> iba ukazuje na blok dát. Veµkos» tohto
bloku mô¾ete zisti» z polo¾ky <code>size</code> ¹trultúry DATAFILE:

<pre>load_map_data(data[2].dat, data[2].size);
</pre>

<p>odovzdá smerník na binárny blok a jeho veµkos» funkcii
<code>load_map_data</code> (ktorú si sami napí¹ete).

<p>Ïalej, ako zisti», aké èíslo objektu v datasúbore kore¹ponduje 
s jednotlivými objektami, ktoré ste vlo¾ili do datasúboru? Sú tri spôsoby,
ako to zisti» a ako v¾dy, je na vás, ktorý z nich zvolíte. Podµa okolností
mô¾ete zmixova» v¹etky tri dohromady.

<p>Prvý spôsob je pou¾i» hlavièkový súbor, ktorý vám mô¾e vytvori» grabber
alebo nástroj DAT. Tento súbor bude obsahova» jedno makro pre ka¾dý súbor,
ktoré #definuje meno objektu ako jeho index v datasúbore. Tak¾e miesto 
pou¾itia toho, èo som písal vy¹¹ie, mô¾ete poveda»:

<pre>blit(data[MY_BITMAP].dat, screen, <small>...</small>);
play_sample(data[MY_SAMPLE].dat, 255, 128, 1000, 0);
load_map_data(data[MY_MAP].dat, data[MY_MAP].size);
</pre>

<p>Ak pri tomto prístupe pridáte do datasúboru nové objekty a ulo¾íte 
ich pred staré, nemusíte v celom programe meni» v¹etky indexy.

<p>Text ka¾dého #define je presne to, èo zadáte grabberu ako meno objektu. Ak na
vytváranie objektu pou¾ijete nástroj DAT, jeho meno bude pravdepodobne pôvodné
meno súboru napísané veµkými písmenami s tým, ¾e znak <code>.</code> bude
nahradený znakom <code>_</code>. Táto náhrada sa robí preto, aby výsledné meno
objektu mohlo by» pou¾iteµné v #define v Cèku -- bodky povolené nie sú.

<p>V tejto súvislosti majte na pamäti, ¾e keï vyberiete svojim objektom mená,
tak budú pou¾ité vo va¹om programe ako makrá v #define -- nevyberajte teda mená,
ktoré mô¾u by» pou¾ité na òieèo iné (napr.<code>main</code>,
<code>BITMAP</code>, atï. ) V grabberi alebo nástroji dat mô¾ete pou¾i»
nastavenie <code>Prefix</code>, èo spôsobí, ¾e sa pred ka¾dé meno v hlavièkovom
súbore nieèo vlo¾í. Ak ho napr. nastavíte na <code>DATAFILE</code>, dostanete:

<pre>blit(data[DATAFILE_BITMAP].dat, screen, <small>...</small>);
</pre>

<p>ak bolo meno objektu <code>BITMAP</code>.

<p>Ïal¹í spôsob, ako sa dá zisti», kde sa objekt v datasúbore nachádza je
zalo¾ený na fakte, ¾e sú ulo¾ené v abecednom poradí.  Podµa autora je to pravda
teraz a v¾dy aj bude. Neodporúèam pou¾íva» túto vlastnos» prièasto, ale mô¾e by»
u¾itoèná, ak napríklad máte viacero bitmáp (napríklad rámce jedného spritu),
ktoré sú nazvané <code>ENEMY_000</code>, <code>ENEMY_001</code>,
<code>ENEMY_002</code>, atï. Aby ste sa na ne odvolali, mô¾ete samozrejme
pou¾íva» mená z #define, ale je výhodnej¹ie môc» vybra» niektorú z týchto
premenných s pomocou èísla ulo¾eného v premennej.

<p>Kvôli spôsobu, akým preprocesing funguje (<code>pre</code> = pred, t.j. pred
kompiláciou) nie je mo¾né zmeni» poèas behu programu <code>ENEMY_000</code> na
<code>ENEMY_xxx</code>. Ale keï¾e sú objekty ulo¾ené v abecednom poradí, viete,
¾e <code>ENEMY_000</code> bude ulo¾ená v súbore ako prvá a
<code>ENEMY_001</code> bude tesne za òou -- teda n-tá bitmapa s nepriateµom bude
objekt èíslo <code>ENEMY_000 + n</code> (ak ako ka¾dý normálny programátor
zaèínate èíslova» od nily, teda <code>ENEMY_000</code> je nultý objekt.) Potom
nasledujúca vec bude fungova»:

<pre>void draw_nth_enemy (int n, BITMAP *where, int x, int y)
{
    draw_sprite(where, data[ENEMY_000 + n], x, y);
}
</pre>

<p>Tretí spôsob nájdenia objektu v datasúbore znamená prehµádávanie datasúboru,
kým nenájdete objekt so správnym menom. Mená objektov sú ulo¾ené ako
<dfn>properties</dfn> (vlastnosti) objektov. V¹etky detaily nájdete v súbore
<code>grabber.txt</code>. Struène ale, ak chcete získa» meno objektu, napí¹te:

<pre>name = get_datafile_property(&amp;dat[obj_number],
                              DAT_ID ('N','A','M','E'));
</pre>

<p>V¹imnite si toho <code>&amp;</code> -- odovzdávate smerník na prvok poµa. Ak
je re»azec, ktorý sa vráti, prázdny (teda name[0] == '\0', <em>nie</em> name ==
NULL), potom objekt nemá vlastnos» <code>NAME</code>. To pravdepodobne znamená,
¾e ste z datasúboru vysekali vlastnosti; v tom prípade musíte na vyhµadanie
objektu pou¾i» niektorú z predo¹lých dvoch metód.

<p>Je spústa ïal¹ích vecí, o ktorých by bolo dobré sa tu zmieni». V prvom rade,
ak pou¾ívate C++, potom sa kompilátoru nebude páèi», ¾e dávate pole
<code>dat</code> (smerník na void) ako parameter funkciam, ktoré oèakávajú iný
typ smerníka, tak¾e ho musíte explicitne pretypova» na to, èo funkcia oèakáva:

<pre>play_midi( (MIDI *) data[MUSIC].dat, 0);
</pre>

<p>Po druhé (a so vz»ahom k predo¹lému) je èasto výhodné zriadi» si aliasy k
objektom v datasúbore tak, ¾e vytvoríte globálne premenné alebo polia, nieèo
ako:

<pre>BITMAP *enemy_bitmap;
MIDI *background_music;
SAMPLE *crash_sound;
</pre>

<p>potom ich nastavíte, aby ukazovali na urèité miesta v datasúbore:

<pre>data = load_datafile("DATAFILE.DAT");
if (!data) barf();  /* loading failed */

enemy_bitmap = (BITMAP *) data[ENEMY_BITMAP];
background_music = (MIDI *) data[MUSIC];
crash_sound = (SAMPLE *) data[CRASH_SOUND];
</pre>

<p>a koneène ich pou¾ijete v hre:

<pre>draw_sprite(screen, enemy_bitmap, x, y);
play_midi(background_music, 1);
play_sample(crash_sound, 255, 128, 1000, 0);
</pre>

<p>Výhody tohto prístupu sú, ¾e sa zbavíte obtia¾neho pretypovávania potrebného
v C++, výsledný kód bude kraj¹í a trochu rýchlej¹í a tie¾ to zjednodu¹í prechod
z kódu zalo¾eného na datasúboroch na kód zalo¾ený na jednotlivých súboroch alebo
naopak.

<p>Po tretie, pole datasúboru je zakonèené objektom typu <code>DAT_END</code>.
Mô¾ete a nemusíte to poklada» za veµmi u¾itoèné; je to temer zbytoèná
informácia, èosi ako ¾e <code>argv[argc]</code> je NULL. Ak chcete celý
datasúbor z nejakého dôvodu prehµáda» (napríklad, aby ste na¹li objekt s urèitou
vlastnos»ou), mô¾ete tento fakt pou¾i», aby ste vedeli, kde máte presta».

<p>Nakoniec, keï prácu s datasúborom skonèíte, mô¾ete ho odstráni» z pamäte
pou¾itím funkcie <code>unload_datafile</code>:

<pre>unload_datafile(data);
</pre>

<p>Je zbytoèné hovori», ¾e keï to spravíte, nemô¾ete viac pole <code>data</code>
pou¾íva» a ak máte nejaké aliasy  pre objekty v poli (ako vy¹¹ie), nemô¾ete
pou¾íva» ani tie.

<p>Pozrite si príklad: <code>examples/chap_10/ex_3_1</code>

<p><hr>[ Ïal¹í:<a rel=next href="#Reading%20a%20datafile%20component%20as%20a%20normal%20packfile">Èítanie zlo¾ky datasúboru ako normálneho súboru</a>
 | Predo¹lý:<a rel=previous href="#Loading%20an%20entire%20datafile">Naèítanie celého datasúboru</a>
 | Hore:<a rel=up href="#Using%20a%20datafile">Pou¾itie datasúboru</a>
 ]<p>

<h3><a name="Individually%20loading%20datafile%20components"><a name="TOC_103">10.3.2 Jednotlivé naèítanie zlo¾ky datasúboru</a></a></h3>

<p>Je mo¾né z datasúboru naèíta» aj jednotlivé objekty, za predpokladu, ¾e v
datasúbore sú informácie o menách (teda, ¾e ste v grabberi nevysekali v¹etky
vlastnosti, alebo ste nepou¾ili <code>-s2</code> v nástroji dat). Funkcia, ktorá
to spraví, je <code>load_datafile_object</code> a pou¾íva sa spôsobom:

<pre>data_object = load_datafile_object ("datafile.dat", "object_name");
</pre>

<p><code>data_object</code> bude <code>DATAFILE *</code>, rovnako ako keby ste
naèítali celý datasúbor. Na prístup k objektu len dereferencujete smerník:

<pre>music_object = load_datafile_object("datafile.dat", "MUSIC");
play_midi(music_object-&gt;dat);      /* alebo music_object[0].dat */
</pre>

<p>Keï¾e je naèítaný len jeden objekt, funkcia vráti smerník na jedinú ¹truktúru
DATAFILE, nie na celé pole. Tak¾e nemô¾ete pou¾i» index objektu z hlavièkového
súboru a za vráteným objektom nenasleduje ¾iaden <code>DAT_END</code> objekt.

<p>Na odstránenie objektu naèítaného týmto spôsobom z pamäti pou¾ijete funkciu
<code>unload_datafile_object</code>:
 
<pre>unload_datafile_object(data_object);
</pre>

<p>Pozrite príklad: <code>examples/chap_10/ex_3_2</code>

<p><hr>[ Predo¹lý:<a rel=previous href="#Individually%20loading%20datafile%20components">Jednotlivé naèítanie zlo¾ky datasúboru</a>
 | Hore:<a rel=up href="#Using%20a%20datafile">Pou¾itie datasúboru</a>
 ]<p>

<h3><a name="Reading%20a%20datafile%20component%20as%20a%20normal%20packfile"><a name="TOC_104">10.3.3 Èítanie zlo¾ky datasúboru ako normálneho súboru</a></a></h3>

<p>Príjemná vlastnos» Allegrovských funkcií na prácu s pakovanými súbormi je
schopnos» èíta» objekt dátového súboru, ako by to bol súbor na disku. Staèí na
to pou¾i» kódovaný formát mena súboru <code>meno_datasúboru#meno_objektu</code>,napríklad:

<pre>fp = pack_fopen("datafile.dat#MUSIC", F_READ);
</pre>

<p>Ak potom <code>fp</code> nie je NULL, mô¾ete z neho èíta» ako z normálneho
pakovaného súboru. Nemô¾ete do neho zapisova». Keï ich chcete zatvori»,
pou¾ijete <code>pack_fclose</code> ako zvyèajne.

<p>Pozrite si príklad: <code>examples/chap_10/ex_3_3</code>

<p><hr>[ Hore:<a rel=up href="#Top">Zaèiatok</a>
 ]<p>

<h1>Obsah</h1>
<ul>
<li><a href="#TOC_0">1. Úvod</a>
<ul>
<li><a href="#TOC_1">1.1 O tutoriáli</a>
<li><a href="#TOC_2">1.2 Zámer</a>
<li><a href="#TOC_3">1.3 Cieµová skupina</a>
<li><a href="#TOC_4">1.4 Po¾iadavky</a>
<li><a href="#TOC_5">1.5 Predtým, ne¾ zaèneme <small>...</small></a>
</ul>
<li><a href="#TOC_6">2. Ako získa», nain¹talova» a pou¾íva» Allegro</a>
<ul>
<li><a href="#TOC_7">2.1 Èo je to Allegro</a>
<li><a href="#TOC_8">2.2 Kde získa» Allegro</a>
<li><a href="#TOC_9">2.3 Ako nain¹talova» Allegro</a>
<li><a href="#TOC_10">2.4 Testovanie in¹talácie</a>
<li><a href="#TOC_11">2.5 Pou¾itie Allegra</a>
</ul>
<li><a href="#TOC_12">3. Základná ¹truktúra hry</a>
<ul>
<li><a href="#TOC_13">3.1 Èo v¹etko musí hra robi»?</a>
<li><a href="#TOC_14">3.2 Návrh ¹truktúry</a>
<li><a href="#TOC_15">3.3 Projekt rozdelený do súborov</a>
</ul>
<li><a href="#TOC_16">4. Úvod do grafiky</a>
<ul>
<li><a href="#TOC_17">4.1 Nastavenie grafického re¾imu</a>
<li><a href="#TOC_18">4.2 Kreslenie objektov</a>
<ul>
<li><a href="#TOC_19">4.2.1 ©truktúra BITMAP</a>
<li><a href="#TOC_20">4.2.2 Kreslenie pixelov</a>
<li><a href="#TOC_21">4.2.3 Nejaké ïal¹ie primitívy</a>
<li><a href="#TOC_22">4.2.4 Písanie textu</a>
</ul>
<li><a href="#TOC_23">4.3 Práca s paletou</a>
<ul>
<li><a href="#TOC_24">4.3.1 Èo je to paleta</a>
<li><a href="#TOC_25">4.3.2 Zmena polo¾ky palety</a>
<li><a href="#TOC_26">4.3.3 Zmena palety</a>
<li><a href="#TOC_27">4.3.4 Stmievanie a rozsvecovanie</a>
</ul>
<li><a href="#TOC_28">4.4 Jednoduchá animácia</a>
<ul>
<li><a href="#TOC_29">4.4.1 Èo je to animácia</a>
<li><a href="#TOC_30">4.4.2 Ako urobi», aby veci vyzerali, ¾e sa hýbu</a>
<li><a href="#TOC_31">4.4.3 Zní¾enie blikania</a>
<ul>
<li><a href="#TOC_32">4.4.3.1 Synchronizácia na zatemnenie</a>
<li><a href="#TOC_33">4.4.3.2 Maximalizácia èasu vykreslenia</a>
<li><a href="#TOC_34">4.4.3.3 Optimalizácia poradia vykreslenia</a>
<li><a href="#TOC_35">4.4.3.4 Dvojitý buffering</a>
<li><a href="#TOC_36">4.4.3.5 ©pinavé obdå¾niky</a>
<li><a href="#TOC_37">4.4.3.6 Striedavé vykreslovanie riadkov</a>
</ul>
</ul>
</ul>
<li><a href="#TOC_38">5. Ako zariadi», aby sa niekoµko vecí dialo súèasne</a>
<ul>
<li><a href="#TOC_39">5.1 Ïal¹ie kruhy</a>
<li><a href="#TOC_40">5.2 Aj ¹tvorce</a>
<li><a href="#TOC_41">5.3 Uchovávanie viacerých vecí</a>
<ul>
<li><a href="#TOC_42">5.3.1 Dynamická alokácia</a>
<li><a href="#TOC_43">5.3.2 Zre»azené zoznamy</a>
<ul>
<li><a href="#TOC_44">5.3.2.1 Jednoducho zre»azené zoznamy</a>
<li><a href="#TOC_45">5.3.2.2 Dvojmo zre»azené zoznamy</a>
<li><a href="#TOC_46">5.3.2.3 Kruhovo zre»azené zoznamy</a>
<li><a href="#TOC_47">5.3.2.4 Pou¾itie zre»azených zoznamov</a>
</ul>
</ul>
<li><a href="#TOC_48">5.4 Objektovo orientované programovanie</a>
</ul>
<li><a href="#TOC_49">6. U¾ivateµský vstup</a>
<ul>
<li><a href="#TOC_50">6.1 Vstup z klávesnice</a>
<ul>
<li><a href="#TOC_51">6.1.1 Preèo sú ¹tandardné klávesnicové funkcie nepou¾iteµné</a>
<li><a href="#TOC_52">6.1.2 Klávesnicové funkcie allegra</a>
<li><a href="#TOC_53">6.1.3 Ako nieèím pohnú» s pomocou klávesnice</a>
<li><a href="#TOC_54">6.1.4 Ako necha» u¾ívateµa vybra» si klávesy</a>
</ul>
<li><a href="#TOC_55">6.2 Vstup z joysticku</a>
<ul>
<li><a href="#TOC_56">6.2.1 Digitálne snímanie</a>
<li><a href="#TOC_57">6.2.2 Tlaèítka na streµbu</a>
<li><a href="#TOC_58">6.2.3 Analógové snímanie a kalibrácia</a>
</ul>
<li><a href="#TOC_59">6.3 Vstup z my¹i</a>
<ul>
<li><a href="#TOC_60">6.3.1 Uká¾ a klikni</a>
<ul>
<li><a href="#TOC_61">6.3.1.1 Inicializácia my¹i</a>
<li><a href="#TOC_62">6.3.1.2 Èítanie my¹i</a>
<li><a href="#TOC_63">6.3.1.3 Zobrazenie ukazovateµa my¹i</a>
<li><a href="#TOC_64">6.3.1.4 Ovládanie ukazovateµa my¹i</a>
</ul>
<li><a href="#TOC_65">6.3.2 Priama kontrola my¹ou</a>
</ul>
<li><a href="#TOC_66">6.4 Vstup v¹eobecne</a>
<li><a href="#TOC_67">6.5 Spôsoby interpretácie vstupných dát</a>
</ul>
<li><a href="#TOC_68">7. Nieèo viac z 2D grafiky</a>
<li><a href="#TOC_69">8. Zvuk</a>
<ul>
<li><a href="#TOC_70">8.1 Konfigurácia zvuku</a>
<ul>
<li><a href="#TOC_71">8.1.1 Inicializácia ovládaèov zvuku</a>
<li><a href="#TOC_72">8.1.2 Konfiguraèný súbor pre zvuk</a>
</ul>
<li><a href="#TOC_73">8.2 Digitálny zvuk</a>
<ul>
<li><a href="#TOC_74">8.2.1 Naèítanie zvukových súborov</a>
<li><a href="#TOC_75">8.2.2 Prehrávanie zvukov</a>
<li><a href="#TOC_76">8.2.3 Úprava parametrov zvuku</a>
<li><a href="#TOC_77">8.2.4 Uvoµnenie zvukov z pamäti</a>
<li><a href="#TOC_78">8.2.5 Hlasové funkcie</a>
</ul>
<li><a href="#TOC_79">8.3 MIDI súbory</a>
<ul>
<li><a href="#TOC_80">8.3.1 Naèítanie MIDI súborov</a>
<li><a href="#TOC_81">8.3.2 Prehrávanie MIDI súborov</a>
<li><a href="#TOC_82">8.3.3 Ovládanie MIDI súborov</a>
<li><a href="#TOC_83">8.3.4 Uvoµnenie MIDI súborov z pamäti</a>
</ul>
</ul>
<li><a href="#TOC_84">9. Èasovaèe</a>
<ul>
<li><a href="#TOC_85">9.1 Pou¾itie èasovaèov</a>
<li><a href="#TOC_86">9.2 Nastavenie obslu¾ných funkcií èasovaèa</a>
<ul>
<li><a href="#TOC_87">9.2.1 Inicializácia systému èasovaèov</a>
<li><a href="#TOC_88">9.2.2 Zamykanie a volatilita</a>
<li><a href="#TOC_89">9.2.3 In¹talovanie obslu¾ných funkcií</a>
<li><a href="#TOC_90">9.2.4 Odin¹talovanie obslu¾ných funkcií</a>
</ul>
<li><a href="#TOC_91">9.3 Obmedzenia èasovaèov</a>
<li><a href="#TOC_92">9.4 Príklady èasovaèov</a>
<ul>
<li><a href="#TOC_93">9.4.1 Èasomiera hry</a>
<li><a href="#TOC_94">9.4.2 Zis»ovanie obnovovacej frekvencie hry</a>
<li><a href="#TOC_95">9.4.3 Ovládanie rýchlosti hry</a>
</ul>
</ul>
<li><a href="#TOC_96">10. Datasúbory</a>
<ul>
<li><a href="#TOC_97">10.1 Koncept</a>
<li><a href="#TOC_98">10.2 Vytvorenie datasúboru</a>
<ul>
<li><a href="#TOC_99">10.2.1 Grabber</a>
<li><a href="#TOC_100">10.2.2 Nástroj DAT</a>
</ul>
<li><a href="#TOC_101">10.3 Pou¾itie datasúboru</a>
<ul>
<li><a href="#TOC_102">10.3.1 Naèítanie celého datasúboru</a>
<li><a href="#TOC_103">10.3.2 Jednotlivé naèítanie zlo¾ky datasúboru</a>
<li><a href="#TOC_104">10.3.3 Èítanie zlo¾ky datasúboru ako normálneho súboru</a>
</ul>
</body></html>

