<?xml version="1.0" encoding="ISO-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">
<head>

<meta http-equiv="content-type" content="text/html; charset=ISO-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta http-equiv="content-script-type" content="text/javascript" />
<meta http-equiv="content-style-type" content="text/css" />

<meta name="robots" content="all, follow" />
<meta name="resource-type" content="document" />

<meta name="description" content="NeHe OpenGL Tutoriály v èe¹tinì, programování 3D grafiky, èlánky, programy se zdrojovými kódy..." />
<meta name="keywords" content="opengl, nehe, tutoriály, woq, programování, 3D" />
<meta name="author" content="all: Michal Turek - Woq; woq (zavináè) seznam.cz" />
<meta name="copyright" content="Copyright (c) 2002, 2003, 2004 Michal Turek - Woq" />

<title>CZ NeHe OpenGL - Lekce 37 - Cel-Shading</title>

<link rel="shortcut icon" href="skin/default/web.ico" type="image/x-icon" />
<link href="skin/default.css" rel="stylesheet" type="text/css" media="all" />
<link href="skin/print.css" rel="stylesheet" type="text/css" media="print" />

</head>

<body>

<!-- Levý sloupec -->
<div class="levy">
<div id="main_menu">
<a href="http://nehe.ceske-hry.cz/"><img src="skin/default/web_logo.gif" width="135" height="135" style="margin-left: 5px;" alt="CZ NeHe OpenGL" /></a>

<div class="main_menu_bez_loga">

<ul class="text_main_menu">
<li><a href="my.php" title="Pøekladatelé NeHe Tutoriálù a autoøi èlánkù">My</a></li>
<li><a href="novinky.php" title="Co je nového">Novinky</a></li>
<li><a href="navigacni_mapa.php" title="Pøehledná navigace na jednotlivé stránky, které dohromady tvoøí tento web">Navigaèní mapa</a></li>
<li><a href="kontakt.php" title="Kontakt na správce tohoto webu">Kontakt</a></li>
<li><a href="http://forum.programovani.com/" title="Diskusní fórum">Fórum</a></li>
</ul>

<ul class="text_main_menu">
<li><a href="clanky.php" title="Obsah èlánkù">Èlánky</a></li>
<li><a href="tut_obsah.php" title="Obsah NeHe OpenGL Tutoriálù">NeHe Tutoriály</a></li>
<li><a href="33D_index.php" title="Obsah Free3D (33D) Basecode">33D Basecode</a></li>
<li><a href="programy.php" title="Programy od èeských autorù">Èeské programy</a></li>
<li><a href="cl_gl_zacinam.php" title="Kde zaèít pøi uèení OpenGL">Pomoc, zaèínám</a></li>
<li><a href="odkazy.php" title="Jiné zdroje informací">Odkazy</a></li>
<li><a href="cl_gl_faq.php" title="FAQ: Èasto kladené dotazy">FAQ</a></li>
</ul>

<ul class="text_main_menu">
<li><a href="spoluprace.php" title="Nechcete se podílet na tvorbì tìchto webových stránek?">Spolupráce...?</a></li>
<li><a href="download.php" title="Stahujte">Download</a></li>
<li><a href="skiny.php" title="Nastavte si jiný layout a design stránek">Skiny</a></li>
<li><a href="javascript:window.print();" title="Vytiskne tuto stránku">Tisk</a></li>
</ul>

<ul class="text_main_menu">
<li>
<form action="p_fulltext.php" method="post" onsubmit="if(!this.najit.value || this.najit.value=='výraz ...') { alert('Byl zadán prázdný øetìzec!'); this.najit.focus(); return false; }">
<input type="text" name="najit" size="12" value="výraz ..." onclick="this.value=''" /><br />
<input type="submit" value="Najít" />
</form>
</li>
</ul>

<ul class="text_main_menu">
<li>Online ètenáøù: 2</li>
</ul>

</div>

</div>
</div>
<!-- Levý sloupec (konec) -->

<!-- Pravý sloupec -->
<div class="pravy">
<div id="tut_menu">

<ul class="text_tut_menu">
<li class="li_tut"><a href="tut_00.php" title="Lekce 0 - Pøedmluva k NeHe Tutoriálùm">00</a></li>
<li class="li_tut"><a href="tut_01.php" title="Lekce 1 - Vytvoøení OpenGL okna ve Windows">01</a></li>
<li class="li_tut"><a href="tut_02.php" title="Lekce 2 - Vytváøení trojúhelníkù a ètyøúhelníkù">02</a></li>
<li class="li_tut"><a href="tut_03.php" title="Lekce 3 - Barvy">03</a></li>
<li class="li_tut"><a href="tut_04.php" title="Lekce 4 - Rotace">04</a></li>
<li class="li_tut"><a href="tut_05.php" title="Lekce 5 - Pevné objekty">05</a></li>
<li class="li_tut"><a href="tut_06.php" title="Lekce 6 - Textury">06</a></li>
<li class="li_tut"><a href="tut_07.php" title="Lekce 7 - Texturové filtry, osvìtlení, ovládání pomocí klávesnice">07</a></li>
<li class="li_tut"><a href="tut_08.php" title="Lekce 8 - Blending">08</a></li>
<li class="li_tut"><a href="tut_09.php" title="Lekce 9 - Pohyb bitmap ve 3D prostoru">09</a></li>
<li class="li_tut"><a href="tut_10.php" title="Lekce 10 - Vytvoøení 3D svìta a pohyb v nìm">10</a></li>
<li class="li_tut"><a href="tut_11.php" title="Lekce 11 - Efekt vlnící se vlajky">11</a></li>
<li class="li_tut"><a href="tut_12.php" title="Lekce 12 - Display list">12</a></li>
<li class="li_tut"><a href="tut_13.php" title="Lekce 13 - Bitmapové fonty">13</a></li>
<li class="li_tut"><a href="tut_14.php" title="Lekce 14 - Outline fonty">14</a></li>
<li class="li_tut"><a href="tut_15.php" title="Lekce 15 - Mapování textur na fonty">15</a></li>
<li class="li_tut"><a href="tut_16.php" title="Lekce 16 - Mlha">16</a></li>
<li class="li_tut"><a href="tut_17.php" title="Lekce 17 - 2D fonty z textur">17</a></li>
<li class="li_tut"><a href="tut_18.php" title="Lekce 18 - Kvadriky">18</a></li>
<li class="li_tut"><a href="tut_19.php" title="Lekce 19 - Èásticové systémy">19</a></li>
<li class="li_tut"><a href="tut_20.php" title="Lekce 20 - Maskování">20</a></li>
<li class="li_tut"><a href="tut_21.php" title="Lekce 21 - Pøímky, antialiasing, èasování, pravoúhlá projekce, základní zvuky a jednoduchá herní logika">21</a></li>
<li class="li_tut"><a href="tut_22.php" title="Lekce 22 - Bump Mapping &amp; Multi Texturing">22</a></li>
<li class="li_tut"><a href="tut_23.php" title="Lekce 23 - Mapování textur na kulové kvadriky">23</a></li>
<li class="li_tut"><a href="tut_24.php" title="Lekce 24 - Výpis OpenGL roz¹íøení, oøezávací testy a textury z TGA obrázkù">24</a></li>
<li class="li_tut"><a href="tut_25.php" title="Lekce 25 - Morfování objektù a jejich nahrávání z textového souboru">25</a></li>
<li class="li_tut"><a href="tut_26.php" title="Lekce 26 - Odrazy a jejich oøezávání za pou¾ití stencil bufferu">26</a></li>
<li class="li_tut"><a href="tut_27.php" title="Lekce 27 - Stíny">27</a></li>
<li class="li_tut"><a href="tut_28.php" title="Lekce 28 - Bezierovy køivky a povrchy, fullscreen fix">28</a></li>
<li class="li_tut"><a href="tut_29.php" title="Lekce 29 - Blitter, nahrávání .RAW textur">29</a></li>
<li class="li_tut"><a href="tut_30.php" title="Lekce 30 - Detekce kolizí">30</a></li>
<li class="li_tut"><a href="tut_31.php" title="Lekce 31 - Nahrávání a renderování modelù">31</a></li>
<li class="li_tut"><a href="tut_32.php" title="Lekce 32 - Picking, alfa blending, alfa testing, sorting">32</a></li>
<li class="li_tut"><a href="tut_33.php" title="Lekce 33 - Nahrávání komprimovaných i nekomprimovaných obrázkù TGA">33</a></li>
<li class="li_tut"><a href="tut_34.php" title="Lekce 34 - Generování terénù a krajin za pou¾ití vý¹kového mapování textur">34</a></li>
<li class="li_tut"><a href="tut_35.php" title="Lekce 35 - Pøehrávání videa ve formátu AVI">35</a></li>
<li class="li_tut"><a href="tut_36.php" title="Lekce 36 - Radial Blur, renderování do textury">36</a></li>
<li class="li_tut"><a href="tut_37.php" title="Lekce 37 - Cel-Shading">37</a></li>
<li class="li_tut"><a href="tut_38.php" title="Lekce 38 - Nahrávání textur z resource souboru &amp; texturování trojúhelníkù">38</a></li>
<li class="li_tut"><a href="tut_39.php" title="Lekce 39 - Úvod do fyzikálních simulací">39</a></li>
<li class="li_tut"><a href="tut_40.php" title="Lekce 40 - Fyzikální simulace lana">40</a></li>
<li class="li_tut"><a href="tut_41.php" title="Lekce 41 - Volumetrická mlha a nahrávání obrázkù pomocí IPicture">41</a></li>
<li class="li_tut"><a href="tut_42.php" title="Lekce 42 - Více viewportù">42</a></li>
<li class="li_tut"><a href="tut_43.php" title="Lekce 43 - FreeType Fonty v OpenGL">43</a></li>
<li class="li_tut"><a href="tut_44.php" title="Lekce 44 - Èoèkové efekty">44</a></li>
<li class="li_tut"><a href="tut_45.php" title="Lekce 45 - Vertex Buffer Object (VBO)">45</a></li>
<li class="li_tut"><a href="tut_46.php" title="Lekce 46 - Fullscreenový antialiasing">46</a></li>
<li class="li_tut"><a href="tut_47.php" title="Lekce 47 - CG vertex shader">47</a></li>
<li class="li_tut"><a href="tut_48.php" title="Lekce 48 - ArcBall rotace">48</a></li>
</ul>

</div>
</div>
<!-- Pravý sloupec (konec) -->

<!-- Vlastní obsah stránky -->
<div class="stred">

<!--[if IE ]>
<div style="text-align: center;">
<a href="http://firefox.czilla.cz/"><img alt="Mozilla Firefox: Objevte znovu web" title="Mozilla Firefox: Objevte znovu web" style="border:none; width:468px;height:60px" src="http://firefox.czilla.cz/img/p/cz-ff-468x60-w-objevte.png" /></a>
</div>
<![endif]-->

<img src="images/nehe_tut/tut_37.jpg" class="nehe_maly" alt="Lekce 37" />

<h1>Lekce 37 - Cel-Shading</h1>

<p class="nadpis_clanku">Cel-Shading je druh vykreslování, pøi kterém výsledné modely vypadají jako ruènì kreslené karikatury z komiksù (cartoons). Rozlièné efekty mohou být dosa¾eny miniaturní modifikací zdrojového kódu. Cel-Shading je velmi úspì¹ným druhem renderingu, který doká¾e kompletnì zmìnit duch hry. Ne ale v¾dy... musí se umìt a pou¾ít s rozmyslem.</p>

<p>Èlánek o teorii Cel-Shadingu napsal Sami &quot;MENTAL&quot; Hamlaoui a umístil ho na <a href="http://www.gamedev.net/reference/programming/features/celshading" target="_blank" title="http://www.gamedev.net/reference/programming/features/celshading">GameDev.net</a>. Poté, co byl jeho èlánek publikován, zavalili ètenáøi Samiho emaily, ve kterých se dotazovali po zdrojovém kódu. Napsal tedy dal¹í èlánek, tentokrát pro NeHe, který u¾ ale popisuje pouze zdrojový kód. Tato èeská verze je slo¾ena z obou èlánkù - teoretického i praktického.</p>

<h2>Teoretická èást</h2>

<p>Pøedtím ne¾ pùjdete dál, mìli byste mít dostateèné znalosti z následujících oblastí:</p>

<ul>
<li>Mapování 1D textur</li>
<li>Texturovací koordináty</li>
<li>Softwarové osvìtlení</li>
<li>Vektorová matematika</li>
</ul>

<p>Pokud nìèemu z tìchto ètyø polo¾ek nerozumíte, neznamená to, ¾e byste nutnì neporozumìli Cel-Shadingu, ale urèitì budete mít obrovské potí¾e s psaním vlastních programù.</p>

<h3>Základní rendering</h3>

<p>Zaèneme opravdu jednoduchými vìcmi. ®ádná svìtla, ¾ádné obrysy, pouze ploché cartoon modely. Budeme potøebovat jenom dva druhy dat - pozici a barvu ka¾dého vertexu. Pøed kreslením v¾dy vypneme osvìtlení a blending. Co by se stalo? Pøi zapnutých svìtlech by objekty vypadaly normálnì. Nedosáhli bychom plochého cartoon efektu. Blending vypínáme, aby se jednotlivé vertexy nesmíchaly s ostatními.</p>

<h4>Shrnuto</h4>

<ul>
<li>Vypnout svìtla</li>
<li>Vypnout blending</li>
<li>Vykreslit obarvené body</li>
</ul>

<h3>Základní osvìtlení (smìrové)</h3>

<p>Ka¾dý vertex bude potøebovat i dal¹í data. Kromì pùvodní pozice a barvy budeme pou¾ívat i normálový vektor a intenzitu osvìtlení (jedna float hodnota). Tyto nové promìnné pou¾ijeme pro renderování se základním osvìtlením.</p>

<h4>Svìtelné mapy (lighting maps)</h4>

<p>Nechci vás poplést, pod lightmapami si nepøedstavujte simulaci svìtel na objektech typu Quake 1 a Quake 2. Podívejte se na stìny, abyste pochopili, co mám na mysli. Nepøedstavujte si oblasti, které jsou osvìtleny/ztmaveny specifickými místy map. To, co budeme pou¾ívat zde, je kompletnì novou formou lightmap - 1D textury.</p>

<p>Zkuste si najít nìjakou animaci (Cartoon Network je v¾dy dobrým zdrojem) a podívejte se na osvìtlení postav. V¹imli jste si, ¾e nejsou hladké jako v reálném ¾ivotì? Svìtlo se rozdìluje do jednotlivých plo¹ek. Nikdy jsem nesly¹el ¾ádný termín nebo pojmenování pro tento efekt, tak¾e mu budeme øíkat Sharp lighting. Abychom ho vytvoøili potøebujeme definovat 1D texturu, která bude ukládat po¾adované hodnoty.</p>

<div class="okolo_img"><img src="images/nehe_tut/tut_37_texmap.gif" width="257" height="18" alt="1D textura" /></div>

<p>Toto je textura 1x16 pixelù (velmi zvìt¹ená). Pou¾íváme hodnoty stupòù ¹edi, proto¾e budou zkombinovány s barvou vertexu. Mù¾ete si v¹imnout, ¾e v lightmapì jsou pouze 3 barvy, které mají podobnou intenzitu, jaká se pou¾ívá v animovaných filmech. Díky tomu, ¾e pou¾íváme velikost právì 16 pixelù, mù¾eme snadno modifikovat hodnoty, abychom vytvoøili rozlièné efekty. Pokud chcete, mù¾ete také pou¾ít obyèejnou èernobílou texturu, ale nedoporuèuje se to. Nikdy byste nemìli pou¾ít 100% èernou, proto¾e tato barva vytváøí vyzdvi¾ení a okraje, které vypadají dost ¹patnì.</p>

<p>Jakmile máte vytvoøenu svou texturu, nahrajte ji do API, které pou¾íváte (OpenGL, DX, software). Vrátíme se k ní za chvíli.</p>

<h4>Poèítání osvìtlení</h4>

<p>Teï pøijdou vhod znalosti ohlednì softwarového osvìtlení. Pokusím se v¹e vysvìtlit jednoduchým jazykem. V¾dy se ujistìte, ¾e máte normalizovaný smìrový vektor svìtla! V¹e, co potøebujeme udìlat, je spoèítání skalárního souèinu vektoru svìtla s normálou vertexu.</p>

<p>Skalární souèin je matematická funkce, která spoèítá úhel mezi dvìma vektory a vrátí ho jako kosinus úhlu. Invertujeme-li kosinus získáme úhel. Namísto kosinu v¹ak pova¾ujte èíslo za texturovací koordinátu. Texturovací koordináty jsou èísla od nuly do jedné. Kosinus je sice v rozmezí -1 a¾ 1, ale pokud bude èíslo záporné mù¾eme mu pøiøadit nulu. Skalární souèin vektoru svìtla a normály vertexu mù¾eme tedy pova¾ovat za texturovací koordináty!</p>

<h4>Rendering objektu</h4>

<p>Nyní máme texturovací koordináty ka¾dého vertexu, je èas vykreslit objekt. Stejnì jako minule vypneme svìtla i blending, ale zapneme 1D texturování. Vykreslíme objekt stejnì jako minule, ale pøed tím, ne¾ umístíme vertex, specifikujeme texturové koordináty (simulace svìtla).</p>

<h4>Shrnuto</h4>

<ul>
<li>Vytvoøit Sharp lighting mapu</li>
<li>Spoèítat a ulo¾it skalární souèin mezi normálou vertexu a smìrovým vektorem svìtla</li>
<li>Vypnout svìtla a blending</li>
<li>Zapnout texturování</li>
<li>Zvolit texturu lightmapy</li>
<li>Vykreslit polygony urèené texturovacími koordináty, barvou a pozicí vertexù</li>
</ul>

<h3>Umístitelná svìtla</h3>

<p>Tato metoda je pouhou modifikací minulého postupu. Umístitelné svìtlo nabízí mnohem více flexibility ne¾ smìrové osvìtlení, proto¾e mù¾e být libovolnì posunováno po scénì. Dynamicky osvìtlované polygony jsou více realistické, ale pou¾itá matematika je del¹í. Ne komplikovanìj¹í, pouze del¹í.</p>

<h4>Spoèítání Sharp koordinátù svìtla</h4>

<p>U smìrového osvìtlení jsme potøebovali získat skalární souèin smìrového vektoru svìtla s normálou vertexu. Nyní, proto¾e umístitelná svìtla nemají smìrový vektor (emitují svìtlo do v¹ech smìrù), bude mít ka¾dý vertex svùj paprsek, který záøí skrz nìj. Nejdøíve potøebujeme urèit vektor smìøující z pozice svìtelného zdroje k pozici vertexu. Normalizujeme ho, tak¾e bude mít jednotkovou délku. tím jsme získali smìr svìtla k vertexu. Vypoèítáme skalární souèin mezi vektorem svìtla a normálou vertexu. V¹e opakujeme pro ka¾dý vertex ve scénì. Tìmito nadbyteènými výpoèty se v¹ak sní¾í FPS. Pojïme se podívat na rychlej¹í metodu, která redukuje celkový poèet osvìtlených vertexù.</p>

<h4>Testování vzdálenosti od svìtla</h4>

<p>Ke sní¾ení poètu osvìtlených vertexù pøiøadíme ka¾dému svìtlu polomìr kam paprsky dosahují. Pøed poèítáním hodnot osvìtlení (viz. vý¹e) zkontrolujeme, jestli je vertex v kouli, urèené polomìrem svìtla. Pokud ano, aplikujeme na nìj svìtla. Je to základní detekce kolizí s koulí, na kterou existují spousty èlánkù a tutoriálù.</p>

<h4>Rendering</h4>

<p>Objekt vykreslíme stejnì jako u smìrového osvìtlení. Specifikujeme barvu, texturovací koordináty a pozici.</p>

<h4>Shrnuto</h4>

<ul>
<li>Vytvoøit Sharp lighting mapu</li>
<li>Pøi pou¾ití polomìru svìtla zjistit, jestli je bod uvnitø</li>
<li>Získat a normalizovat vektor od svìtla k vertexu</li>
<li>Vypoèítat skalární souèin vektoru s normálou vertexu</li>
<li>Zopakovat 2-4x pro ka¾dý vertex (Pøekl.: ???)</li>
<li>Renderovat jako minule</li>
</ul>

<h3>Obrysy a zvýraznìní</h3>

<p>Obrysy a zvýraznìní jsou tenké èerné linky reprezentující tahy tu¾kou, které zdùrazòují okraje. Mù¾ou znepokojit, ale jejich vytvoøení je mnohem jednodu¹¹í ne¾ si myslíte.</p>

<h4>Výpoèet kde zvýrazòovat</h4>

<p>Pravidlo je jednoduché: vykreslit linku na okraji, který má jeden pøivrácený a jeden odvrácený polygon. Zní to hloupì, ale zkuste se podívat napøíklad na klávesnici. V¹imli jste si, ¾e nemù¾ete vidìt zadní èásti kláves? To proto, ¾e jsou odvrácené. Na rozhraní vykreslíme èáru, abychom zvýraznili, ¾e tam je okraj.</p>

<p>Mo¾ná, ¾e si to ani neuvìdomujete, ale nikde jsem se nezmínil o na¹em vlastním cullingu polygonù. To proto, ¾e v¹e za nás udìlá API, ve kterém programujeme.</p>

<h4>Rendering zvýraznìní</h4>

<p>Klasicky vykreslíme objekt a pak nastavíme ¹íøku èáry na dva a¾ tøi pixely. Mù¾eme také zapnout antialiasing. Zmìníme mód cullingu, aby odstraòoval pøivrácené polygony. Pøepneme do drátìného modelu, tak¾e se budou vykreslovat pouze okrajové hrany polygonù. Vykreslíme je, ale nepotøebujeme specifikovat barvu a texturovací koordináty. Tím vykreslíme drátìný model objektu z relativnì ¹irokých linek. Nicménì... cullingem jsou linky pøivrácených polygonù odstranìny a depth bufferem se vyøadí v¹echny linky, které jsou hloubìji ne¾ pøivrácené (tedy ty zadní). Zdálo by se, ¾e tedy nevykreslíme nic. Ale díky ¹íøce èáry zasahují linky okrajových polygonù a¾ za okraje objektu. Právì ty se vykreslí. Z toho plyne, ¾e tato metoda nebude pracovat pøi tlou¹»ce èáry nastavené na jeden pixel.</p>

<h4>Shrnuto</h4>

<ul>
<li>Vykreslit objekt jako normálnì</li>
<li>Pøepnout orientaci facù</li>
<li>Nastavit 100% èernou barvu</li>
<li>Zmìnit mód polygonù na drátìný model</li>
<li>Vykreslit objekt znovu, ale specifikovat pouze pozice vertexù</li>
<li>Obnovit originální nastavení</li>
</ul>

<p>To je z teorie asi v¹echno. Nyní se ji pokusíme pøevést do praxe.</p>

<h2>Praktická èást</h2>

<p>Na zaèátku bych se chtìl omluvit za volbu pou¾itého modelu, ale v poslední dobì si hodnì hraji s Quake 2...</p>

<p class="src0">#include &lt;windows.h&gt;<span class="kom">// Hlavièkový soubor pro Windows</span></p>
<p></p>
<p class="src0">#include &lt;gl\gl.h&gt;<span class="kom">// Hlavièkový soubor pro OpenGL32 knihovnu</span></p>
<p class="src0">#include &lt;gl\glu.h&gt;<span class="kom">// Hlavièkový soubor pro Glu32 knihovnu</span></p>
<p class="src0">#include &lt;gl\glaux.h&gt;<span class="kom">// Hlavièkový soubor pro Glaux knihovnu</span></p>
<p></p>
<p class="src0">#include &lt;math.h&gt;<span class="kom">// Hlavièkový soubor pro matematickou knihovnu</span></p>
<p class="src0">#include &lt;stdio.h&gt;<span class="kom">// Hlavièkový soubor pro standardní vstup/výstup</span></p>
<p></p>
<p class="src0">#include &quot;NeHeGL.h&quot;<span class="kom">// Hlavièkový soubor pro NeHeGL</span></p>

<p>Nadefinujeme pár struktur, které nám pomohou pøi ukládání dat. První z tìchto struktur je tagMATRIX. Pokud se na ni podíváte, zjistíte, ¾e ukládá matici jako jednorozmìrné pole 16ti floatù místo toho, aby to bylo dvourozmìrné pole 4x4. To je proto, ¾e OpenGL pracuje taky s jednorozmìrným polem. Pokud bychom pou¾ili 4x4, hodnoty by byly ve ¹patném poøadí.</p>

<p class="src0">typedef struct tagMATRIX<span class="kom">// Ukládá OpenGL matici</span></p>
<p class="src0">{</p>
<p class="src1">float Data[16];<span class="kom">// Matice ve formátu OpenGL</span></p>
<p class="src0">}</p>
<p class="src0">MATRIX;</p>

<p>Dal¹í strukturou je vektor, který ukládá jednotlivé x, y, z slo¾ky na osách.</p>

<p class="src0">typedef struct tagVECTOR<span class="kom">// Struktura vektoru</span></p>
<p class="src0">{</p>
<p class="src1">float X, Y, Z;<span class="kom">// Slo¾ky vektoru</span></p>
<p class="src0">}</p>
<p class="src0">VECTOR;</p>

<p>Tøetí je vertexová struktura. Ka¾dý vertex se bude skládat z pozice a normály (¾ádné texturovací koordináty). Slo¾ky struktury musí být v uvedeném poøadí, jinak se pøi loadování stane nìco OPRAVDU stra¹ného (sám jsem kvùli tomu rozsekal celý tento kód, abych na¹el chybu).</p>

<p class="src0">typedef struct tagVERTEX<span class="kom">// Struktura vertexu</span></p>
<p class="src0">{</p>
<p class="src1">VECTOR Nor;<span class="kom">// Normála vertexu</span></p>
<p class="src1">VECTOR Pos;<span class="kom">// Pozice vertexu</span></p>
<p class="src0">}</p>
<p class="src0">VERTEX;</p>

<p>Nakonec struktura polygonu. Vím, ¾e toto není nejlep¹í zpùsob, jak ukládat vertexy, ale pro jednoduchost to staèí. Normálnì bych pou¾il pole vertexù a pole polygonù obsahujících indexy vertexù tvoøících polygon, ale my to udìláme jinak - v¹e pro jednoduchost.</p>

<p class="src0">typedef struct tagPOLYGON<span class="kom">// Struktura polygonu</span></p>
<p class="src0">{</p>
<p class="src1">VERTEX Verts[3];<span class="kom">// Pole tøí vertexù</span></p>
<p class="src0">}</p>
<p class="src0">POLYGON;</p>

<p>Nádhernì jednoduchá èást kódu. Pøeètìte si komentáø ke ka¾dé promìnné a budete vìdìt, proè jsme ji deklarovali.</p>

<p class="src0">bool outlineDraw = true;<span class="kom">// Flag pro vykreslování obrysu</span></p>
<p class="src0">bool outlineSmooth = false;<span class="kom">// Flag pro vyhlazování èar</span></p>
<p class="src0">float outlineColor[3] = { 0.0f, 0.0f, 0.0f };<span class="kom">// Barva èar</span></p>
<p class="src0">float outlineWidth = 3.0f;<span class="kom">// Tlou¹»ka èar</span></p>
<p></p>
<p class="src0">VECTOR lightAngle;<span class="kom">// Smìr svìtla</span></p>
<p class="src0">bool lightRotate = false;<span class="kom">// Flag oznamující zda rotujeme svìtlem</span></p>
<p></p>
<p class="src0">float modelAngle = 0.0f;<span class="kom">// Úhel natoèení objektu na ose y</span></p>
<p class="src0">bool modelRotate = false;<span class="kom">// Flag na otáèení modelem</span></p>
<p></p>
<p class="src0">POLYGON* polyData = NULL;<span class="kom">// Data polygonù</span></p>
<p class="src0">int polyNum = 0;<span class="kom">// Poèet polygonù</span></p>
<p></p>
<p class="src0">GLuint shaderTexture[1];<span class="kom">// Místo pro jednu texturu</span></p>

<p>Model je ulo¾en úplnì nejjednodu¹¹ím zpùsobem. Prvních pár bajtù obsahuje poèet polygonù tvoøících objekt a zbytek souboru je pole tagPOLYGON struktur. Proto mù¾e následující funkce data pøímo naèíst bez jakéhokoliv dal¹ího upravování.</p>

<p class="src0">BOOL ReadMesh()<span class="kom">// Naète obsah souboru model.txt</span></p>
<p class="src0">{</p>
<p class="src1">FILE *In = fopen(&quot;Data\\model.txt&quot;, &quot;rb&quot;);<span class="kom">// Otevøe soubor</span></p>
<p></p>
<p class="src1">if (!In)<span class="kom">// Kontrola chyby otevøení</span></p>
<p class="src2">return FALSE;</p>
<p></p>
<p class="src1">fread(&amp;polyNum, sizeof(int), 1, In);<span class="kom">// Naète hlavièku souboru (poèet vertexù)</span></p>
<p></p>
<p class="src1">polyData = new POLYGON[polyNum];<span class="kom">// Alokace pamìti</span></p>
<p class="src1">fread(&amp;polyData[0], sizeof(POLYGON) * polyNum, 1, In);<span class="kom">// Naète v¹echna data</span></p>
<p></p>
<p class="src1">fclose(In);<span class="kom">// Zavøe soubor</span></p>
<p class="src1">return TRUE;<span class="kom">// Loading objektu úspì¹ný</span></p>
<p class="src0">}</p>

<p>Funkce DotProduct() spoèítá úhel mezi dvìma vektory nebo rovinami. Funkce Magnitude() spoèítá délku vektoru a funkce Normalize() upraví vektor na jednotkovou délku.</p>

<p class="src0">inline float DotProduct(VECTOR &amp;V1, VECTOR &amp;V2)<span class="kom">// Spoèítá odchylku dvou vektorù</span></p>
<p class="src0">{</p>
<p class="src1">return V1.X * V2.X + V1.Y * V2.Y + V1.Z * V2.Z;<span class="kom">// Vrátí úhel</span></p>
<p class="src0">}</p>
<p></p>

<p class="src0">inline float Magnitude(VECTOR &amp;V)<span class="kom">// Spoèítá délku vektoru</span></p>
<p class="src0">{</p>
<p class="src1">return sqrtf(V.X * V.X + V.Y * V.Y + V.Z * V.Z);<span class="kom">// Vrátí délku vektoru</span></p>
<p class="src0">}</p>
<p></p>

<p class="src0">void Normalize(VECTOR &amp;V)<span class="kom">// Vytvoøí jednotkový vektor</span></p>
<p class="src0">{</p>
<p class="src1">float M = Magnitude(V);<span class="kom">// Spoèítá aktuální délku vektoru</span></p>
<p></p>
<p class="src1">if (M != 0.0f)<span class="kom">// Proti dìlení nulou</span></p>
<p class="src1">{</p>
<p class="src2">V.X /= M;<span class="kom">// Normalizování jednotlivých slo¾ek</span></p>
<p class="src2">V.Y /= M;</p>
<p class="src2">V.Z /= M;</p>
<p class="src1">}</p>
<p class="src0">}</p>

<p>Funkce RotateVector() pootoèí vektor podle zadané matice. V¹imnìte si, ¾e vektor pouze otoèí, ale u¾ nic nedìlá s jeho pozicí. Funkce se pou¾ívá pro otáèení normál, aby zajistila, ¾e normály budou pøi poèítání osvìtlení ukazovat správným smìrem.</p>

<p class="src0">void RotateVector(MATRIX &amp;M, VECTOR &amp;V, VECTOR &amp;D)<span class="kom">// Rotace vektoru podle zadané matice</span></p>
<p class="src0">{</p>
<p class="src1">D.X = (M.Data[0] * V.X) + (M.Data[4] * V.Y) + (M.Data[8]  * V.Z);<span class="kom">// Otoèení na x</span></p>
<p class="src1">D.Y = (M.Data[1] * V.X) + (M.Data[5] * V.Y) + (M.Data[9]  * V.Z);<span class="kom">// Otoèení na y</span></p>
<p class="src1">D.Z = (M.Data[2] * V.X) + (M.Data[6] * V.Y) + (M.Data[10] * V.Z);<span class="kom">// Otoèení na z</span></p>
<p class="src0">}</p>

<p>První významnìj¹í funkcí tohoto enginu je Initialize(), která provádí to, co je z jejího názvu zjevné - inicializaci.</p>

<p class="src0">BOOL Initialize (GL_Window* window, Keys* keys)<span class="kom">// U¾ivatelská a OpenGL inicializace</span></p>
<p class="src0">{</p>
<p class="src1">int i;<span class="kom">// Øídící promìnná cyklù</span></p>

<p>Následující 3 promìnné jsou pou¾ity pro naètení shader souboru. Line obsahuje jeden øádek øetìzce a pole shaderData ukládá hodnoty pro shading. Pou¾íváme 96 hodnot namísto 32, proto¾e potøebujeme pøevést stupnì ¹edi na hodnoty RGB, aby s nimi mohlo OpenGL pracovat. Mù¾eme sice hodnoty ulo¾it jako stupnì ¹edi, ale bude jednodu¹¹í kdy¾ pøi nahrávání textury pou¾ijeme stejné hodnoty pro jednotlivé slo¾ky RGB.</p>

<p class="src1">char Line[255];<span class="kom">// Pole 255 znakù</span></p>
<p class="src1">float shaderData[32][3];<span class="kom">// Pole 96 shader hodnot</span></p>
<p></p>
<p class="src1">FILE *In = NULL;<span class="kom">// Ukazatel na soubor</span></p>

<p>Klasické nastavení enginu a OpenGL...</p>

<p class="src1">g_window = window;</p>
<p class="src1">g_keys = keys;</p>
<p></p>
<p class="src1">glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);<span class="kom">// Perspektivní korekce</span></p>
<p></p>
<p class="src1">glClearColor(0.7f, 0.7f, 0.7f, 0.0f);<span class="kom">// Svìtle ¹edé pozadí</span></p>
<p class="src1">glClearDepth(1.0f);<span class="kom">// Nastavení hloubkového bufferu</span></p>
<p></p>
<p class="src1">glEnable(GL_DEPTH_TEST);<span class="kom">// Zapne testování hloubky</span></p>
<p class="src1">glDepthFunc(GL_LESS);<span class="kom">// Typ testování hloubky</span></p>

<p>Pøi vykreslování èar chceme, aby byly pìknì vyhlazené. Implicitnì je tato funkce vypnuta, ale stiskem klávesy 2 ji mù¾eme zapínat a vypínat podle libosti.</p>

<p class="src1">glShadeModel(GL_SMOOTH);<span class="kom">// Jemné stínování</span></p>
<p class="src1">glDisable(GL_LINE_SMOOTH);<span class="kom">// Vypne vyhlazování èar</span></p>

<p>Zapneme oøezávání vnitøních stìn objektu, které stejnì nejsou vidìt a vypneme OpenGL svìtla, proto¾e potøebné výpoèty provedeme po svém.</p>

<p class="src1">glEnable(GL_CULL_FACE);<span class="kom">// Zapne face culling (oøezávání stìn)</span></p>
<p class="src1">glDisable(GL_LIGHTING);<span class="kom">// Vypne svìtla</span></p>

<p>V dal¹í èásti kódu naèteme shader soubor. Obsahuje pouze 32 desetinných èísel ulo¾ených, pro jednoduchou modifikaci, v ASCII formátu, ka¾dé na samostatném øádku.</p>

<p class="src1">In = fopen(&quot;Data\\shader.txt&quot;, &quot;r&quot;);<span class="kom">// Otevøení shader souboru</span></p>
<p></p>
<p class="src1">if (In)<span class="kom">// Kontrola, zda je soubor otevøen</span></p>
<p class="src1">{</p>
<p class="src2">for (i = 0; i &lt; 32; i++)<span class="kom">// Projde v¹ech 32 hodnot ve stupních ¹edi</span></p>
<p class="src2">{</p>
<p class="src3">if (feof(In))<span class="kom">// Kontrola konce souboru</span></p>
<p class="src4">break;</p>
<p></p>
<p class="src3">fgets(Line, 255, In);<span class="kom">// Získání aktuálního øádku</span></p>

<p>Pøemìníme naètené stupnì ¹edi na RGB, jak jsme si popsali vý¹e.</p>

<p class="src3"><span class="kom">// Zkopíruje danou hodnotu do v¹ech slo¾ek barvy</span></p>
<p class="src3">shaderData[i][0] = shaderData[i][1] = shaderData[i][2] = float(atof(Line));</p>
<p class="src2">}</p>
<p></p>
<p class="src2">fclose(In);<span class="kom">// Zavøe soubor</span></p>
<p class="src1">}</p>
<p class="src1">else</p>
<p class="src1">{</p>
<p class="src2">return FALSE;<span class="kom">// Neúspìch</span></p>
<p class="src1">}</p>

<p>Nahrajeme texturu pøesnì tak, jak je. Bez pou¾ití filtrování, jinak by výsledek vypadal opravdu hnusnì, pøinejmen¹ím. Pou¾ijeme GL_TEXTURE_1D, proto¾e jde o jednorozmìrné pole hodnot.</p>

<p class="src1">glGenTextures(1, &amp;shaderTexture[0]);<span class="kom">// Získání ID textury</span></p>
<p></p>
<p class="src1">glBindTexture(GL_TEXTURE_1D, shaderTexture[0]);<span class="kom">// Pøiøazení textury; od teï je 1D texturou</span></p>
<p></p>
<p class="src1"><span class="kom">// Nikdy nepou¾ívejte bi-/trilinearní filtrování!</span></p>
<p class="src1">glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</p>
<p class="src1">glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</p>
<p></p>
<p class="src1">glTexImage1D(GL_TEXTURE_1D, 0, GL_RGB, 32, 0, GL_RGB , GL_FLOAT, shaderData);<span class="kom">// Upload dat</span></p>

<p>Nastavíme smìr dopadání svìtla na objekt ze smìru kladné èásti osy z. Ve svém dùsledku to znamená, ¾e svìtlo bude zepøedu svítit na model.</p>

<p class="src1">lightAngle.X = 0.0f;<span class="kom">// Nastavení smìru x</span></p>
<p class="src1">lightAngle.Y = 0.0f;<span class="kom">// Nastavení smìru y</span></p>
<p class="src1">lightAngle.Z = 1.0f;<span class="kom">// Nastavení smìru z</span></p>
<p></p>
<p class="src1">Normalize(lightAngle);<span class="kom">// Normalizování vektoru svìtla</span></p>

<p>Naètení tvaru ze souboru (funkce popsána vý¹e).</p>

<p class="src1">return ReadMesh();<span class="kom">// Vrátí návratovou hodnotu funkce ReadMesh()</span></p>
<p class="src0">}</p>

<p>Funkce Deinitialize() je pravým opakem pøedchozí funkce. Sma¾e texturu a data polygonù nahraná pomocí funkcí Initialize() a ReadMesh().</p>

<p class="src0">void Deinitialize(void)<span class="kom">// Deinicializace</span></p>
<p class="src0">{</p>
<p class="src1">glDeleteTextures(1, &amp;shaderTexture[0]);<span class="kom">// Sma¾e shader texturu</span></p>
<p class="src1"></p>
<p class="src1">delete [] polyData;<span class="kom">// Uvolní data polygonù</span></p>
<p class="src0">}</p>

<p>Funkce Update() se periodicky volá v hlavní smyèce tohoto dema. Jedinou její funkcí je zpracování vstupu z klávesnice.</p>

<p class="src0">void Update(DWORD milliseconds)<span class="kom">// Aktualizace scény (objektu)</span></p>
<p class="src0">{</p>
<p class="src1">if (g_keys-&gt;keyDown [VK_ESCAPE] == TRUE)<span class="kom">// Klávesa ESC</span></p>
<p class="src1">{</p>
<p class="src2">TerminateApplication (g_window);<span class="kom">// Ukonèení programu</span></p>
<p class="src1">}</p>
<p></p>
<p class="src1">if (g_keys-&gt;keyDown [VK_F1] == TRUE)<span class="kom">// Klávesa F1</span></p>
<p class="src1">{</p>
<p class="src2">ToggleFullscreen(g_window);<span class="kom">// Pøepnutí módù fullscreen/okno</span></p>
<p class="src1">}</p>
<p></p>
<p class="src1">if (g_keys-&gt;keyDown [' '] == TRUE)<span class="kom">// Mezerník</span></p>
<p class="src1">{</p>
<p class="src2">modelRotate = !modelRotate;<span class="kom">// Zapne/vypne rotaci objektu</span></p>
<p></p>
<p class="src2">g_keys-&gt;keyDown [' '] = FALSE;</p>
<p class="src1">}</p>
<p></p>
<p class="src1">if (g_keys-&gt;keyDown ['1'] == TRUE)<span class="kom">// Klávesa èísla 1</span></p>
<p class="src1">{</p>
<p class="src2">outlineDraw = !outlineDraw;<span class="kom">// Zapne/vypne vykreslování obrysu</span></p>
<p></p>
<p class="src2">g_keys-&gt;keyDown ['1'] = FALSE;</p>
<p class="src1">}</p>
<p></p>
<p class="src1">if (g_keys-&gt;keyDown ['2'] == TRUE)<span class="kom">// Klávesa èíslo 2</span></p>
<p class="src1">{</p>
<p class="src2">outlineSmooth = !outlineSmooth;<span class="kom">// Zapne/vypne anti-aliasing</span></p>
<p></p>
<p class="src2">g_keys-&gt;keyDown ['2'] = FALSE;</p>
<p class="src1">}</p>
<p></p>
<p class="src1">if (g_keys-&gt;keyDown [VK_UP] == TRUE)<span class="kom">// ©ipka nahoru</span></p>
<p class="src1">{</p>
<p class="src2">outlineWidth++;<span class="kom">// Zvìt¹í tlou¹»ku èáry</span></p>
<p></p>
<p class="src2">g_keys-&gt;keyDown [VK_UP] = FALSE;</p>
<p class="src1">}</p>
<p></p>
<p class="src1">if (g_keys-&gt;keyDown [VK_DOWN] == TRUE)<span class="kom">// ©ipka dolù</span></p>
<p class="src1">{</p>
<p class="src2">outlineWidth--;<span class="kom">// Zmen¹í tlou¹»ku èáry</span></p>
<p></p>
<p class="src2">g_keys-&gt;keyDown [VK_DOWN] = FALSE;</p>
<p class="src1">}</p>
<p></p>
<p class="src1">if (modelRotate)<span class="kom">// Je rotace zapnutá</span></p>
<p class="src2">modelAngle += (float)(milliseconds) / 10.0f;<span class="kom">// Aktualizace úhlu natoèení v závislosti na FPS</span></p>
<p class="src0">}</p>

<p>Funkce, na kterou u¾ urèitì netrpìlivì èekáte. Draw() provádí vìt¹inu nejdùle¾itìj¹í práce v tomto tutoriálu - poèítá hodnoty stínu, renderuje daný tvar a renderuje obrys.</p>

<p class="src0">void Draw(void)<span class="kom">// Vykreslování</span></p>
<p class="src0">{</p>
<p class="src1">int i, j;<span class="kom">// Øídící promìnné cyklù</span></p>

<p>Promìnná TmpShade se pou¾ije na ulo¾ení doèasné hodnoty stínu pro aktuální vertex. V¹echna data týkajícího se jednoho vertexu jsou spoèítána ve stejném èase, co¾ znamená, ¾e mù¾eme pou¾ít jen jednu promìnnou, kterou postupnì pou¾ijeme pro v¹echny vertexy. Struktury TmpMatrix, TmpVector a TmpNormal jsou také pou¾ity pro spoèítání dat jednoho vertexu. TmpMatrix se nastaví v¾dy jednou pøi startu funkce Draw() a nezmìní se a¾ do jejího dal¹ího startu. TmpVector a TmpNormal se li¹í vertex od vertexu.</p>

<p class="src1">float TmpShade;<span class="kom">// Doèasná hodnota stínu</span></p>
<p></p>
<p class="src1">MATRIX TmpMatrix;<span class="kom">// Doèasná MATRIX struktura</span></p>
<p class="src1">VECTOR TmpVector, TmpNormal;<span class="kom">// Doèasné VECTOR struktury</span></p>

<p>Po deklaraci promìnných vyma¾eme buffery a data OpenGL matice.</p>

<p class="src1">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<span class="kom">// Vyma¾e buffery</span></p>
<p class="src1">glLoadIdentity();<span class="kom">// Reset matice</span></p>

<p>Nejdøíve zkontrolujeme zda chceme obrys vyhlazený. Kdy¾ ano, zapneme anti-aliasing. Kdy¾ ne, tak ho vypneme. Jak jednoduché...</p>

<p class="src1">if (outlineSmooth)<span class="kom">// Chce u¾ivatel vyhlazené èáry?</span></p>
<p class="src1">{</p>
<p class="src2">glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);<span class="kom">// Pou¾ije nejkvalitnìj¹í výpoèty</span></p>
<p class="src2">glEnable(GL_LINE_SMOOTH);<span class="kom">// Zapne anti-aliasing</span></p>
<p class="src1">}</p>
<p class="src1">else<span class="kom">// Nechce</span></p>
<p class="src1">{</p>
<p class="src2">glDisable(GL_LINE_SMOOTH);<span class="kom">// Vypne anti-aliasing</span></p>
<p class="src1">}</p>

<p>Posunutím kamery o 2 jednotky dozadu nastavíme pohled, potom model pootoèíme o daný úhel. Poznámka: proto¾e jsme nejdøíve pohnuli s kamerou, model se bude toèit na místì. Pokud bychom to udìlali opaènì, model by rotoval kolem kamery.</p>

<p class="src1">glTranslatef(0.0f, 0.0f, -2.0f);<span class="kom">// Posun do hloubky</span></p>
<p class="src1">glRotatef(modelAngle, 0.0f, 1.0f, 0.0f);<span class="kom">// Rotace objektem na ose y</span></p>

<p>Získáme novì vytvoøenou OpenGL matici a ulo¾íme ji do TmpMatrix.</p>

<p class="src1">glGetFloatv(GL_MODELVIEW_MATRIX, TmpMatrix.Data);<span class="kom">// Získání matice</span></p>

<p>Kouzla zaèínají... Povolíme 1D texturování a pou¾ijeme texturu stínu. Potom nastavíme barvu modelu. Vybral jsem bílou, proto¾e na ní jde lépe vidìt svìtlo a stín ne¾ na ostatních barvách. Nejménì vhodná je zcela urèitì èerná.</p>

<p class="src1"><span class="kom">// Kód Cel-Shadingu</span></p>
<p class="src1">glEnable(GL_TEXTURE_1D);<span class="kom">// Zapne 1D texturování</span></p>
<p class="src1">glBindTexture(GL_TEXTURE_1D, shaderTexture[0]);<span class="kom">// Zvolí texturu</span></p>
<p></p>
<p class="src1">glColor3f(1.0f, 1.0f, 1.0f);<span class="kom">// Nastavení barvy modelu (bílá)</span></p>

<p>Zaèneme s kreslením trojúhelníkù. Projdeme v¹echny polygony v poli a v¹echny vertexy ka¾dého z tìchto polygonù. Nejdøíve zkopírujeme normálu do doèasné struktury. Díky tomu mù¾eme hodnotami normály otáèet bez toho, ¾e bychom ztratili pùvodní data (bez prùbì¾né degradace).</p>

<p class="src1">glBegin(GL_TRIANGLES);<span class="kom">// Zaèátek kreslení trojúhelníkù</span></p>
<p></p>
<p class="src2">for (i = 0; i &lt; polyNum; i++)<span class="kom">// Prochází jednotlivé polygony</span></p>
<p class="src2">{</p>
<p class="src3">for (j = 0; j &lt; 3; j++)<span class="kom">// Prochází jednotlivé vertexy</span></p>
<p class="src3">{</p>
<p class="src4"><span class="kom">// Zkopírování aktuální normály do doèasné struktury</span></p>
<p class="src4">TmpNormal.X = polyData[i].Verts[j].Nor.X;</p>
<p class="src4">TmpNormal.Y = polyData[i].Verts[j].Nor.Y;</p>
<p class="src4">TmpNormal.Z = polyData[i].Verts[j].Nor.Z;</p>

<p>Otoèíme vektor o matici, kterou jsme získali od OpenGL a normalizujeme ho.</p>

<p class="src4">RotateVector(TmpMatrix, TmpNormal, TmpVector);<span class="kom">// Otoèí vektor podle matice</span></p>
<p></p>
<p class="src4">Normalize(TmpVector);<span class="kom">// Normalizace normály</span></p>

<p>Spoèítáme odchylku pootoèené normály a smìru svìtla. Potom hodnotu dáme do rozmezí 0-1 (z pùvodního -1 a¾ 1).</p>

<p class="src4">TmpShade = DotProduct(TmpVector, lightAngle);<span class="kom">// Spoèítání hodnoty stínu</span></p>
<p></p>
<p class="src4">if (TmpShade &lt; 0.0f)<span class="kom">// Pokud je TmpShade men¹í ne¾ nula bude se rovnat nule</span></p>
<p class="src5">TmpShade = 0.0f;</p>

<p>Pøedáme tuto hodnotu OpenGL jako texturovací souøadnici. Potom pøedáme pozici vertexu a opakujeme. A opakujeme. A opakujeme. Myslím, ¾e podstatu u¾ chápete.</p>

<p class="src4">glTexCoord1f(TmpShade);<span class="kom">// Nastavení texturovací souøadnice na hodnotu stínu</span></p>
<p class="src4">glVertex3fv(&amp;polyData[i].Verts[j].Pos.X);<span class="kom">// Po¹le pozici vertexu</span></p>
<p class="src3">}</p>
<p class="src2">}</p>
<p></p>
<p class="src1">glEnd();<span class="kom">// Konec kreslení</span></p>
<p></p>
<p class="src1">glDisable(GL_TEXTURE_1D);<span class="kom">// Vypne 1D texturování</span></p>

<p>Pøesuneme se k obrysùm. Obrys mù¾eme definovat jako hranu, kde je jeden polygon pøivrácen smìrem k nám a druhý od nás. Pou¾ijeme pro OpenGL bì¾né testování hloubky - ménì nebo stejnì (GL_LEQUAL) a také nastavíme vyøazování v¹ech polygonù otoèených k nám. Také pou¾ijeme blending, aby to trochu vypadalo.</p>

<p>Nastavíme OpenGL tak, aby polygony èelem od nás vyrenderoval jako èáry. Vyøadíme v¹echny polygony èelem k nám a nastavíme testování hloubky na men¹í nebo stejné na aktuální ose Z. Potom je¹tì nastavíme barvu èar, projdeme v¹echny polygony a vykreslíme jejich rohy. Staèí zadat pozici. Nemusíme zadávat normálu a stíny, proto¾e chceme jenom obrys.</p>

<p class="src1"><span class="kom">// Kód pro vykreslení obrysù</span></p>
<p class="src1">if (outlineDraw)<span class="kom">// Chceme vùbec kreslit obrys?</span></p>
<p class="src1">{</p>
<p class="src2">glEnable(GL_BLEND);<span class="kom">// Zapne blending</span></p>
<p class="src2">glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);<span class="kom">// Mód blendingu</span></p>
<p></p>
<p class="src2">glPolygonMode(GL_BACK, GL_LINE);<span class="kom">// Odvrácené polygony se stanout pouze obrysovými èarami</span></p>
<p class="src2">glLineWidth(outlineWidth);<span class="kom">// Nastavení ¹íøky èáry</span></p>
<p></p>
<p class="src2">glCullFace(GL_FRONT);<span class="kom">// Nerenderovat pøivrácené polygony</span></p>
<p class="src2">glDepthFunc(GL_LEQUAL);<span class="kom">// Mód testování hloubky</span></p>
<p></p>
<p class="src2">glColor3fv(&amp;outlineColor[0]);<span class="kom">// Barva obrysu (èerná)</span></p>
<p></p>
<p class="src2">glBegin(GL_TRIANGLES);<span class="kom">// Zaèátek kreslení trojúhelníkù</span></p>
<p></p>
<p class="src3">for (i = 0; i &lt; polyNum; i++)<span class="kom">// Prochází jednotlivé polygony</span></p>
<p class="src3">{</p>
<p class="src4">for (j = 0; j &lt; 3; j++)<span class="kom">// Prochází jednotlivé vertexy</span></p>
<p class="src4">{</p>
<p class="src5">glVertex3fv(&amp;polyData[i].Verts[j].Pos.X);<span class="kom">// Po¹le pozici vertexu</span></p>
<p class="src4">}</p>
<p class="src3">}</p>
<p></p>
<p class="src2">glEnd();<span class="kom">// Konec kreslení</span></p>

<p>Na konci u¾ jenom vrátíme nastavení do pùvodního stavu a ukonèíme funkci i tutoriál.</p>

<p class="src2">glDepthFunc(GL_LESS);<span class="kom">// Testování hloubky na pùvodní nastavení</span></p>
<p class="src2"></p>
<p class="src2">glCullFace(GL_BACK);<span class="kom">// Nastavení oøezávání na pùvodní hodnotu</span></p>
<p class="src2">glPolygonMode(GL_BACK, GL_FILL);<span class="kom">// Normální vykreslování</span></p>
<p class="src2"></p>
<p class="src2">glDisable(GL_BLEND);<span class="kom">// Vypne blending</span></p>
<p class="src1">}</p>
<p class="src0">}</p>

<p class="autor">napsal: Sami &quot;MENTAL&quot; Hamlaoui <span class="transform_email">&lt;disk_disaster (zavináè) hotmail.com&gt;</span><br />
teoretickou èást pøelo¾il: Michal Turek - Woq <span class="transform_email">&lt;WOQ (zavináè) seznam.cz&gt;</span><br />
praktickou èást pøelo¾il: Václav Slováèek - Wessan <span class="transform_email">&lt;horizont (zavináè) host.sk&gt;</span></p>

<h3 class="zdroj_kody_nadpis">Zdrojové kódy</h3>

<ul class="zdroj_kody">
<li><a href="http://nehe.gamedev.net/data/lessons/vc/lesson37.zip">Visual C++</a> kód této lekce.</li>
<li><a href="http://nehe.gamedev.net/data/lessons/bcb6/lesson37_bcb6.zip">Borland C++ Builder 6</a> kód této lekce. ( <a href="mailto:christian@tugzip.com">Christian Kindahl</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/cwarrior/lesson37.zip">Code Warrior 5.3</a> kód této lekce. ( <a href="mailto:DelusionalBeing@hotmail.com">Scott Lupton</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/delphi/lesson37.zip">Delphi</a> kód této lekce. ( <a href="mailto:webmaster@joachimrohde.de">Joachim Rohde</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/devc/lesson37.zip">Dev C++</a> kód této lekce. ( <a href="mailto:zealouselixir@mchsi.com">Warren Moore</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/euphoria/lesson37.zip">Euphoria</a> kód této lekce. ( <a href="mailto:1evan@sbcglobal.net">Evan Marshall</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/jogl/lesson37.jar">JoGL</a> kód této lekce. ( <a href="mailto:abezrati@hotmail.com">Abdul Bezrati</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/linux/lesson37.tar.gz">Linux / GLut</a> kód této lekce. ( <a href="mailto:rainmaker@xs4all.nl">Kah</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/linuxglx/lesson37.tar.gz">Linux/GLX</a> kód této lekce. ( <a href="mailto:Schubert_P@Yahoo.de">Patrick Schubert</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/linuxsdl/lesson37.tar.gz">Linux/SDL</a> kód této lekce. ( <a href="mailto:drfnbee@wanadoo.fr">Sean Farrell</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/macosxcocoa/lesson37.zip">Mac OS X/Cocoa</a> kód této lekce. ( <a href="mailto:blb@pobox.com">Bryan Blackburn</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/vs_net/lesson37.zip">Visual Studio .NET</a> kód této lekce. ( <a href="mailto:ultimatezeus@hotmail.com">Grant James</a> )</li>
</ul>

<div class="okolo_img"><img src="images/nehe_tut/tut_37_big.jpg" class="nehe_velky" alt="Lekce 37" /></div>
<p class="okolni_lekce"><a href="tut_36.php">&lt;&lt;&lt; Lekce 36</a> | <a href="tut_38.php">Lekce 38 &gt;&gt;&gt;</a></p>


<div class="netisk">
<h3 class="d_nadpis">Diskuze ke èlánku</h3>

®ádné pøíspìvky...<form action="d_view.php" method="post" class="d_o_obsah">
<div class="okolo_img" style="margin-top: 20px;">
<input type="submit" name="vlozit_novy" id="vlozit_novy" value="Vlo¾it nový" class="tlacitko" />
<input type="hidden" name="f" id="f" value="tut_37.php" />
</div>
</form>
</div>
<!-- Informace o webu -->
<center><div id="informace">
<img src="images/my/woq.gif" width="60" height="60" align="left" alt="Woq logo" />
<div style="margin-left: 70px">
<div><strong>CZ NeHe OpenGL, v¹e o programování 3D grafiky</strong></div>
<div>Copyright &copy; 2002-2007 Michal Turek <span class="transform_email">&lt;WOQ (zavináè) seznam.cz&gt;</span></div>
<div style="margin-top: 5px">Komerèní publikování v ti¹tìné, elektronické nebo jiné podobì je bez výslovného souhlasu zakázáno. Redistribuce pro výukové úèely nebo osobní pou¾ití je v¹ak povolena.</div>
</div>
</div></center>
<!-- Informace o webu (konec) -->

</div>
<!-- Vlastní obsah stránky (konec) -->

<script src="http://c1.navrcholu.cz/code?site=56575;t=b14"
type="text/javascript"></script><noscript><div><a
href="http://navrcholu.cz/"><img
src="http://c1.navrcholu.cz/hit?site=56575;t=b14;ref=;jss=0"
width="14" height="14" alt="NAVRCHOLU.cz"
style="border:none" /></a></div></noscript>

</body>
</html>
