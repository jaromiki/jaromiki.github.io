<?xml version="1.0" encoding="ISO-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">
<head>

<meta http-equiv="content-type" content="text/html; charset=ISO-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta http-equiv="content-script-type" content="text/javascript" />
<meta http-equiv="content-style-type" content="text/css" />

<meta name="robots" content="all, follow" />
<meta name="resource-type" content="document" />

<meta name="description" content="NeHe OpenGL Tutoriály v èe¹tinì, programování 3D grafiky, èlánky, programy se zdrojovými kódy..." />
<meta name="keywords" content="opengl, nehe, tutoriály, woq, programování, 3D" />
<meta name="author" content="all: Michal Turek - Woq; woq (zavináè) seznam.cz" />
<meta name="copyright" content="Copyright (c) 2002, 2003, 2004 Michal Turek - Woq" />

<title>CZ NeHe OpenGL - Lekce 32 - Picking, alfa blending, alfa testing, sorting</title>

<link rel="shortcut icon" href="skin/default/web.ico" type="image/x-icon" />
<link href="skin/default.css" rel="stylesheet" type="text/css" media="all" />
<link href="skin/print.css" rel="stylesheet" type="text/css" media="print" />

</head>

<body>

<!-- Levý sloupec -->
<div class="levy">
<div id="main_menu">
<a href="http://nehe.ceske-hry.cz/"><img src="skin/default/web_logo.gif" width="135" height="135" style="margin-left: 5px;" alt="CZ NeHe OpenGL" /></a>

<div class="main_menu_bez_loga">

<ul class="text_main_menu">
<li><a href="my.php" title="Pøekladatelé NeHe Tutoriálù a autoøi èlánkù">My</a></li>
<li><a href="novinky.php" title="Co je nového">Novinky</a></li>
<li><a href="navigacni_mapa.php" title="Pøehledná navigace na jednotlivé stránky, které dohromady tvoøí tento web">Navigaèní mapa</a></li>
<li><a href="kontakt.php" title="Kontakt na správce tohoto webu">Kontakt</a></li>
<li><a href="http://forum.programovani.com/" title="Diskusní fórum">Fórum</a></li>
</ul>

<ul class="text_main_menu">
<li><a href="clanky.php" title="Obsah èlánkù">Èlánky</a></li>
<li><a href="tut_obsah.php" title="Obsah NeHe OpenGL Tutoriálù">NeHe Tutoriály</a></li>
<li><a href="33D_index.php" title="Obsah Free3D (33D) Basecode">33D Basecode</a></li>
<li><a href="programy.php" title="Programy od èeských autorù">Èeské programy</a></li>
<li><a href="cl_gl_zacinam.php" title="Kde zaèít pøi uèení OpenGL">Pomoc, zaèínám</a></li>
<li><a href="odkazy.php" title="Jiné zdroje informací">Odkazy</a></li>
<li><a href="cl_gl_faq.php" title="FAQ: Èasto kladené dotazy">FAQ</a></li>
</ul>

<ul class="text_main_menu">
<li><a href="spoluprace.php" title="Nechcete se podílet na tvorbì tìchto webových stránek?">Spolupráce...?</a></li>
<li><a href="download.php" title="Stahujte">Download</a></li>
<li><a href="skiny.php" title="Nastavte si jiný layout a design stránek">Skiny</a></li>
<li><a href="javascript:window.print();" title="Vytiskne tuto stránku">Tisk</a></li>
</ul>

<ul class="text_main_menu">
<li>
<form action="p_fulltext.php" method="post" onsubmit="if(!this.najit.value || this.najit.value=='výraz ...') { alert('Byl zadán prázdný øetìzec!'); this.najit.focus(); return false; }">
<input type="text" name="najit" size="12" value="výraz ..." onclick="this.value=''" /><br />
<input type="submit" value="Najít" />
</form>
</li>
</ul>

<ul class="text_main_menu">
<li>Online ètenáøù: 2</li>
</ul>

</div>

</div>
</div>
<!-- Levý sloupec (konec) -->

<!-- Pravý sloupec -->
<div class="pravy">
<div id="tut_menu">

<ul class="text_tut_menu">
<li class="li_tut"><a href="tut_00.php" title="Lekce 0 - Pøedmluva k NeHe Tutoriálùm">00</a></li>
<li class="li_tut"><a href="tut_01.php" title="Lekce 1 - Vytvoøení OpenGL okna ve Windows">01</a></li>
<li class="li_tut"><a href="tut_02.php" title="Lekce 2 - Vytváøení trojúhelníkù a ètyøúhelníkù">02</a></li>
<li class="li_tut"><a href="tut_03.php" title="Lekce 3 - Barvy">03</a></li>
<li class="li_tut"><a href="tut_04.php" title="Lekce 4 - Rotace">04</a></li>
<li class="li_tut"><a href="tut_05.php" title="Lekce 5 - Pevné objekty">05</a></li>
<li class="li_tut"><a href="tut_06.php" title="Lekce 6 - Textury">06</a></li>
<li class="li_tut"><a href="tut_07.php" title="Lekce 7 - Texturové filtry, osvìtlení, ovládání pomocí klávesnice">07</a></li>
<li class="li_tut"><a href="tut_08.php" title="Lekce 8 - Blending">08</a></li>
<li class="li_tut"><a href="tut_09.php" title="Lekce 9 - Pohyb bitmap ve 3D prostoru">09</a></li>
<li class="li_tut"><a href="tut_10.php" title="Lekce 10 - Vytvoøení 3D svìta a pohyb v nìm">10</a></li>
<li class="li_tut"><a href="tut_11.php" title="Lekce 11 - Efekt vlnící se vlajky">11</a></li>
<li class="li_tut"><a href="tut_12.php" title="Lekce 12 - Display list">12</a></li>
<li class="li_tut"><a href="tut_13.php" title="Lekce 13 - Bitmapové fonty">13</a></li>
<li class="li_tut"><a href="tut_14.php" title="Lekce 14 - Outline fonty">14</a></li>
<li class="li_tut"><a href="tut_15.php" title="Lekce 15 - Mapování textur na fonty">15</a></li>
<li class="li_tut"><a href="tut_16.php" title="Lekce 16 - Mlha">16</a></li>
<li class="li_tut"><a href="tut_17.php" title="Lekce 17 - 2D fonty z textur">17</a></li>
<li class="li_tut"><a href="tut_18.php" title="Lekce 18 - Kvadriky">18</a></li>
<li class="li_tut"><a href="tut_19.php" title="Lekce 19 - Èásticové systémy">19</a></li>
<li class="li_tut"><a href="tut_20.php" title="Lekce 20 - Maskování">20</a></li>
<li class="li_tut"><a href="tut_21.php" title="Lekce 21 - Pøímky, antialiasing, èasování, pravoúhlá projekce, základní zvuky a jednoduchá herní logika">21</a></li>
<li class="li_tut"><a href="tut_22.php" title="Lekce 22 - Bump Mapping &amp; Multi Texturing">22</a></li>
<li class="li_tut"><a href="tut_23.php" title="Lekce 23 - Mapování textur na kulové kvadriky">23</a></li>
<li class="li_tut"><a href="tut_24.php" title="Lekce 24 - Výpis OpenGL roz¹íøení, oøezávací testy a textury z TGA obrázkù">24</a></li>
<li class="li_tut"><a href="tut_25.php" title="Lekce 25 - Morfování objektù a jejich nahrávání z textového souboru">25</a></li>
<li class="li_tut"><a href="tut_26.php" title="Lekce 26 - Odrazy a jejich oøezávání za pou¾ití stencil bufferu">26</a></li>
<li class="li_tut"><a href="tut_27.php" title="Lekce 27 - Stíny">27</a></li>
<li class="li_tut"><a href="tut_28.php" title="Lekce 28 - Bezierovy køivky a povrchy, fullscreen fix">28</a></li>
<li class="li_tut"><a href="tut_29.php" title="Lekce 29 - Blitter, nahrávání .RAW textur">29</a></li>
<li class="li_tut"><a href="tut_30.php" title="Lekce 30 - Detekce kolizí">30</a></li>
<li class="li_tut"><a href="tut_31.php" title="Lekce 31 - Nahrávání a renderování modelù">31</a></li>
<li class="li_tut"><a href="tut_32.php" title="Lekce 32 - Picking, alfa blending, alfa testing, sorting">32</a></li>
<li class="li_tut"><a href="tut_33.php" title="Lekce 33 - Nahrávání komprimovaných i nekomprimovaných obrázkù TGA">33</a></li>
<li class="li_tut"><a href="tut_34.php" title="Lekce 34 - Generování terénù a krajin za pou¾ití vý¹kového mapování textur">34</a></li>
<li class="li_tut"><a href="tut_35.php" title="Lekce 35 - Pøehrávání videa ve formátu AVI">35</a></li>
<li class="li_tut"><a href="tut_36.php" title="Lekce 36 - Radial Blur, renderování do textury">36</a></li>
<li class="li_tut"><a href="tut_37.php" title="Lekce 37 - Cel-Shading">37</a></li>
<li class="li_tut"><a href="tut_38.php" title="Lekce 38 - Nahrávání textur z resource souboru &amp; texturování trojúhelníkù">38</a></li>
<li class="li_tut"><a href="tut_39.php" title="Lekce 39 - Úvod do fyzikálních simulací">39</a></li>
<li class="li_tut"><a href="tut_40.php" title="Lekce 40 - Fyzikální simulace lana">40</a></li>
<li class="li_tut"><a href="tut_41.php" title="Lekce 41 - Volumetrická mlha a nahrávání obrázkù pomocí IPicture">41</a></li>
<li class="li_tut"><a href="tut_42.php" title="Lekce 42 - Více viewportù">42</a></li>
<li class="li_tut"><a href="tut_43.php" title="Lekce 43 - FreeType Fonty v OpenGL">43</a></li>
<li class="li_tut"><a href="tut_44.php" title="Lekce 44 - Èoèkové efekty">44</a></li>
<li class="li_tut"><a href="tut_45.php" title="Lekce 45 - Vertex Buffer Object (VBO)">45</a></li>
<li class="li_tut"><a href="tut_46.php" title="Lekce 46 - Fullscreenový antialiasing">46</a></li>
<li class="li_tut"><a href="tut_47.php" title="Lekce 47 - CG vertex shader">47</a></li>
<li class="li_tut"><a href="tut_48.php" title="Lekce 48 - ArcBall rotace">48</a></li>
</ul>

</div>
</div>
<!-- Pravý sloupec (konec) -->

<!-- Vlastní obsah stránky -->
<div class="stred">

<!--[if IE ]>
<div style="text-align: center;">
<a href="http://firefox.czilla.cz/"><img alt="Mozilla Firefox: Objevte znovu web" title="Mozilla Firefox: Objevte znovu web" style="border:none; width:468px;height:60px" src="http://firefox.czilla.cz/img/p/cz-ff-468x60-w-objevte.png" /></a>
</div>
<![endif]-->

<img src="images/nehe_tut/tut_32.jpg" class="nehe_maly" alt="Lekce 32" />

<h1>Lekce 32 - Picking, alfa blending, alfa testing, sorting</h1>

<p class="nadpis_clanku">V tomto tutoriálu se pokusím zodpovìdìt nìkolik otázek, na které jsem dennì dotazován. Chcete vìdìt, jak pøi kliknutí tlaèítkem my¹i identifikovat OpenGL objekt nacházející se pod kurzorem (picking). Dále byste se chtìli dozvìdìt, jak vykreslit objekt bez zobrazení urèité barvy (alfa blending, alfa testing). Tøetí vìcí, se kterou si nevíte rady, je, jak øadit objekty, aby se pøi blendingu správnì zobrazily (sorting). Naprogramujeme hru, na které si v¹e vysvìtlíme.</p>

<p>Vítejte do 32. lekce. Je asi nejdel¹í, jakou jsem kdy napsal - pøes 1000 øádkù kódu a více ne¾ 1500 øádkù HTML. Také je prvním, který pou¾ívá nový NeHeGL základní kód. Tutoriál zabral hodnì èasu, ale myslím si, ¾e stojí za to. Probírá se v nìm pøedev¹ím: alfa blending, alfa testing, ètení zpráv my¹i, souèasné pou¾ívání perspektivní i pravoúhlé projekce, zobrazování kurzoru my¹i pomocí OpenGL, ruèní øazení objektù podle hloubky, snímky animace z jedné textury a to nejdùle¾itìj¹í: nauèíte se v¹e o pickingu.</p>

<p>V první verzi program zobrazoval tøi polygony, které po kliknutí mìnily barvu. Jak vzru¹ující! Tak, jako v¾dycky, chci zapùsobit super cool tutoriálem. Nejen, ¾e jsou v nìm zahrnuty v¹echny informace k probíranému tématu, ale samozøejmì musí být také hezký na pohled. Dokonce i tehdy, pokud neprogramujete, vás mù¾e zaujmout - kompletní hra. Objekty se sestøelují tak dlouho, dokud vám neochabne ruka dr¾ící my¹, tak¾e u¾ nejste schopni stisknout tlaèítko.</p>

<p>Poznámka ohlednì kódu: Budu vysvìtlovat pouze lesson33.cpp. V NeHeGL jsou zmìny pøedev¹ím v podpoøe my¹i ve funkci WindowProc(). Také u¾ nebudu vysvìtlovat loading textur, vytváøení display listù fontu a výstup textu. V¹e bylo vysvìtleno v minulých tutoriálech.</p>

<p>Textury, pou¾ívané v tomto programu, byly nakresleny v Adobe Photoshopu. Ka¾dý z .TGA obrázkù má barevnou hloubku 32 bitù na pixel, obsahuje tedy alfa kanál. Pokud si nejste jistí, jak ho pøidat, kupte si nìjakou knihu, prozkoumejte internet nebo zkuste help. Postup je podobný vytváøení masky v tutoriálu o maskingu, nahrajte svùj obrázek do Adobe Photoshopu nebo jakéhokoli grafického editoru s podporou alfa kanálu. Proveïte výbìr barvy, abyste oznaèili oblast okolo objektu, zkopírujte výbìr a vlo¾te ho do nového obrázku. Negujte obrázek, tak¾e oblast, kde by mìl být, bude èerná. Zmìòte okolí na bílé, vyberte celý obrázek a zkopírujte ho. Vra»te se na originál a vytvoøte alfa kanál, do kterého vlo¾te masku. Ulo¾te obrázek jako 32 bitový .TGA soubor. Ujistìte se, ¾e je za¹krtnuto Uchovat prùhlednost a ukládejte bez komprese.</p>

<p>Zjistíme, jestli je definovaná symbolická konstanta CDS_FULLSCREEN a pokud ne, nadefinujeme ji na hodnotu 4. Pro ty z vás, kteøí se úplnì ztratili... nìkteré kompilátory nepøiøazují CDS_FULLSCREEN hodnotu. Pokud ji pak v programu pou¾ijeme, kompilace skonèí s chybovou zprávou. Abychom tomuto pøede¹li, tak ji v pøípadì potøeby nadefinujeme ruènì.</p>

<p class="src0">#ifndef CDS_FULLSCREEN<span class="kom">// Nìkteré kompilátory nedefinují CDS_FULLSCREEN</span></p>
<p class="src1">#define CDS_FULLSCREEN 4<span class="kom">// Ruèní nadefinování</span></p>
<p class="src0">#endif</p>

<p>Deklarujeme funkci DrawTargets(), potom promìnnou okna a kláves.</p>

<p class="src0">void DrawTargets();<span class="kom">// Deklarace funkce</span></p>
<p></p>
<p class="src0">GL_Window* g_window;<span class="kom">// Okno</span></p>
<p class="src0">Keys* g_keys;<span class="kom">// Klávesy</span></p>

<p>Ka¾dý program potøebuje promìnné. Base ukládá display listy fontu, roll slou¾í k pohybu zemì a rolování mrakù. Jako ve v¹ech hrách i my zaèínáme prvním levelem. Miss vede záznam, do kolika objektù se v daném levelu støelec nestrefil, kill je jeho pravý opak. Score zahrnuje souèty zasa¾ených objektù z jednotlivých levelù. Game signalizuje konec hry.</p>

<p class="src0">GLuint base;<span class="kom">// Display listy fontu</span></p>
<p class="src0">GLfloat roll;<span class="kom">// Rolování mrakù</span></p>
<p></p>
<p class="src0">GLint level = 1;<span class="kom">// Aktuální level</span></p>
<p class="src0">GLint miss;<span class="kom">// Poèet nesestøelených objektù</span></p>
<p class="src0">GLint kills;<span class="kom">// Poèet sestøelených objektù v daném levelu</span></p>
<p class="src0">GLint score;<span class="kom">// Aktuální skóre</span></p>
<p></p>
<p class="src0">bool game;<span class="kom">// Konec hry?</span></p>

<p>Nadefinujeme nový datový typ, díky kterému budeme moci pøedat struktury porovnávací funkci. Qsort() toti¾ oèekává v posledním parametru ukazatel na funkci s parametry (const* void, const* void).</p>

<p class="src0">typedef int (*compfn)(const void*, const void*);<span class="kom">// Ukazatel na porovnávací funkci</span></p>

<p>Struktura objects bude ukládat v¹echny informace popisující sestøelovaný objekt. Rychlý prùzkum promìnných: rot urèuje smìr rotace na ose z. Pokud je¹tì nebyl objekt sestøelen, hit bude obsahovat false. Frame definuje snímek animace pøi explozi, dir urèuje smìr pohybu. Texid je indexem do pole textur, nabývá hodnot nula a¾ ètyøi, z èeho¾ plyne, ¾e máme celkem pìt druhù objektù. X a y definuje aktuální pozici, spin úhel rotace na ose z. Distance je hodnì dùle¾itá promìnná, urèuje hloubku ve scénì. Právì podle ní budeme pøi blendingu øadit objekty, aby se nejdøíve vykreslovali vzdálenìj¹í a a¾ po nich bli¾¹í.</p>

<p class="src0">struct objects<span class="kom">// Struktura objektu</span></p>
<p class="src0">{</p>
<p class="src1">GLuint rot;<span class="kom">// Rotace (0 - ¾ádná, 1 - po smìru hodinových ruèièek, 2 - proti smìru)</span></p>
<p class="src1">bool hit;<span class="kom">// Byl objekt zasa¾en?</span></p>
<p></p>
<p class="src1">GLuint frame;<span class="kom">// Aktuální snímek exploze</span></p>
<p class="src1">GLuint dir;<span class="kom">// Smìr pohybu (0 - vlevo, 1 - vpravo, 2 - nahoru, 3 - dolù)</span></p>
<p class="src1">GLuint texid;<span class="kom">// Index do pole textur</span></p>
<p></p>
<p class="src1">GLfloat x;<span class="kom">// X pozice</span></p>
<p class="src1">GLfloat y;<span class="kom">// Y pozice</span></p>
<p class="src1">GLfloat spin;<span class="kom">// Smìr rotace na ose z</span></p>
<p class="src1">GLfloat distance;<span class="kom">// Hloubka ve scénì</span></p>
<p class="src0">};</p>

<p>Následující pole vedou záznamy o deseti texturách a tøiceti objektech.</p>

<p class="src0">TextureImage textures[10];<span class="kom">// Deset textur</span></p>
<p class="src0">objects object[30];<span class="kom">// 30 Objektù</span></p>

<p>Nebudeme limitovat velikost objektù. Váza by mìla být vy¹¹í ne¾ plechovka coly a kýbl naopak ¹ir¹í ne¾ váza. Abychom si ulehèili ¾ivot, vytvoøíme strukturu obsahující vý¹ku a ¹íøku. Definujeme a ihned inicializujeme pole tìchto struktur o pìti prvcích. Na ka¾dém indexu se nachází jeden z pìti typù objektù.</p>

<p class="src0">struct dimensions<span class="kom">// Rozmìr objektu</span></p>
<p class="src0">{</p>
<p class="src1">GLfloat w;<span class="kom">// ©íøka</span></p>
<p class="src1">GLfloat h;<span class="kom">// Vý¹ka</span></p>
<p class="src0">};</p>
<p></p>
<p class="src0"><span class="kom">// Velikost ka¾dého objektu: Modrá tváø, kýbl, terè, Coca-cola, Váza</span></p>
<p class="src0">dimensions size[5] = {{1.0f,1.0f}, {1.0f,1.0f}, {1.0f,1.0f}, {0.5f,1.0f}, {0.75f,1.5f}};</p>

<p>Tento kód bude volán funkcí qsort(). Porovnává hloubku dvou objektù ve scénì a vrací -1, pokud je první objekt dále, bude-li ale vzdálenìj¹í druhý objekt vrátí funkce 1. Získáme-li 0, znamená to, ¾e jsou oba ve stejné vzdálenosti od pozorovatele.</p>

<p class="src0"><span class="kom">// *** Modifikovaný MSDN kód pro tento tutoriál ***</span></p>
<p class="src0">int Compare(struct objects *elem1, struct objects *elem2)<span class="kom">// Porovnávací funkce</span></p>
<p class="src0">{</p>
<p class="src1">if (elem1-&gt;distance &lt; elem2-&gt;distance)<span class="kom">// První je vzdálenìj¹í</span></p>
<p class="src1">{</p>
<p class="src2">return -1;</p>
<p class="src1">}</p>
<p class="src1">else if (elem1-&gt;distance &gt; elem2-&gt;distance)<span class="kom">// První je bli¾¹í</span></p>
<p class="src1">{</p>
<p class="src2">return 1;</p>
<p class="src1">}</p>
<p class="src1">else<span class="kom">// Vzdálenosti jsou stejné</span></p>
<p class="src1">{</p>
<p class="src2">return 0;</p>
<p class="src1">}</p>
<p class="src0">}</p>

<p>Ve funkci InitObject() nastavujeme objekt na výchozí hodnoty. Pøiøadíme mu rotaci po smìru hodinových ruèièek. Animace exploze samozøejmì zaèíná na prvním (nultém) snímku. Objekt je¹tì nebyl zasa¾en, tak¾e nastavíme hit na false. Randomem zvolíme jednu z pìti dostupných textur.</p>

<p class="src0">GLvoid InitObject(int num)<span class="kom">// Inicializace objektu</span></p>
<p class="src0">{</p>
<p class="src1">object[num].rot = 1;<span class="kom">// Rotace po smìru hodinových ruèièek</span></p>
<p class="src1">object[num].frame = 0;<span class="kom">// První snímek exploze</span></p>
<p class="src1">object[num].hit = FALSE;<span class="kom">// Je¹tì nebyl zasa¾en</span></p>
<p class="src1">object[num].texid = rand() % 5;<span class="kom">// Náhodný index textury</span></p>

<p>Vzdálenost od pozorovatele nastavíme opìt náhodnì na hodnotu 0.0f a¾ -40.0f (4000/100 = 40). Pøed renderingem objektu v¹ak scénu je¹tì posouváme do hloubky o dal¹ích deset jednotek, tak¾e se objekt defakto zobrazí v rozmezí od -10.0f do -50.0f. Ani pøíli¹ blízko ani pøíli¹ daleko.</p>

<p class="src1">object[num].distance = -(float(rand() % 4001) / 100.0f);<span class="kom">// Náhodná hloubka</span></p>

<p>Po definování hloubky urèíme vý¹ku nad zemí. Nechceme, aby se objekt nacházel ní¾e ne¾ -1.5f, proto¾e by byl pod zemí. Také by nemìl být vý¹e ne¾ 3.0f. Abychom zùstali v tomto rozmezí, výsledek randomu nesmí být vy¹¹í ne¾ 4.5f (-1.5f + 4.5f = 3.0f).</p>

<p class="src1">object[num].y = -1.5f + (float(rand() % 451) / 100.0f);<span class="kom">// Náhodná y pozice</span></p>

<p>Výpoèet poèáteèní x pozice je malièko slo¾itìj¹í. Vezmeme pozici objektu v hloubce a odeèteme od ní 15.0f. Výsledek operace vydìlíme dvìma a odeèteme od nìj 5*level. Následuje dal¹í odèítání. Tentokrát odeèteme náhodné èíslo od 0 do 5 násobené aktuálním levelem. Pøedpokládám, ¾e nechápete :-). Objekty se nyní ve vy¹¹ích levelech zobrazují dále od viditelné èásti scény (vlevo nebo vpravo). Kdybychom toto neudìlali, zobrazovaly by se rychle jeden za druhým, tak¾e by bylo velmi obtí¾né v¹echny zasáhnout a dostat se tak do dal¹ího levelu.</p>

<p>Abyste lépe pochopili urèování x pozice, uvedu pøíklad. Øeknìme, ¾e se objekt nachází -30.0f jednotek hluboko ve scénì a aktuální level je 1.</p>

<p class="src0"><span class="kom">object[num].x = ((-30.0f - 15.0f) / 2.0f) - (5*1) - float(rand() % (5*1));</span></p>
<p class="src0"><span class="kom">object[num].x = (-45.0f / 2.0f) - 5 - float(rand() % 5);</span></p>
<p class="src0"><span class="kom">object[num].x = (-22.5f) - 5 - { øeknìme 3.0f };</span></p>
<p class="src0"><span class="kom">object[num].x = (-22.5f) - 5 - { 3.0f };</span></p>
<p class="src0"><span class="kom">object[num].x = -27.5f - { 3.0f };</span></p>
<p class="src0"><span class="kom">object[num].x = -30.5f;</span></p>

<p>Pøed renderingem objektu provádíme translaci o deset jednotek do scény na ose z a hloubka v na¹em pøíkladu je -30.0f. Celková hloubka ve scénì je tedy -40.0f. Pou¾íváním perspektivního kódu z NeHeGL mù¾eme pøedpokládat, ¾e levý okraj viditelné scény je -20.0f a pravý okraj se nachází na +20.0f. Pøed odeèítáním randomù se rovná x-ová pozice -22.5f, co¾ je PRÁVÌ okraj viditelné scény. Po tìchto operacích to u¾ je ale -30.0f a to znamená, ¾e ne¾ se poprvé objeví, musí nejdøíve urazit celých 8 jednotek doprava. U¾ je to jasnìj¹í?</p>

<p class="src1"><span class="kom">// Náhodná x pozice zalo¾ená na hloubce v obrazovce a s náhodným zpo¾dìním pøed vstupem na scénu</span></p>
<p class="src1">object[num].x = ((object[num].distance - 15.0f) / 2.0f) - (5*level) - float(rand() % (5*level));</p>

<p>Nakonec zvolíme náhodný smìr pohybu: 0 vlevo nebo 1 vpravo.</p>

<p class="src1">object[num].dir = (rand() % 2);<span class="kom">// Náhodný smìr pohybu</span></p>

<p>Nyní se podíváme, kterým smìrem se bude objekt posunovat. Pokud pùjde doleva (dir == 0), zmìníme rotaci na proti smìru hodinových ruèièek (rot = 2). Pozice na ose x je defaultnì záporná. Nicménì, pokud se máme pohybovat vlevo, musíme se na zaèátku nacházet vpravo. Negujeme tedy hodnotu x.</p>

<p class="src1">if (object[num].dir == 0)<span class="kom">// Pohybuje se doleva?</span></p>
<p class="src1">{</p>
<p class="src2">object[num].rot = 2;<span class="kom">// Rotace proti smìru hodinových ruèièek</span></p>
<p class="src2">object[num].x = -object[num].x;<span class="kom">// Výchozí pozice vpravo</span></p>
<p class="src1">}</p>

<p>Zjistíme, který druh objektu poèítaè vybral. Pokud se index textury rovná nule, zvolil texturu modré tváøe a ty se v¾dy pohybují tìsnì nad zemí. Ruènì nastavíme y pozici na -2.0f.</p>

<p class="src1">if (object[num].texid == 0)<span class="kom">// Modrá tváø</span></p>
<p class="src1">{</p>
<p class="src2">object[num].y = -2.0f;<span class="kom">// V¾dy tìsnì nad zemí</span></p>
<p class="src1">}</p>

<p>Práce s objektem kýblu bude slo¾itìj¹í. Padají toti¾ z nebe (dir = 3). Z toho také plyne, ¾e bychom mìli nastavit novou x-ovou pozici, proto¾e by nikdy nebyl vidìt (objekty jsou na zaèátku v¾dy vlevo nebo vpravo od scény). Namísto odeèítání 15 z minulého pøíkladu odeèteme pouze 10. Tímto dosáhneme men¹ího rozmezí hodnot, které udr¾í objekt viditelnì na scénì. Pøedpokládáme-li, ¾e se hloubka rovná -30.0f, skonèíme s náhodnou hodnotou od 0.0f do +40.0f. Horní hodnota je kladná a ne záporná, jak by se mohlo zdát, proto¾e rand() v¾dy vrací kladné èíslo. Získali jsme tedy èíslo od 0.0f do 40.0f, k nìmu pøièteme hloubku (záporné èíslo) mínus 10.0f a to celé dìlené dvìma. Opìt pøíklad: pøepokládáme, ¾e vrácená náhodná hodnota je 15 a objekt se nachází ve vzdálenosti -30.0f jednotek.</p>

<p class="src0"><span class="kom">object[num].x = float(rand() % int(-30.0f - 10.0f)) + ((-30.0f - 10.0f) / 2.0f);</span></p>
<p class="src0"><span class="kom">object[num].x = float(rand() % int(-40.0f) + (-40.0f) / 2.0f);</span></p>
<p class="src0"><span class="kom">object[num].x = { pøedpokládejme 15 } + (-20.0f);</span></p>
<p class="src0"><span class="kom">object[num].x = 15.0f - 20.0f;</span></p>
<p class="src0"><span class="kom">object[num].x = -5.0f;</span></p>

<p>Nakonec urèíme umístìní na ose y. Chceme, aby padal z oblohy, ale nevystupoval z mrakù. Èíslo 4.5f odpovídá pozici malièko ní¾e pod mraky.</p>

<p class="src1">if (object[num].texid == 1)<span class="kom">// Kýbl</span></p>
<p class="src1">{</p>
<p class="src2">object[num].dir = 3;<span class="kom">// Padá dolù</span></p>
<p class="src2">object[num].x = float(rand() % int(object[num].distance - 10.0f)) + ((object[num].distance - 10.0f) / 2.0f);</p>
<p class="src2">object[num].y = 4.5f;<span class="kom">// Tìsnì pod mraky</span></p>
<p class="src1">}</p>

<p>Objekt terèe by mìl vystoupit nahoru ze zemì (dir = 2). Pro umístìní na ose x pou¾ijeme stejný postup jako pøed chvílí. Nechceme, aby jeho poèáteèní poloha zaèínala nad zemí, tak¾e nastavíme y na -3.0f (pod zemí). Od nìj odeèteme náhodné èíslo od nuly do 5*level, aby se neobjevil hned, ale se zpo¾dìním a¾ po chvíli. Èím vy¹¹í level, tím déle trvá, ne¾ se objeví. To dává hráèi trochu èasu na vzpamatování se - bez této operace by terèe vyskakovaly rychle jeden za druhým.</p>

<p class="src1">if (object[num].texid == 2)<span class="kom">// Terè</span></p>
<p class="src1">{</p>
<p class="src2">object[num].dir = 2;<span class="kom">// Vyletí vzhùru</span></p>
<p class="src2">object[num].x = float(rand() % int(object[num].distance - 10.0f)) + ((object[num].distance - 10.0f) / 2.0f);</p>
<p class="src2">object[num].y = -3.0f - float(rand() % (5*level));<span class="kom">// Pod zemí</span></p>
<p class="src1">}</p>

<p>V¹echny ostatní objekty se pohybují zleva doprava, a proto není nutné, abychom jejich nastavení nìjakým zpùsobem mìnili.</p>

<p>Mohli bychom u¾ skonèit, ale zbývá je¹tì udìlat jednu velice dùle¾itou vìc. Aby alfa blending pracoval správnì, musí být prùhledné polygony vykreslovány od nejvzdálenìj¹ích po nejbli¾¹í a nesmí se protínat. Z buffer toti¾ vyøazuje vzdálenìj¹í polygony, jsou-li ji¾ nìjaké pøed nimi. Kdyby ty pøední nebyly prùhledné, nièemu by to nevadilo a navíc by se rendering urychlil, nicménì, kdy¾ jsou objekty vepøedu prùhledné, tak by objekty za nimi mìly být vidìt. Nyní se buï nezobrazí nebo je kolem pøedních vykreslen ètvercový tvar, reprezentující pùvodní polygon bez prùhlednosti... nic hezkého.</p>

<p>Známe hloubku v¹ech objektù, tak¾e není ¾ádný problém, abychom je po inicializaci nového seøadili, jak potøebujeme. Pou¾ijeme standardní funkci qsort() (quick sort - rychlé øazení). Pøi následném renderingu vezmeme první prvek pole a vykreslíme ho. Nebudeme se muset o nic starat, proto¾e víme, ¾e je ve scénì nejhloubìji.</p>

<p>Tento kód jsem nalezl v MSDN, ale úspìchu pøedcházelo dlouhé hledání na internetu. Funkce qsort() pracuje dobøe a dovoluje øadit celé struktury. Pøedáváme jí ètyøi parametry. První ukazuje na pole objektù, které mají být seøazeny, druhý urèuje jejich poèet (odpovídá aktuálnímu levelu). Tøetí parametr definuje velikost jedné struktury a ètvrtý je ukazatelem na porovnávací funkci Compare(). S nejvìt¹í pravdìpodobností existuje nìjaká lep¹í metoda pro øazení struktur, ale qsort() vyhovuje. Je rychlá a snadno se pou¾ívá.</p>

<p>Dùle¾itá poznámka: Pokud pou¾íváte glAlphaFunc() a glEnable(GL_ALPHA_TEST) namísto &quot;klasického&quot; blendingu, není øazení nutné. Pou¾íváním alpha funkcí jste ale omezeni na úplnou prùhlednost nebo úplnou neprùhlednost, nic mezi tím. Pou¾ívání BlendFunc() a øazení objektù stojí sice trochu práce navíc, ale dovoluje mít objekty poloprùhledné.</p>

<p class="src1"><span class="kom">// *** Modifikovaný MSDN kód pro tento tutoriál ***</span></p>
<p class="src1">qsort((void *) &amp;object, level, sizeof(struct objects), (compfn)Compare);<span class="kom">// Øazení objektù podle hloubky</span></p>
<p class="src0">}</p>

<p>První dva pøíkazy v inicializaèním kódu nagrabují informace o oknì a indikátoru stisknutých kláves. Funkcí srand() inicializujeme generátor náhodných èísel, potom loadujeme textury a vytvoøíme display listy fontu.</p>

<p class="src0">BOOL Initialize (GL_Window* window, Keys* keys)<span class="kom">// Inicializace OpenGL</span></p>
<p class="src0">{</p>
<p class="src1">g_window = window;</p>
<p class="src1">g_keys = keys;</p>
<p></p>
<p class="src1">srand((unsigned)time(NULL));<span class="kom">// Inicializace generátoru náhodných èísel</span></p>
<p></p>
<p class="src1">if ((!LoadTGA(&amp;textures[0],&quot;Data/BlueFace.tga&quot;)) ||<span class="kom">// Modrá tváø</span></p>
<p class="src2">(!LoadTGA(&amp;textures[1],&quot;Data/Bucket.tga&quot;)) ||<span class="kom">// Kbelík</span></p>
<p class="src2">(!LoadTGA(&amp;textures[2],&quot;Data/Target.tga&quot;)) ||<span class="kom">// Terè</span></p>
<p class="src2">(!LoadTGA(&amp;textures[3],&quot;Data/Coke.tga&quot;)) ||<span class="kom">// Coca-Cola</span></p>
<p class="src2">(!LoadTGA(&amp;textures[4],&quot;Data/Vase.tga&quot;)) ||<span class="kom">// Váza</span></p>
<p class="src2">(!LoadTGA(&amp;textures[5],&quot;Data/Explode.tga&quot;)) ||<span class="kom">// Exploze</span></p>
<p class="src2">(!LoadTGA(&amp;textures[6],&quot;Data/Ground.tga&quot;)) ||<span class="kom">// Zemì</span></p>
<p class="src2">(!LoadTGA(&amp;textures[7],&quot;Data/Sky.tga&quot;)) ||<span class="kom">// Obloha</span></p>
<p class="src2">(!LoadTGA(&amp;textures[8],&quot;Data/Crosshair.tga&quot;)) ||<span class="kom">// Kurzor</span></p>
<p class="src2">(!LoadTGA(&amp;textures[9],&quot;Data/Font.tga&quot;)))<span class="kom">// Font</span></p>
<p class="src1">{</p>
<p class="src2">return FALSE;<span class="kom">// Inicializace se nezdaøila</span></p>
<p class="src1">}</p>
<p></p>
<p class="src1">BuildFont();<span class="kom">// Vytvoøí display listy fontu</span></p>

<p>Nastavíme èerné pozadí. Depth bufferem testujeme na ménì nebo rovno (GL_LEQUAL).</p>

<p class="src1">glClearColor(0.0f, 0.0f, 0.0f, 0.0f);<span class="kom">// Èerné pozadí</span></p>
<p class="src1">glClearDepth(1.0f);<span class="kom">// Nastavení depth bufferu</span></p>
<p class="src1">glDepthFunc(GL_LEQUAL);<span class="kom">// Typ testování hloubky</span></p>
<p class="src1">glEnable(GL_DEPTH_TEST);<span class="kom">// Zapne testování hloubky</span></p>

<p>Pøíkaz glBlendFunc() je VELMI dùle¾itý. Parametry GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA oznamují OpenGL, aby pøi renderingu pou¾ívalo alfa hodnoty ulo¾ené v textuøe. Aby se blending mohl projevit, musíme ho zapnout. Dále zapínáme i mapování 2D textur a oøezávání zadních stran polygonù. Pøi kreslení zadáváme souøadnice polygonù proti smìru hodinových ruèièek, tak¾e odstranìní zadních stran polygonù nièemu nevadí. Navíc se program urychlí, proto¾e má s kreslením pouze polovinu práce.</p>

<p>Vý¹e v tutoriálu jsem psal o pou¾ití glAlphaFunc() namísto blendingu. Pokud chcete pou¾ívat radìji alfa funkci, zakomentáøujte dva øádky dùle¾ité pro blending a odkomentáøujte dva øádky alfy. Zakomentáøovat mù¾ete také øazení objektù pomocí qsort() a v¹e s ním spojené. Pøi alfa testingu není poøadí renderingu dùle¾ité.</p>

<p>Program pùjde v poøádku, ale obloha se nezobrazí. Pøíèinou je její textura, která má alfa hodnotu 0.5f. Alfa, narozdíl od blendingu, v¹ak mù¾e být buï nula nebo jedna, nic mezi. Problém lze vyøe¹it modifikací alfa kanálu textury. Obì metody pøiná¹ejí velmi dobré výsledky.</p>

<p class="src1">glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);<span class="kom">// Nastavení alfa blendingu</span></p>
<p class="src1">glEnable(GL_BLEND);<span class="kom">// Zapne alfa blending</span></p>
<p></p>
<p class="src1"><span class="kom">// glAlphaFunc(GL_GREATER, 0.1f);// Nastavení alfa testingu</span></p>
<p class="src1"><span class="kom">// glEnable(GL_ALPHA_TEST);// Zapne alfa testing</span></p>
<p></p>
<p class="src1">glEnable(GL_TEXTURE_2D);<span class="kom">// Zapne mapování textur</span></p>
<p class="src1">glEnable(GL_CULL_FACE);<span class="kom">// Oøezávání zadních stran polygonù</span></p>

<p>Na tomto místì inicializujeme v¹echny objekty, které program pou¾ívá a potom ukonèíme funkci.</p>

<p class="src1">for (int loop = 0; loop &lt; 30; loop++)<span class="kom">// Prochází v¹echny objekty</span></p>
<p class="src1">{</p>
<p class="src2">InitObject(loop);<span class="kom">// Inicializace ka¾dého z nich</span></p>
<p class="src1">}</p>
<p></p>
<p class="src1">return TRUE;<span class="kom">// Inicializace úspì¹ná</span></p>
<p class="src0">}</p>

<p>Naprogramujeme detekci zásahù do objektù. Ze v¹eho nejdøíve deklarujeme buffer, který pou¾ijeme k ulo¾ení informací o vybraných objektech. Promìnná hits slou¾í k poèítání zásahù.</p>

<p class="src0">void Selection(void)<span class="kom">// Detekce zasa¾ení objektù</span></p>
<p class="src0">{</p>
<p class="src1">GLuint buffer[512];<span class="kom">// Deklarace selection bufferu</span></p>
<p class="src1">GLint hits;<span class="kom">// Poèet zasa¾ených objektù</span></p>

<p>Skonèila-li hra, není ¾ádný dùvod, abychom hledali, který objekt byl zasa¾en, a proto ukonèíme funkci. Pokud je hráè stále ve høe, pøehrajeme zvuk výstøelu. Tato funkce je volána pouze tehdy, kdy¾ hráè stiskl tlaèítko my¹i. A pokud stiskl tlaèítko my¹i, znamená to, ¾e chtìl vystøelit. Nezále¾í, jestli zasáhl nebo ne, zvuk výstøelu je sly¹et v¾dy. Pøehrajeme ho v asynchroním módu (SND_ASYNC), aby bì¾el na pozadí a program nemusel èekat a¾ skonèí.</p>

<p class="src1">if (game)<span class="kom">// Konec hry?</span></p>
<p class="src1">{</p>
<p class="src2">return;<span class="kom">// Není dùvod testovat na zásah</span></p>
<p class="src1">}</p>
<p></p>
<p class="src1">PlaySound(&quot;data/shot.wav&quot;, NULL, SND_ASYNC);<span class="kom">// Pøehraje zvuk výstøelu</span></p>

<p>Nastavíme pole viewport tak, aby obsahovalo pozici x, y se ¹íøkou a vý¹kou aktuálního viewportu (OpenGL okna). Voláním funkce glSelectBuffer() naøídíme OpenGL, aby pou¾ilo na¹e pole buffer pro svùj selection buffer.</p>

<p class="src1">GLint viewport[4];<span class="kom">// Velikost viewportu. [0] = x, [1] = y, [2] = vý¹ka, [3] = ¹íøka</span></p>
<p></p>
<p class="src1">glGetIntegerv(GL_VIEWPORT, viewport);<span class="kom">// Nastaví pole podle velikosti a lokace scény relativnì k oknu</span></p>
<p class="src1">glSelectBuffer(512, buffer);<span class="kom">// Pøiká¾e OpenGL, aby pro selekci objektù pou¾ilo pole buffer</span></p>

<p>V¹echen kód ní¾e je velmi dùle¾itý. Nejdøíve pøevedeme OpenGL do selection módu. Nic, co se vykresluje, se nezobrazí, ale namísto toho se informace o renderovaných objektech ulo¾í do selection bufferu. Potom voláním glInitNames() a glPushName(0) inicializujeme name stack (stack jmen). Kdyby OpenGL nebylo v selection módu, glPushName() by bylo ignorováno.</p>

<p class="src1">(void) glRenderMode(GL_SELECT);<span class="kom">// Pøevedení OpenGL do selection módu</span></p>
<p></p>
<p class="src1">glInitNames();<span class="kom">// Inicializace name stacku</span></p>
<p class="src1">glPushName(0);<span class="kom">// Vlo¾í 0 (nejménì jedna polo¾ka) na stack</span></p>

<p>Po pøípravì name stacku musíme omezit kreslení na oblast pod kurzorem. Zvolíme projekèní matici, pushneme ji na stack a resetujeme ji voláním glLoadIdentity().</p>

<p class="src1">glMatrixMode(GL_PROJECTION);<span class="kom">// Zvolí projekèní matici</span></p>
<p class="src1">glPushMatrix();<span class="kom">// Ulo¾ení projekèní matice</span></p>
<p class="src1">glLoadIdentity();<span class="kom">// Reset matice</span></p>

<p>Oblast kreslení omezíme pøíkazem gluPickMatrix(). První parametr urèuje pozice my¹i na ose x, druhý je na ose y. Jednièky pøedstavují ¹íøku a vý¹ku picking regionu. Posledním parametrem je pole viewport, které urèuje aktuální okraje viewportu. Mouse_x a mouse_y budou støedem picking regionu.</p>

<p class="src1"><span class="kom">// Vytvoøení matice, která zvìt¹í malou èást obrazovky okolo kurzoru my¹i</span></p>
<p class="src1">gluPickMatrix((GLdouble) mouse_x, (GLdouble) (viewport[3] - mouse_y), 1.0f, 1.0f, viewport);</p>

<p>Voláním gluPerspective vynásobíme perspektivní matici pick maticí, která omezuje vykreslování na oblast vy¾ádanou od gluPickMatrix(). Potom pøepneme na matici modelview a vykreslíme sestøelované objekty. Kreslíme je funkcí DrawTargets() a ne Draw(), proto¾e chceme urèit zásahy do objektù a ne do oblohy, zemì nebo kurzoru. Po vykreslení objektù pøepneme zpìt na projekèní matici a popneme ji ze stacku. Nakonec se znovu vrátíme k matici modelview. Posledním pøíkazem pøepneme OpenGL zpìt do renderovacího módu, tak¾e se opìt budou vykreslované objekty zobrazovat na scénu. Promìnná hits bude po pøiøazení obsahovat poèet objektù, které byly vykresleny na oblast specifikovanou gluPickMatrix(). Tedy tam, kde se nacházel kurzor my¹i pøi výstøelu.</p>

<p class="src1"><span class="kom">// Aplikování perspektivní matice</span></p>
<p class="src1">gluPerspective(45.0f, (GLfloat) (viewport[2] - viewport[0]) / (GLfloat) (viewport[3] - viewport[1]), 0.1f, 100.0f);</p>
<p class="src1">glMatrixMode(GL_MODELVIEW);<span class="kom">// Modelview matice</span></p>
<p></p>
<p class="src1">DrawTargets();<span class="kom">// Renderuje objekty do selection bufferu</span></p>
<p></p>
<p class="src1">glMatrixMode(GL_PROJECTION);<span class="kom">// Projekèní matice</span></p>
<p class="src1">glPopMatrix();<span class="kom">// Obnovení projekèní matice</span></p>
<p class="src1">glMatrixMode(GL_MODELVIEW);<span class="kom">// Modelview matice</span></p>
<p></p>
<p class="src1">hits = glRenderMode(GL_RENDER);<span class="kom">// Pøepnutí do renderovacího módu, ulo¾ení poètu objektù pod kurzorem</span></p>

<p>Zjistíme, jestli bylo zaznamenáno více ne¾ nula zásahù. Pokud ano, pøiøadíme promìnné choose jméno prvního objektu, který byl vykreslen do picking oblasti. Depth ukládá, jak hluboko ve scénì se tento objekt nachází. Ka¾dý zásah zabírá v bufferu ètyøi polo¾ky. První je poètem jmen v name stacku, kdy¾ se zásah udál. Druhá polo¾ka pøedstavuje minimální z hodnotu (hloubku) ze v¹ech vertexù, které protínaly zobrazenou oblast v èase zásahu. Tøetí naopak obsahuje maximální z hodnotu a poslední polo¾ka je obsahem name stacku v èase zásahu, nebo-li jméno objektu. V tomto programu nás zajímá minimální z hodnota a jméno objektu.</p>

<p class="src1">if (hits &gt; 0)<span class="kom">// Bylo více ne¾ nula zásahù?</span></p>
<p class="src1">{</p>
<p class="src2">int choose = buffer[3];<span class="kom">// Ulo¾í jméno prvního objektu</span></p>
<p class="src2">int depth = buffer[1];<span class="kom">// Ulo¾í jeho hloubku</span></p>

<p>Zalo¾íme cyklus skrz v¹echny zásahy, abychom se ujistili, ¾e ¾ádný z objektù není blí¾e ne¾ ten první. Jinými slovy potøebujeme najít nejbli¾¹í objekt ke støelci. Kdybychom ho nehledali a støelec zasáhl dva pøekrývající se objekty najednou, mohl by ten v poøadí pole první být vzdálenìj¹í od pozorovatele. kliknutí my¹í by sestøelilo ¹patný objekt. Je jasné, ¾e pokud je nìkolik terèù za sebou, tak se pøi výstøelu zasáhne v¾dy ten nejbli¾¹í.</p>

<p>Ka¾dý objekt má v poli buffer ètyøi polo¾ky, tak¾e násobíme aktuální prùbìh ètyømi. Abychom získali hloubku objektu (druhá polo¾ka), pøièítáme jednièku. pokud je právì testovaná hloubka men¹í ne¾ aktuálnì nejni¾¹í, pøipí¹eme informace o jménu objektu a jeho hloubce. Po v¹ech prùchodech cyklem, bude choose obsahovat jméno ke støelci nejbli¾¹ího zasa¾eného objektu a depth jeho hloubku.</p>

<p class="src2">for (int loop = 1; loop &lt; hits; loop++)<span class="kom">// Prochází v¹echny detekované zásahy</span></p>
<p class="src2">{</p>
<p class="src3">if (buffer[loop*4 + 1] &lt; GLuint(depth))<span class="kom">// Je tento objekt blí¾e ne¾ nìkterý z pøedchozích?</span></p>
<p class="src3">{</p>
<p class="src4">choose = buffer[loop*4 + 3];<span class="kom">// Ulo¾í jméno bli¾¹ího objektu</span></p>
<p class="src4">depth = buffer[loop*4 + 1];<span class="kom">// Ulo¾í jeho hloubku</span></p>
<p class="src3">}</p>
<p class="src2">}</p>

<p>Na¹li jsme zasa¾ený objekt. Pøiøazením TRUE do hit ho oznaèíme, aby nemohl být zasa¾en po druhé nebo znièen automaticky po opu¹tìní scény. Pøièteme k hráèovu score jednièku a také inkrementujeme poèet zásahù v daném levelu.</p>

<p class="src2">if (!object[choose].hit)<span class="kom">// Nebyl je¹tì objekt zasa¾en?</span></p>
<p class="src2">{</p>
<p class="src3">object[choose].hit = TRUE;<span class="kom">// Oznaèí ho jako zasa¾ený</span></p>
<p></p>
<p class="src3">score += 1;<span class="kom">// Zvý¹í celkové skóre</span></p>
<p class="src3">kills += 1;<span class="kom">// Zvý¹í poèet zásahù v levelu</span></p>

<p>Chceme, aby v ka¾dém následujícím levelu musel hráè sestøelit vìt¹í poèet objektù. Tím se znesnadòuje postup mezi levely. Zkontrolujeme, jestli je kills vìt¹í ne¾ aktuální level násobený pìti. V levelu jedna staèí pro postup sestøelit pouze pìt objektù (1*5). V druhém levelu u¾ je to deset (2*5), atd. Hra zaèíná být tì¾¹í a tì¾¹í.</p>

<p>Nastal-li èas pro pøesun do následujího levelu, nastavíme poèet nezasa¾ených objektù na nulu, aby jím mìl hráè vìt¹í ¹anci úspì¹nì projít. Ale aby v¹e nebylo zase tak jednoduché, vynulujeme i poèet zasa¾ených objektù. Nakonec nesmíme zapomenout inkrementovat level a otestovat, jestli u¾ nebyl poslední. Dùvod proè máme zrovna tøicet levelù je velice jednoduchý. Tøicátý level je u¾ ¹ílenì obtí¾ný, myslím, ¾e nikdo nemá ¹anci ho dosáhnout. Druhým dùvodem je maximální poèet objektù - je jich právì tøicet. Chcete-li jich více poupravujte program.</p>

<p>Na scénì mù¾ete mít ale MAXIMÁLNÌ 64 objektù (0 a¾ 63). Pokud jich zkusíte renderovat 65 a více, PICKING PØESTANE PRACOVAT SPRÁVNÌ a zaènou se dít podivné vìci. V¹echno od náhodnì vybuchujících objektù a¾ k celému va¹emu poèítaèi se kompletnì zhroutí. 64 objektù je fyzikální limit OpenGL, stejnì jako napøíklad 8 svìtel ve scénì.</p>

<p>Pokud jste nìjakou ¹»astnou náhodou bohem :-) a dostanete se a¾ k tøicátému levelu, vý¹e u¾ bohu¾el nepostoupíte. Nicménì celkové skóre se bude stále zvy¹ovat a poèet zasa¾ených i nezasa¾ených objektù se v¾dy na tomto místì resetuje.</p>

<p class="src3">if (kills &gt; level*5)<span class="kom">// Èas pro dal¹í level?</span></p>
<p class="src3">{</p>
<p class="src4">miss = 0;<span class="kom">// Nulování nezasa¾ených objektù</span></p>
<p class="src4">kills = 0;<span class="kom">// Nulování zasa¾ených objektù v tomto levelu</span></p>
<p class="src4">level += 1;<span class="kom">// Posun na dal¹í level</span></p>
<p></p>
<p class="src4">if (level &gt; 30)<span class="kom">// Poslední level?</span></p>
<p class="src4">{</p>
<p class="src5">level = 30;<span class="kom">// Nastavení levelu na poslední</span></p>
<p class="src4">}</p>
<p class="src3">}</p>
<p class="src2">}</p>
<p class="src1">}</p>
<p class="src0">}</p>

<p>Ve funkci Update() testujeme stisk kláves a aktualizujeme umístìní objektù ve scénì. Jednou z pøíjemných vìcí je pøedávaný parametr miliseconds, který definuje uplynulý èas od pøedchozího volání. Na jeho bázi posuneme objekt o danou vzdálenost. A výsledek? Hra pùjde stejnì rychle na libovolném procesoru. ALE je zde jeden nedostatek. Øeknìme, ¾e máme objekt pohybující se pìt jednotek za deset sekund. Rychlý poèítaè posune objektem o pùl jednotky za sekundu. Na pomalém systému mù¾e trvat 2 sekundy, ne¾ se funkce znovu zavolá. Tím vznikají rùzná zpo¾dìní a trhání, zkrátka animace u¾ není plynulá. Lep¹í øe¹ení v¹ak neexistuje. Pomalý poèítaè nezrychlíte, leda koupit nový...</p>

<p>Ale zpátky ke kódu. První podmínka zji¹»uje stisk klávesy ESC, který ukonèuje aplikaci.</p>

<p class="src0">void Update(DWORD milliseconds)<span class="kom">// Aktualizace pohybù ve scénì a stisk kláves</span></p>
<p class="src0">{</p>
<p class="src1">if (g_keys-&gt;keyDown[VK_ESCAPE])<span class="kom">// Klávesa ESC?</span></p>
<p class="src1">{</p>
<p class="src2">TerminateApplication(g_window);<span class="kom">// Ukonèení programu</span></p>
<p class="src1">}</p>

<p>Klávesa F1 pøepíná mód okna mezi systémem a fullscreenem.</p>

<p class="src1">if (g_keys-&gt;keyDown[VK_F1])<span class="kom">// Klávesa F1?</span></p>
<p class="src1">{</p>
<p class="src2">ToggleFullscreen(g_window);<span class="kom">// Pøepnutí fullscreen/okno</span></p>
<p class="src1">}</p>

<p>Stisk mezerníku po skonèení hry zalo¾í novou. Inicializujeme v¹ech tøicet objektù, nastavíme konec hry na false, skóre na nulu, první level a zasa¾ené i nezasa¾ené objekty v tomto levelu také na nulu. Nic nepochopitelného.</p>

<p class="src1">if (g_keys-&gt;keyDown[' '] &amp;&amp; game)<span class="kom">// Mezerník na konci hry?</span></p>
<p class="src1">{</p>
<p class="src2">for (int loop = 0; loop &lt; 30; loop++)<span class="kom">// Prochází v¹echny objekty</span></p>
<p class="src2">{</p>
<p class="src3">InitObject(loop);<span class="kom">// Jejich inicializace</span></p>
<p class="src2">}</p>
<p></p>
<p class="src2">game = FALSE;<span class="kom">// Je¹tì není konec hry</span></p>
<p></p>
<p class="src2">score = 0;<span class="kom">// Nulové skóre</span></p>
<p class="src2">level = 1;<span class="kom">// První level</span></p>
<p class="src2">kills = 0;<span class="kom">// Nula zasa¾ených objektù</span></p>
<p class="src2">miss = 0;<span class="kom">// Nula nezasa¾ených objektù</span></p>
<p class="src1">}</p>

<p>K vytvoøení iluze plujících mrakù a pohybující se zemì, odeèteme od roll èíslo 0.00005f násobené poètem milisekund od minulého renderingu. Princip èasování jsme si vysvìtlili vý¹e.</p>

<p class="src1">roll -= milliseconds * 0.00005f;<span class="kom">// Mraky plují a zemì se pohybuje</span></p>

<p>Zalo¾íme cyklus, který prochází v¹echny objekty ve scénì a aktualizuje je. Jejich poèet je roven aktuálnímu levelu.</p>

<p class="src1">for (int loop = 0; loop &lt; level; loop++)<span class="kom">// Aktualizace v¹ech viditelných objektù</span></p>
<p class="src1">{</p>

<p>Potøebujeme zjistit, kterým smìrem se který objekt otáèí. Podle smìru rotace upravíme aktuální úhel natoèení o 0.2 stupòù vynásobených øídící promìnnou cyklu seètenou s milisekundami. Pøièítáním loop získáme rozdílnou rotaci pro ka¾dý objekt. Druhý objekt se nyní otáèí rychleji ne¾ první a tøetí objekt je¹tì rychleji ne¾ druhý.</p>

<p class="src2">if (object[loop].rot == 1)<span class="kom">// Rotace po smìru hodinových ruèièek?</span></p>
<p class="src3">object[loop].spin -= 0.2f * (float(loop + milliseconds));</p>
<p></p>
<p class="src2">if (object[loop].rot == 2)<span class="kom">// Rotace proti smìru hodinových ruèièek?</span></p>
<p class="src3">object[loop].spin += 0.2f * (float(loop + milliseconds));</p>

<p>Pøesuneme se ke kódu zaji¹»ujícímu pohyby. Pokud se objekt pohybuje doprava (dir == 1), pøièteme k x pozici 0.0012f. Podobným zpùsobem o¹etøíme posun doleva (dir == 0). Pøi smìru nahoru (dir == 2) zvìt¹íme y hodnotu, proto¾e kladná èást osy y le¾í nahoøe. Smìr dolù (dir == 3) je úplnì stejný jako pøedchozí. Odeèítáme v¹ak men¹í èíslo, aby byl pád pomalej¹í.</p>

<p class="src2">if (object[loop].dir == 1)<span class="kom">// Pohyb doprava?</span></p>
<p class="src3">object[loop].x += 0.012f * float(milliseconds);</p>
<p></p>
<p class="src2">if (object[loop].dir == 0)<span class="kom">// Pohyb doleva?</span></p>
<p class="src3">object[loop].x -= 0.012f * float(milliseconds);</p>
<p></p>
<p class="src2">if (object[loop].dir == 2)<span class="kom">// Pohyb nahoru?</span></p>
<p class="src3">object[loop].y += 0.012f * float(milliseconds);</p>
<p></p>
<p class="src2">if (object[loop].dir == 3)<span class="kom">// Pohyb dolù?</span></p>
<p class="src3">object[loop].y -= 0.0025f * float(milliseconds);</p>

<p>Posunuli jsme objektem a nyní potøebujeme otestovat, jestli je na scénì je¹tì vidìt. Mù¾eme to zjistit podle hloubky ve scénì mínus 15.0f (malá tolerance navíc) a dìlením dvìma. Pro ty z vás, kteøí od inicializace objektù u¾ zapomnìli... Pokud jste dvacet jednotek ve scénì, máte z ka¾dé strany zhruba deset jednotek viditelné scény (zále¾í na nastavení perspektivy). Tak¾e -20.0f (hloubka) -15.0f (extra okraj) = -35.0f. Vydìlíme 2.0f a získáme -17.5f, co¾ je pøibli¾nì 7.5 jednotek vlevo od viditelné scény. Objekt tedy u¾ urèitì není vidìt.</p>

<p>Musí také platit podmínka, ¾e se objekt pohybuje doleva (dir == 0). Pokud ne, nestaráme se o nìj. Poslední èást logického výrazu pøedstavuje test zásahu. Shrneme to: pokud objekt vyletìl vlevo ze scény, pohybuje se doleva a nebyl zasa¾en, u¾ivatel ho u¾ nemá ¹anci zasáhnout. Zvý¹íme poèet nezasa¾ených objektù a oznaèíme objekt jako zasa¾ený, aby se o nìj program u¾ pøí¹tì nestaral. Touto cestou (hit = true) také zajistíme autodestrukci, co¾ nám po nìjaké dobì umo¾ní jeho automatickou reinicializaci - nová textura, smìr pohybu, rotace ap.</p>

<p class="src2"><span class="kom">// Objekt vyletìl vlevo ze scény, pohybuje se vlevo a je¹tì nebyl zasa¾en</span></p>
<p class="src2">if ((object[loop].x &lt; (object[loop].distance - 15.0f) / 2.0f) &amp;&amp; (object[loop].dir == 0) &amp;&amp; !object[loop].hit)</p>
<p class="src2">{</p>
<p class="src3">miss += 1;<span class="kom">// Zvý¹ení poètu nezasa¾ených objektù</span></p>
<p class="src3">object[loop].hit = TRUE;<span class="kom">// Odstranìní objektu (zaji¹»uje animaci exploze a reinicializaci)</span></p>
<p class="src2">}</p>

<p>Analogicky o¹etøíme opu¹tìní scény vpravo a náraz do zemì.</p>

<p class="src2"><span class="kom">// Objekt vyletìl vpravo ze scény, pohybuje se vpravo a je¹tì nebyl zasa¾en</span></p>
<p class="src2">if ((object[loop].x &gt; -(object[loop].distance - 15.0f) / 2.0f) &amp;&amp; (object[loop].dir == 1) &amp;&amp; !object[loop].hit)</p>
<p class="src2">{</p>
<p class="src3">miss += 1;<span class="kom">// Zvý¹ení poètu nezasa¾ených objektù</span></p>
<p class="src3">object[loop].hit = TRUE;<span class="kom">// Odstranìní objektu (zaji¹»uje animaci exploze a reinicializaci)</span></p>
<p class="src2">}</p>
<p></p>
<p class="src2"><span class="kom">// Objekt narazil do zemì, pohybuje se dolù a je¹tì nebyl zasa¾en</span></p>
<p class="src2">if ((object[loop].y &lt; -2.0f) &amp;&amp; (object[loop].dir == 3) &amp;&amp; !object[loop].hit)</p>
<p class="src2">{</p>
<p class="src3">miss += 1;<span class="kom">// Zvý¹ení poètu nezasa¾ených objektù</span></p>
<p class="src3">object[loop].hit = TRUE;<span class="kom">// Odstranìní objektu (zaji¹»uje animaci exploze a reinicializaci)</span></p>
<p class="src2">}</p>

<p>Narozdíl od pøedchozích testù pøi letu vzhùru udìláme men¹í zmìnu. Pokud se objekt dostane na ose y vý¹e ne¾ 4.5f jednotek (tìsnì pod mraky), neznièíme ho, ale pouze zmìníme jeho smìr, aby se pohyboval dolù. Destrukci zajistí pøedchozí kód pro nara¾ení do zemì.</p>

<p class="src2">if ((object[loop].y &gt; 4.5f) &amp;&amp; (object[loop].dir == 2))<span class="kom">// Objekt je pod mraky a smìøuje vzhùru</span></p>
<p class="src3">object[loop].dir = 3;<span class="kom">// Zmìna smìru na pád</span></p>
<p class="src1">}</p>
<p class="src0">}</p>

<p>Do mapy zpráv ve funkci WindowProc() pøidáme dvì vìtve, které obsluhují události my¹i. Pøi stisknutí levého tlaèítka ulo¾íme pozici kliknutí v oknì a ve funkci Selection() zjistíme, jestli se hráè strefil do nìkterého z objektù nebo ne. Proto¾e vykreslujeme vlastní OpenGL kurzor, potøebujeme pøi renderingu znát jeho pozici. O to se stará WM_MOUSEMOVE.</p>

<p class="src0"><span class="kom">// Funkce WindowProc</span></p>
<p class="src1">case WM_LBUTTONDOWN:<span class="kom">// Stisknutí levého tlaèítka my¹i</span></p>
<p class="src2">mouse_x = LOWORD(lParam);</p>
<p class="src2">mouse_y = HIWORD(lParam);</p>
<p class="src2">Selection();</p>
<p class="src2">break;</p>
<p></p>
<p class="src1">case WM_MOUSEMOVE:<span class="kom">// Pohyb my¹i</span></p>
<p class="src2">mouse_x = LOWORD(lParam);</p>
<p class="src2">mouse_y = HIWORD(lParam);</p>
<p class="src2">break;</p>

<p>Pøistoupíme k vykreslení objektu. Funkci se pøedávají celkem tøi parametry, které ho dostateènì popisují - ¹íøka, vý¹ka a textura. Obdélník renderujeme zadáváním bodù proti smìru hodinových ruèièek, abychom mohli pou¾ít culling.</p>

<p class="src0">void Object(float width, float height, GLuint texid)<span class="kom">// Vykreslí objekt</span></p>
<p class="src0">{</p>
<p class="src1">glBindTexture(GL_TEXTURE_2D, textures[texid].texID);<span class="kom">// Zvolí správnou texturu</span></p>
<p></p>
<p class="src1">glBegin(GL_QUADS);<span class="kom">// Kreslení obdélníkù</span></p>
<p class="src2">glTexCoord2f(0.0f, 0.0f); glVertex3f(-width,-height, 0.0f);<span class="kom">// Levý dolní</span></p>
<p class="src2">glTexCoord2f(1.0f, 0.0f); glVertex3f( width,-height, 0.0f);<span class="kom">// Pravý dolní</span></p>
<p class="src2">glTexCoord2f(1.0f, 1.0f); glVertex3f( width, height, 0.0f);<span class="kom">// Pravý horní</span></p>
<p class="src2">glTexCoord2f(0.0f, 1.0f); glVertex3f(-width, height, 0.0f);<span class="kom">// Levý horní</span></p>
<p class="src1">glEnd();<span class="kom">// Konec kreslení</span></p>
<p class="src0">}</p>

<p>Kód pro renderování exploze dostává pouze jeden parametr - identifikátor objektu. Potøebujeme nagrabovat souøadnice oblasti na textuøe exploze. Udìláme to podobnou cestou, jako kdy¾ jsme získávali jednotlivé znaky z textury fontu. Ex a ey pøedstavují sloupec a øádek závislý na poøadí snímku animace (framu).</p>

<div class="okolo_img"><img src="images/nehe_tut/tut_32_exploze.jpg" width="256" height="256" alt="Textura snímkù exploze" /></div>

<p>Pozici na ose x získáme dìlením aktuálního snímku ètyømi. Proto¾e máme 64 snímkù a pouze 16 obrázkù, potøebujeme animaci zpomalit. Zbytek po dìlení upraví èíslo na hodnoty 0 a¾ 3 a aby texturové koordináty byly v rozmezí 0.0f a 1.0f, dìlíme ètyømi. Získali jsme sloupec, nyní je¹tì øádek. První dìlení opìt zmen¹uje èíslo, druhé dìlení eliminuje celý øádek a posledním dìlením získáme vertikální souøadnici na textuøe.</p>

<p>Pokud je aktuální snímek 16, ey = 16/4/4/4 = 4/4/4 = 0,25. Jeden øádek dolù. je-li snímek 60, ey = 60/4/4/4 = 15/4/4 = 3/4 = 0,75. Matematici nevìøí vlastním oèím... Dùvod proè se 15/4 nerovná 3,75 je to, ¾e do posledního dìlení pracujeme s celými èísly. Poèítáme-li se zaokrouhlováním dojdeme k závìru, ¾e výsledkem jsou v¾dy èísla 0.0f, 0.25f, 0.50f nebo 0.75f. Doufám, ¾e to dává smysl. Je to jednoduché, ale matematika zastra¹uje.</p>

<p class="src0">void Explosion(int num)<span class="kom">// Animace exploze objektu</span></p>
<p class="src0">{</p>
<p class="src1">float ex = (float)((object[num].frame/4)%4)/4.0f;<span class="kom">// Výpoèet x snímku exploze (0.0f - 0.75f)</span></p>
<p class="src1">float ey = (float)((object[num].frame/4)/4)/4.0f;<span class="kom">// Výpoèet y snímku exploze (0.0f - 0.75f)</span></p>

<p>Získali jsme texturovací koordináty, zbývá vykreslit obdélník. Vertexy jsou fixovány na -1.0f a 1.0f. U textur odeèítáme ey od 1.0f. Pokud bychom to neudìlali animace by probíhala v opaèném poøadí. Poèátek texturovacích souøadnic je vlevo dole.</p>

<p class="src1">glBindTexture(GL_TEXTURE_2D, textures[5].texID);<span class="kom">// Textura exploze</span></p>
<p></p>
<p class="src1">glBegin(GL_QUADS);<span class="kom">// Kreslení obdélníkù</span></p>
<p class="src2">glTexCoord2f(ex, 1.0f - (ey));</p>
<p class="src2">glVertex3f(-1.0f, -1.0f, 0.0f);<span class="kom">// Levý dolní</span></p>
<p></p>
<p class="src2">glTexCoord2f(ex + 0.25f, 1.0f - (ey));</p>
<p class="src2">glVertex3f( 1.0f, -1.0f, 0.0f);<span class="kom">// Pravý dolní</span></p>
<p></p>
<p class="src2">glTexCoord2f(ex + 0.25f, 1.0f - (ey + 0.25f));</p>
<p class="src2">glVertex3f( 1.0f, 1.0f, 0.0f);<span class="kom">// Pravý horní</span></p>
<p></p>
<p class="src2">glTexCoord2f(ex, 1.0f - (ey + 0.25f));</p>
<p class="src2">glVertex3f(-1.0f, 1.0f, 0.0f);<span class="kom">// Levý horní</span></p>
<p class="src1">glEnd();<span class="kom">// Konec kreslení</span></p>

<p>Jak je vysvìtleno vý¹e, snímek nesmí být vy¹¹í ne¾ 63, jinak by animace zaèala nanovo. Pøi pøesáhnutí tohoto èísla reinicializujeme objekt.</p>

<p class="src1">object[num].frame += 1;<span class="kom">// Zvý¹í snímek exploze</span></p>
<p></p>
<p class="src1">if (object[num].frame &gt; 63)<span class="kom">// Poslední snímek?</span></p>
<p class="src1">{</p>
<p class="src2">InitObject(num);<span class="kom">// Reinicializace objektu</span></p>
<p class="src1">}</p>
<p class="src0">}</p>

<p>Následující sekce kódu vykresluje objekty. Zaèneme resetováním matice a pøesunem o deset jednotek do hloubky.</p>

<p class="src0">void DrawTargets(void)<span class="kom">// Vykreslí objekty</span></p>
<p class="src0">{</p>
<p class="src1">glLoadIdentity();<span class="kom">// Reset matice</span></p>
<p class="src1">glTranslatef(0.0f, 0.0f, -10.0f);<span class="kom">// Posun do hloubky</span></p>

<p>Zalo¾íme cyklus procházející v¹echny aktivní objekty. Funkcí glLoadName() skrytì oznaèíme individuální objekty - ka¾dému se urèí jméno (èíslo), které odpovídá indexu v poli. Prvnímu se pøiøadí nula, druhému jednièka atd. Podle tohoto jména mù¾eme zjistit, který objekt byl zasa¾en. Pokud program není v selection módu glLoadName() je ignorováno. Po pøiøazení jména ulo¾íme matici.</p>

<p class="src1">for (int loop = 0; loop &lt; level; loop++)<span class="kom">// Prochází aktivní objekty</span></p>
<p class="src1">{</p>
<p class="src2">glLoadName(loop);<span class="kom">// Pøiøadí objektu jméno (pro detekci zásahù)</span></p>
<p class="src2">glPushMatrix();<span class="kom">// Ulo¾ení matice</span></p>

<p>Pøesuneme se na pozici objektu, kde má být vykreslen.</p>

<p class="src2">glTranslatef(object[loop].x, object[loop].y, object[loop].distance);<span class="kom">// Umístìní objektu</span></p>

<p>Pøed renderingem testujeme, jestli byl zasa¾en nebo ne. Pokud podmínka platí, vykreslíme místo objektu snímek animace exploze, jinak otoèíme objektem na ose z o jeho úhel spin a a¾ potom ho vykreslíme. Pro urèení rozmìrù pou¾ijeme pole size, které jsme vytvoøili na zaèátku programu. Texid reprezentuje typ objektu (texturu).</p>

<p class="src2">if (object[loop].hit)<span class="kom">// Byl objekt zasa¾en?</span></p>
<p class="src2">{</p>
<p class="src3">Explosion(loop);<span class="kom">// Vykreslí snímek exploze</span></p>
<p class="src2">}</p>
<p class="src2">else<span class="kom">// Objekt nebyl zasa¾en</span></p>
<p class="src2">{</p>
<p class="src3">glRotatef(object[loop].spin,0.0f,0.0f,1.0f);<span class="kom">// Natoèení na ose z</span></p>
<p class="src3">Object(size[object[loop].texid].w, size[object[loop].texid].h, object[loop].texid);<span class="kom">// Vykreslení</span></p>
<p class="src2">}</p>

<p>Po renderingu popneme matici, abychom zru¹ili posun a natoèení.</p>

<p class="src2">glPopMatrix();<span class="kom">// Obnoví matici</span></p>
<p class="src1">}</p>
<p class="src0">}</p>

<p>Draw() je hlavní vykreslovací funkcí. Jako obvykle sma¾eme buffery a resetujeme matici, kterou následnì pushneme.</p>

<p class="src0">void Draw(void)<span class="kom">// Vykreslení scény</span></p>
<p class="src0">{</p>
<p class="src1">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<span class="kom">// Sma¾e buffery</span></p>
<p class="src1">glLoadIdentity();<span class="kom">// Reset matice</span></p>
<p></p>
<p class="src1">glPushMatrix();<span class="kom">// Ulo¾í matici</span></p>

<p>Zvolíme texturu (v poøadí sedmá) a pokusíme se vykreslit oblohu. Je slo¾ena ze ètyø otexturovaných obdélníkù. První pøedstavuje oblohu od zemì pøímo vzhùru. Textura na nìm roluje docela pomalu. Druhý obdélník je vykreslen na stejném místì, ale jeho textura roluje rychleji. Obì textury se blendingem spojí dohromady a vytvoøí tak hezký vícevrstvý efekt.</p>

<p class="src1">glBegin(GL_QUADS);<span class="kom">// Kreslení obdélníkù</span></p>
<p class="src2">glTexCoord2f(1.0f,roll/1.5f+1.0f); glVertex3f( 28.0f,+7.0f,-50.0f);<span class="kom">// Pravý horní</span></p>
<p class="src2">glTexCoord2f(0.0f,roll/1.5f+1.0f); glVertex3f(-28.0f,+7.0f,-50.0f);<span class="kom">// Levý horní</span></p>
<p class="src2">glTexCoord2f(0.0f,roll/1.5f+0.0f); glVertex3f(-28.0f,-3.0f,-50.0f);<span class="kom">// Levý dolní</span></p>
<p class="src2">glTexCoord2f(1.0f,roll/1.5f+0.0f); glVertex3f( 28.0f,-3.0f,-50.0f);<span class="kom">// Pravý dolní</span></p>
<p></p>
<p class="src2">glTexCoord2f(1.5f,roll+1.0f); glVertex3f( 28.0f,+7.0f,-50.0f);<span class="kom">// Pravý horní</span></p>
<p class="src2">glTexCoord2f(0.5f,roll+1.0f); glVertex3f(-28.0f,+7.0f,-50.0f);<span class="kom">// Levý horní</span></p>
<p class="src2">glTexCoord2f(0.5f,roll+0.0f); glVertex3f(-28.0f,-3.0f,-50.0f);<span class="kom">// Levý dolní</span></p>
<p class="src2">glTexCoord2f(1.5f,roll+0.0f); glVertex3f( 28.0f,-3.0f,-50.0f);<span class="kom">// Pravý dolní</span></p>

<p>Abychom pøidali iluzi, ¾e mraky plují smìrem k pozorovateli, tøetí obdélník smìøuje z hloubky dopøedu. Dal¹í obdélník je opìt na stejné místì, ale textura roluje rychleji. Výsledkem ètyø obyèejných obdélníkù je obloha, která se jeví, jako by stoupala od zemì vzhùru a pøibli¾ovala se k pozorovateli. Mohl jsem pou¾ít otexturovanou polokouli, ale byl jsem pøíli¹ líný. Efekt s obdélníky vypadá celkem slu¹nì.</p>

<p class="src2">glTexCoord2f(1.0f,roll/1.5f+1.0f); glVertex3f( 28.0f,+7.0f,0.0f);<span class="kom">// Pravý horní</span></p>
<p class="src2">glTexCoord2f(0.0f,roll/1.5f+1.0f); glVertex3f(-28.0f,+7.0f,0.0f);<span class="kom">// Levý horní</span></p>
<p class="src2">glTexCoord2f(0.0f,roll/1.5f+0.0f); glVertex3f(-28.0f,+7.0f,-50.0f);<span class="kom">// Levý dolní</span></p>
<p class="src2">glTexCoord2f(1.0f,roll/1.5f+0.0f); glVertex3f( 28.0f,+7.0f,-50.0f);<span class="kom">// Bottom Right</span></p>
<p></p>
<p class="src2">glTexCoord2f(1.5f,roll+1.0f); glVertex3f( 28.0f,+7.0f,0.0f);<span class="kom">// Pravý horní</span></p>
<p class="src2">glTexCoord2f(0.5f,roll+1.0f); glVertex3f(-28.0f,+7.0f,0.0f);<span class="kom">// Levý horní</span></p>
<p class="src2">glTexCoord2f(0.5f,roll+0.0f); glVertex3f(-28.0f,+7.0f,-50.0f);<span class="kom">// Levý dolní</span></p>
<p class="src2">glTexCoord2f(1.5f,roll+0.0f); glVertex3f( 28.0f,+7.0f,-50.0f);<span class="kom">// Pravý dolní</span></p>
<p class="src1">glEnd();<span class="kom">// Konec kreslení</span></p>

<p>Nyní vykreslíme zemi. Zaèíná tam, kde se nachází nejni¾¹í bod oblohy a smìøuje smìrem k pozorovateli. Roluje stejnì rychle jako mraky. Abychom pøidali trochu více detailù a zamezili tak nepøíjemnému kostièkování pøi velkém zvìt¹ení, namapujeme texturu sedmkrát na ose x a ètyøikrát na ose y.</p>

<p class="src1">glBindTexture(GL_TEXTURE_2D, textures[6].texID);<span class="kom">// Textura zemì</span></p>
<p></p>
<p class="src1">glBegin(GL_QUADS);<span class="kom">// Kreslení obdélníkù</span></p>
<p class="src2">glTexCoord2f(7.0f,4.0f-roll); glVertex3f( 27.0f,-3.0f,-50.0f);<span class="kom">// Pravý horní</span></p>
<p class="src2">glTexCoord2f(0.0f,4.0f-roll); glVertex3f(-27.0f,-3.0f,-50.0f);<span class="kom">// Levý horní</span></p>
<p class="src2">glTexCoord2f(0.0f,0.0f-roll); glVertex3f(-27.0f,-3.0f,0.0f);<span class="kom">// Levý dolní</span></p>
<p class="src2">glTexCoord2f(7.0f,0.0f-roll); glVertex3f( 27.0f,-3.0f,0.0f);<span class="kom">// Pravý dolní</span></p>
<p class="src1">glEnd();<span class="kom">// Konec kreslení</span></p>

<p>Pozadí je vykresleno, pøistoupíme k sestøelovaným objektùm. Napsali jsme pro nì speciální funkci. Potom obnovíme matici.</p>

<p class="src1">DrawTargets();<span class="kom">// Sestøelované objekty</span></p>
<p class="src1">glPopMatrix();<span class="kom">// Obnovení matice</span></p>

<p>Vykreslíme kurzor my¹i. Nagrabované rozmìry okna ulo¾íme do struktury obdélníku window. Zvolíme projekèní matici a pushneme ji, resetujeme ji a pøevedeme scénu z perspektivního módu do pravoúhlé projekce. Souøadnice 0, 0 se nacházejí vlevo dole.</p>

<p>Ve funkci glOrtho() prohodíme tøetí a ètvrtý parametr, aby byl kurzor renderován proti smìru hodinových ruèièek a culling pracoval tak, jak chceme. Kdyby byl poèátek souøadnic nahoøe, zadávání bodù by probíhalo v opaèném smìru a kurzor s textem by se nezobrazil.</p>

<p class="src1">RECT window;<span class="kom">// Promìnná obdélníku</span></p>
<p class="src1">GetClientRect (g_window-&gt;hWnd,&amp;window);<span class="kom">// Grabování rozmìrù okna</span></p>
<p></p>
<p class="src1">glMatrixMode(GL_PROJECTION);<span class="kom">// Projekèní matice</span></p>
<p class="src1">glPushMatrix();<span class="kom">// Ulo¾í projekèní matici</span></p>
<p class="src1">glLoadIdentity();<span class="kom">// Reset projekèní matice</span></p>
<p></p>
<p class="src1">glOrtho(0, window.right, 0, window.bottom, -1, 1);<span class="kom">// Nastavení pravoúhlé scény</span></p>

<p>Po nastavení kolmé projekce zvolíme modelview matici a umístíme kurzor. Problém je v tom, ¾e poèátek scény (0, 0) je vlevo dole, ale okno (systém) ho má vlevo nahoøe. Kdybychom pozici kurzoru neinvertovali, tak by se pøi posunutí dolù, pohyboval nahoru. Od spodního okraje okna odeèteme mouse_y. Namísto pøedávání velikosti v OpenGL jednotkách, specifikujeme ¹íøku a vý¹ku v pixelech.</p>

<p>Rozhodl jsem se pou¾ít vlastní a ne systémový kurzor ze dvou dùvodù. První a více dùle¾itý je, ¾e vypadá lépe a mù¾e být modifikován v jakémkoli grafickém editoru, který podporuje alfa kanál. Druhým dùvodem je, ¾e nìkteré grafické karty kurzor ve fullscreenu nezobrazují. Hrát hru podobného typu bez kurzoru není vùbec snadné :-).</p>

<p class="src1">glMatrixMode(GL_MODELVIEW);<span class="kom">// Zvolí matici modelview</span></p>
<p class="src1">glTranslated(mouse_x, window.bottom-mouse_y, 0.0f);<span class="kom">// Posun na pozici kurzoru</span></p>
<p></p>
<p class="src1">Object(16, 16, 8);<span class="kom">// Vykreslí kurzor my¹i</span></p>

<p>Vypí¹eme logo NeHe Productions zarovnané na støed horní èásti okna, dále zobrazíme aktuální level a skóre.</p>

<p class="src1">glPrint(240, 450, &quot;NeHe Productions&quot;);<span class="kom">// Logo</span></p>
<p class="src1">glPrint(10, 10, &quot;Level: %i&quot;, level);<span class="kom">// Level</span></p>
<p class="src1">glPrint(250, 10, &quot;Score: %i&quot;, score);<span class="kom">// Skóre</span></p>

<p>Otestujeme, jestli hráè nestrefil více ne¾ devìt objektù. Pokud ano, nastavíme game na true, èím¾ indikujeme konec hry.</p>

<p class="src1">if (miss &gt; 9)<span class="kom">// Nestrefil hráè více ne¾ devìt objektù?</span></p>
<p class="src1">{</p>
<p class="src2">miss = 9;<span class="kom">// Limit je devìt</span></p>
<p class="src2">game = TRUE;<span class="kom">// Konec hry</span></p>
<p class="src1">}</p>

<p>Po skonèení hry vypisujeme text GAME OVER. Je-li hráè je¹tì ve høe, vypí¹eme kolik objektù mu mù¾e je¹tì uniknout. Text je ve formátu napø. '6/10' - mù¾e je¹tì nezasáhnout ¹est objektù z deseti.</p>

<p class="src1">if (game)<span class="kom">// Konec hry?</span></p>
<p class="src1">{</p>
<p class="src2">glPrint(490, 10, &quot;GAME OVER&quot;);<span class="kom">// Vypí¹e konec hry</span></p>
<p class="src1">}</p>
<p class="src1">else</p>
<p class="src1">{</p>
<p class="src2">glPrint(490, 10, &quot;Morale: %i/10&quot;, 10-miss);<span class="kom">// Vypí¹e poèet objektù, které nemusí sestøelit</span></p>
<p class="src1">}</p>

<p>Zbývá obnovit pùvodní nastavení. Zvolíme projekèní matici, obnovíme ji, zvolíme modelview matici a vyprázdníme buffer, abychom se ujistili, ¾e v¹echny objekty byly v poøádku zobrazeny.</p>

<p class="src1">glMatrixMode(GL_PROJECTION);<span class="kom">// Projekèní matice</span></p>
<p class="src1">glPopMatrix();<span class="kom">// Obnovení projekèní matice</span></p>
<p class="src1">glMatrixMode(GL_MODELVIEW);<span class="kom">// Modelview matice</span></p>
<p></p>
<p class="src1">glFlush();<span class="kom">// Vyprázdní OpenGL renderovací pipeline</span></p>
<p class="src0">}</p>

<p>Tento tutoriál je výsledkem mnoha probdìlých nocí pøi kódování a psaní HTML. Nyní byste mìli rozumìt pickingu, alfa testingu a øazení podle hloubky pøi alfa blendingu. Picking umo¾òuje vytvoøit interaktivní software, který se ovládá my¹í. V¹echno od her a¾ po nádherné GUI. Nejvìt¹í výhodou pickingu je, ¾e si nemusíme vést slo¾itý záznam, kde se objekty nacházejí, o translacích a rotacích ani nemluvì. Objektu staèí pøiøadit jméno a poèkat na výsledek. S alfa blendingem a testingem mù¾ete vykreslit objekt kompletnì neprùhledný a/nebo plný otvorù. Výsledek je ú¾asný, nemusíte se starat o prosvítání textur.</p>

<p>Mohl jsem strávit spoustu èasu pøidáváním pohybù podle fyzikálních zákonù, grafiky, zvukù a podobnì. Nicménì jsem vysvìtlil OpenGL techniky bez dal¹ích zbyteèností. Doufám, ¾e se po èase objeví nìjaké skvìlé modifikace kódu, které u¾ ale nechám na vás.</p>

<p class="autor">napsal: Jeff Molofee - NeHe <span class="transform_email">&lt;nehe (zavináè) connect.ab.ca&gt;</span><br />
pøelo¾il: Michal Turek - Woq <span class="transform_email">&lt;WOQ (zavináè) seznam.cz&gt;</span></p>

<h3 class="zdroj_kody_nadpis">Zdrojové kódy</h3>

<ul class="zdroj_kody">
<li><a href="http://nehe.gamedev.net/data/lessons/vc/lesson32.zip">Visual C++</a> kód této lekce.</li>
<li><a href="http://nehe.gamedev.net/data/lessons/bcb6/lesson32_bcb6.zip">Borland C++ Builder 6</a> kód této lekce. ( <a href="mailto:christian@tugzip.com">Christian Kindahl</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/cwarrior/lesson32.zip">Code Warrior 5.3</a> kód této lekce. ( <a href="mailto:DelusionalBeing@hotmail.com">Scott Lupton</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/delphi/lesson32.zip">Delphi</a> kód této lekce. ( <a href="mailto:Hugh@mikespike.freeserve.co.uk">Hugh Waite</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/devc/lesson32.zip">Dev C++</a> kód této lekce. ( <a href="mailto:danprogram@hotmail.com">Dan</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/euphoria/lesson32.zip">Euphoria</a> kód této lekce. ( <a href="mailto:1evan@sbcglobal.net">Evan Marshall</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/linuxsdl/lesson32.tar.gz">Linux/SDL</a> kód této lekce. ( <a href="mailto:edgarcostanzo@tiscalinet.it">Edgar Costanzo</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/macosxcocoa/lesson32.zip">Mac OS X/Cocoa</a> kód této lekce. ( <a href="mailto:blb@pobox.com">Bryan Blackburn</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/vs_net/lesson32.zip">Visual Studio .NET</a> kód této lekce. ( <a href="mailto:ultimatezeus@hotmail.com">Grant James</a> )</li>
</ul>

<div class="okolo_img"><img src="images/nehe_tut/tut_32_big.jpg" class="nehe_velky" alt="Lekce 32" /></div>
<p class="okolni_lekce"><a href="tut_31.php">&lt;&lt;&lt; Lekce 31</a> | <a href="tut_33.php">Lekce 33 &gt;&gt;&gt;</a></p>


<div class="netisk">
<h3 class="d_nadpis">Diskuze ke èlánku</h3>

<form action="d_view.php" method="post" class="d_o_obsah">

<div class="d_o_zprava">
<div class="d_o_jmeno">Centurion</div>
<div class="d_o_datumcas">28.10.2004 - 10:47:41</div>
<div>
<input type="checkbox" name="id_0" id="id_0" value="1" />
<span class="d_o_nadpis" style="margin-left: 0px;"><a href="d_view.php?f=tut_32.php&j=0">Maximálne 64 objektov?</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">.::]|DEAD|[::.Screamer</div>
<div class="d_o_datumcas">28.06.2005 - 19:50:09</div>
<div>
<input type="checkbox" name="id_1" id="id_1" value="1" />
<span class="d_o_nadpis" style="margin-left: 0px;"><a href="d_view.php?f=tut_32.php&j=1">polprimka(paprsek)</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">MP</div>
<div class="d_o_datumcas">08.07.2005 - 08:52:24</div>
<div>
<input type="checkbox" name="id_3" id="id_3" value="1" />
<span class="d_o_nadpis" style="margin-left: 20px;"><a href="d_view.php?f=tut_32.php&j=3">Re: polprimka(paprsek)</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">.::]|DEAD|[::.Screamer</div>
<div class="d_o_datumcas">08.07.2005 - 18:09:54</div>
<div>
<input type="checkbox" name="id_4" id="id_4" value="1" />
<span class="d_o_nadpis" style="margin-left: 40px;"><a href="d_view.php?f=tut_32.php&j=4">Re: polprimka(paprsek)</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">MP</div>
<div class="d_o_datumcas">09.07.2005 - 08:04:45</div>
<div>
<input type="checkbox" name="id_5" id="id_5" value="1" />
<span class="d_o_nadpis" style="margin-left: 60px;"><a href="d_view.php?f=tut_32.php&j=5">Re: polprimka(paprsek)</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">.::]|DEAD|[::.Screamer</div>
<div class="d_o_datumcas">10.07.2005 - 20:26:55</div>
<div>
<input type="checkbox" name="id_6" id="id_6" value="1" />
<span class="d_o_nadpis" style="margin-left: 80px;"><a href="d_view.php?f=tut_32.php&j=6">Re: polprimka(paprsek)</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">.::]|DEAD|[::.Screamer</div>
<div class="d_o_datumcas">10.07.2005 - 20:28:31</div>
<div>
<input type="checkbox" name="id_7" id="id_7" value="1" />
<span class="d_o_nadpis" style="margin-left: 100px;"><a href="d_view.php?f=tut_32.php&j=7">Re: polprimka(paprsek)</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">MP</div>
<div class="d_o_datumcas">17.07.2005 - 17:32:56</div>
<div>
<input type="checkbox" name="id_8" id="id_8" value="1" />
<span class="d_o_nadpis" style="margin-left: 120px;"><a href="d_view.php?f=tut_32.php&j=8">Re: polprimka(paprsek)</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">.::]|DEAD|[::.Screamer</div>
<div class="d_o_datumcas">26.07.2005 - 15:54:08</div>
<div>
<input type="checkbox" name="id_9" id="id_9" value="1" />
<span class="d_o_nadpis" style="margin-left: 140px;"><a href="d_view.php?f=tut_32.php&j=9">Re: polprimka(paprsek)</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">MP</div>
<div class="d_o_datumcas">08.07.2005 - 08:35:49</div>
<div>
<input type="checkbox" name="id_2" id="id_2" value="1" />
<span class="d_o_nadpis" style="margin-left: 0px;"><a href="d_view.php?f=tut_32.php&j=2">Picking a OpenGL souøadnice?</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">MP</div>
<div class="d_o_datumcas">25.08.2005 - 19:58:56</div>
<div>
<input type="checkbox" name="id_10" id="id_10" value="1" />
<span class="d_o_nadpis" style="margin-left: 0px;"><a href="d_view.php?f=tut_32.php&j=10">Díra po zásahu kulkou???</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">.::]|DEAD|[::.Screamer</div>
<div class="d_o_datumcas">26.08.2005 - 20:05:14</div>
<div>
<input type="checkbox" name="id_11" id="id_11" value="1" />
<span class="d_o_nadpis" style="margin-left: 20px;"><a href="d_view.php?f=tut_32.php&j=11">Re: Díra po zásahu kulkou???</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">MP</div>
<div class="d_o_datumcas">26.08.2005 - 20:47:01</div>
<div>
<input type="checkbox" name="id_12" id="id_12" value="1" />
<span class="d_o_nadpis" style="margin-left: 40px;"><a href="d_view.php?f=tut_32.php&j=12">Re: Díra po zásahu kulkou???</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">MP</div>
<div class="d_o_datumcas">29.08.2005 - 19:10:18</div>
<div>
<input type="checkbox" name="id_13" id="id_13" value="1" />
<span class="d_o_nadpis" style="margin-left: 0px;"><a href="d_view.php?f=tut_32.php&j=13">Z - úroveò polygonù</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">.::]|DEAD|[::.Screamer</div>
<div class="d_o_datumcas">29.08.2005 - 22:49:04</div>
<div>
<input type="checkbox" name="id_14" id="id_14" value="1" />
<span class="d_o_nadpis" style="margin-left: 20px;"><a href="d_view.php?f=tut_32.php&j=14">Re: Z - úroveò polygonù</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">MP</div>
<div class="d_o_datumcas">30.08.2005 - 06:15:40</div>
<div>
<input type="checkbox" name="id_15" id="id_15" value="1" />
<span class="d_o_nadpis" style="margin-left: 40px;"><a href="d_view.php?f=tut_32.php&j=15">Re: Z - úroveò polygonù</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">.::]|DEAD|[::.Screamer</div>
<div class="d_o_datumcas">30.08.2005 - 18:32:01</div>
<div>
<input type="checkbox" name="id_16" id="id_16" value="1" />
<span class="d_o_nadpis" style="margin-left: 60px;"><a href="d_view.php?f=tut_32.php&j=16">Re: Z - úroveò polygonù</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">Woq</div>
<div class="d_o_datumcas">28.09.2005 - 22:21:48</div>
<div>
<input type="checkbox" name="id_18" id="id_18" value="1" />
<span class="d_o_nadpis" style="margin-left: 80px;"><a href="d_view.php?f=tut_32.php&j=18">Re: Z - úroveò polygonù</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">MP</div>
<div class="d_o_datumcas">03.09.2005 - 12:18:07</div>
<div>
<input type="checkbox" name="id_17" id="id_17" value="1" />
<span class="d_o_nadpis" style="margin-left: 0px;"><a href="d_view.php?f=tut_32.php&j=17">Alfa razeni</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">Woq</div>
<div class="d_o_datumcas">28.09.2005 - 22:26:45</div>
<div>
<input type="checkbox" name="id_19" id="id_19" value="1" />
<span class="d_o_nadpis" style="margin-left: 20px;"><a href="d_view.php?f=tut_32.php&j=19">Re: Alfa razeni</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">.::]|DEAD|[::.Screamer</div>
<div class="d_o_datumcas">23.04.2006 - 19:17:48</div>
<div>
<input type="checkbox" name="id_20" id="id_20" value="1" />
<span class="d_o_nadpis" style="margin-left: 40px;"><a href="d_view.php?f=tut_32.php&j=20">Re: Alfa razeni</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">mp</div>
<div class="d_o_datumcas">24.04.2006 - 20:40:58</div>
<div>
<input type="checkbox" name="id_21" id="id_21" value="1" />
<span class="d_o_nadpis" style="margin-left: 60px;"><a href="d_view.php?f=tut_32.php&j=21">Re: Alfa razeni</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">.::]|DEAD|[::.Screamer</div>
<div class="d_o_datumcas">28.04.2006 - 21:27:32</div>
<div>
<input type="checkbox" name="id_22" id="id_22" value="1" />
<span class="d_o_nadpis" style="margin-left: 80px;"><a href="d_view.php?f=tut_32.php&j=22">Re: Alfa razeni</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">mp</div>
<div class="d_o_datumcas">29.04.2006 - 19:57:21</div>
<div>
<input type="checkbox" name="id_23" id="id_23" value="1" />
<span class="d_o_nadpis" style="margin-left: 100px;"><a href="d_view.php?f=tut_32.php&j=23">Re: Alfa razeni</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">k4r7m3n</div>
<div class="d_o_datumcas">31.08.2006 - 13:24:01</div>
<div>
<input type="checkbox" name="id_24" id="id_24" value="1" />
<span class="d_o_nadpis" style="margin-left: 0px;"><a href="d_view.php?f=tut_32.php&j=24">Xlib a cursor</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">k4r7m3n</div>
<div class="d_o_datumcas">02.09.2006 - 19:48:46</div>
<div>
<input type="checkbox" name="id_25" id="id_25" value="1" />
<span class="d_o_nadpis" style="margin-left: 20px;"><a href="d_view.php?f=tut_32.php&j=25">Re: Xlib a cursor</a></span>
</div>
</div>

<div class="okolo_img" style="margin-top: 20px;">
<input type="submit" name="zobrazit_vybrane" id="zobrazit_vybrane" value="Zobrazit vybrané" class="tlacitko" />
<input type="submit" name="zobrazit_vse" id="zobrazit_vse" value="Zobrazit v¹e" class="tlacitko" />
<input type="submit" name="vlozit_novy" id="vlozit_novy" value="Vlo¾it nový" class="tlacitko" />
<input type="hidden" name="f" id="f" value="tut_32.php" />
</div>
</form>
</div>
<!-- Informace o webu -->
<center><div id="informace">
<img src="images/my/woq.gif" width="60" height="60" align="left" alt="Woq logo" />
<div style="margin-left: 70px">
<div><strong>CZ NeHe OpenGL, v¹e o programování 3D grafiky</strong></div>
<div>Copyright &copy; 2002-2007 Michal Turek <span class="transform_email">&lt;WOQ (zavináè) seznam.cz&gt;</span></div>
<div style="margin-top: 5px">Komerèní publikování v ti¹tìné, elektronické nebo jiné podobì je bez výslovného souhlasu zakázáno. Redistribuce pro výukové úèely nebo osobní pou¾ití je v¹ak povolena.</div>
</div>
</div></center>
<!-- Informace o webu (konec) -->

</div>
<!-- Vlastní obsah stránky (konec) -->

<script src="http://c1.navrcholu.cz/code?site=56575;t=b14"
type="text/javascript"></script><noscript><div><a
href="http://navrcholu.cz/"><img
src="http://c1.navrcholu.cz/hit?site=56575;t=b14;ref=;jss=0"
width="14" height="14" alt="NAVRCHOLU.cz"
style="border:none" /></a></div></noscript>

</body>
</html>
