<?xml version="1.0" encoding="ISO-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">
<head>

<meta http-equiv="content-type" content="text/html; charset=ISO-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta http-equiv="content-script-type" content="text/javascript" />
<meta http-equiv="content-style-type" content="text/css" />

<meta name="robots" content="all, follow" />
<meta name="resource-type" content="document" />

<meta name="description" content="NeHe OpenGL Tutoriály v èe¹tinì, programování 3D grafiky, èlánky, programy se zdrojovými kódy..." />
<meta name="keywords" content="opengl, nehe, tutoriály, woq, programování, 3D" />
<meta name="author" content="all: Michal Turek - Woq; woq (zavináè) seznam.cz" />
<meta name="copyright" content="Copyright (c) 2002, 2003, 2004 Michal Turek - Woq" />

<title>CZ NeHe OpenGL - Lekce 33 - Nahrávání komprimovaných i nekomprimovaných obrázkù TGA</title>

<link rel="shortcut icon" href="skin/default/web.ico" type="image/x-icon" />
<link href="skin/default.css" rel="stylesheet" type="text/css" media="all" />
<link href="skin/print.css" rel="stylesheet" type="text/css" media="print" />

</head>

<body>

<!-- Levý sloupec -->
<div class="levy">
<div id="main_menu">
<a href="http://nehe.ceske-hry.cz/"><img src="skin/default/web_logo.gif" width="135" height="135" style="margin-left: 5px;" alt="CZ NeHe OpenGL" /></a>

<div class="main_menu_bez_loga">

<ul class="text_main_menu">
<li><a href="my.php" title="Pøekladatelé NeHe Tutoriálù a autoøi èlánkù">My</a></li>
<li><a href="novinky.php" title="Co je nového">Novinky</a></li>
<li><a href="navigacni_mapa.php" title="Pøehledná navigace na jednotlivé stránky, které dohromady tvoøí tento web">Navigaèní mapa</a></li>
<li><a href="kontakt.php" title="Kontakt na správce tohoto webu">Kontakt</a></li>
<li><a href="http://forum.programovani.com/" title="Diskusní fórum">Fórum</a></li>
</ul>

<ul class="text_main_menu">
<li><a href="clanky.php" title="Obsah èlánkù">Èlánky</a></li>
<li><a href="tut_obsah.php" title="Obsah NeHe OpenGL Tutoriálù">NeHe Tutoriály</a></li>
<li><a href="33D_index.php" title="Obsah Free3D (33D) Basecode">33D Basecode</a></li>
<li><a href="programy.php" title="Programy od èeských autorù">Èeské programy</a></li>
<li><a href="cl_gl_zacinam.php" title="Kde zaèít pøi uèení OpenGL">Pomoc, zaèínám</a></li>
<li><a href="odkazy.php" title="Jiné zdroje informací">Odkazy</a></li>
<li><a href="cl_gl_faq.php" title="FAQ: Èasto kladené dotazy">FAQ</a></li>
</ul>

<ul class="text_main_menu">
<li><a href="spoluprace.php" title="Nechcete se podílet na tvorbì tìchto webových stránek?">Spolupráce...?</a></li>
<li><a href="download.php" title="Stahujte">Download</a></li>
<li><a href="skiny.php" title="Nastavte si jiný layout a design stránek">Skiny</a></li>
<li><a href="javascript:window.print();" title="Vytiskne tuto stránku">Tisk</a></li>
</ul>

<ul class="text_main_menu">
<li>
<form action="p_fulltext.php" method="post" onsubmit="if(!this.najit.value || this.najit.value=='výraz ...') { alert('Byl zadán prázdný øetìzec!'); this.najit.focus(); return false; }">
<input type="text" name="najit" size="12" value="výraz ..." onclick="this.value=''" /><br />
<input type="submit" value="Najít" />
</form>
</li>
</ul>

<ul class="text_main_menu">
<li>Online ètenáøù: 2</li>
</ul>

</div>

</div>
</div>
<!-- Levý sloupec (konec) -->

<!-- Pravý sloupec -->
<div class="pravy">
<div id="tut_menu">

<ul class="text_tut_menu">
<li class="li_tut"><a href="tut_00.php" title="Lekce 0 - Pøedmluva k NeHe Tutoriálùm">00</a></li>
<li class="li_tut"><a href="tut_01.php" title="Lekce 1 - Vytvoøení OpenGL okna ve Windows">01</a></li>
<li class="li_tut"><a href="tut_02.php" title="Lekce 2 - Vytváøení trojúhelníkù a ètyøúhelníkù">02</a></li>
<li class="li_tut"><a href="tut_03.php" title="Lekce 3 - Barvy">03</a></li>
<li class="li_tut"><a href="tut_04.php" title="Lekce 4 - Rotace">04</a></li>
<li class="li_tut"><a href="tut_05.php" title="Lekce 5 - Pevné objekty">05</a></li>
<li class="li_tut"><a href="tut_06.php" title="Lekce 6 - Textury">06</a></li>
<li class="li_tut"><a href="tut_07.php" title="Lekce 7 - Texturové filtry, osvìtlení, ovládání pomocí klávesnice">07</a></li>
<li class="li_tut"><a href="tut_08.php" title="Lekce 8 - Blending">08</a></li>
<li class="li_tut"><a href="tut_09.php" title="Lekce 9 - Pohyb bitmap ve 3D prostoru">09</a></li>
<li class="li_tut"><a href="tut_10.php" title="Lekce 10 - Vytvoøení 3D svìta a pohyb v nìm">10</a></li>
<li class="li_tut"><a href="tut_11.php" title="Lekce 11 - Efekt vlnící se vlajky">11</a></li>
<li class="li_tut"><a href="tut_12.php" title="Lekce 12 - Display list">12</a></li>
<li class="li_tut"><a href="tut_13.php" title="Lekce 13 - Bitmapové fonty">13</a></li>
<li class="li_tut"><a href="tut_14.php" title="Lekce 14 - Outline fonty">14</a></li>
<li class="li_tut"><a href="tut_15.php" title="Lekce 15 - Mapování textur na fonty">15</a></li>
<li class="li_tut"><a href="tut_16.php" title="Lekce 16 - Mlha">16</a></li>
<li class="li_tut"><a href="tut_17.php" title="Lekce 17 - 2D fonty z textur">17</a></li>
<li class="li_tut"><a href="tut_18.php" title="Lekce 18 - Kvadriky">18</a></li>
<li class="li_tut"><a href="tut_19.php" title="Lekce 19 - Èásticové systémy">19</a></li>
<li class="li_tut"><a href="tut_20.php" title="Lekce 20 - Maskování">20</a></li>
<li class="li_tut"><a href="tut_21.php" title="Lekce 21 - Pøímky, antialiasing, èasování, pravoúhlá projekce, základní zvuky a jednoduchá herní logika">21</a></li>
<li class="li_tut"><a href="tut_22.php" title="Lekce 22 - Bump Mapping &amp; Multi Texturing">22</a></li>
<li class="li_tut"><a href="tut_23.php" title="Lekce 23 - Mapování textur na kulové kvadriky">23</a></li>
<li class="li_tut"><a href="tut_24.php" title="Lekce 24 - Výpis OpenGL roz¹íøení, oøezávací testy a textury z TGA obrázkù">24</a></li>
<li class="li_tut"><a href="tut_25.php" title="Lekce 25 - Morfování objektù a jejich nahrávání z textového souboru">25</a></li>
<li class="li_tut"><a href="tut_26.php" title="Lekce 26 - Odrazy a jejich oøezávání za pou¾ití stencil bufferu">26</a></li>
<li class="li_tut"><a href="tut_27.php" title="Lekce 27 - Stíny">27</a></li>
<li class="li_tut"><a href="tut_28.php" title="Lekce 28 - Bezierovy køivky a povrchy, fullscreen fix">28</a></li>
<li class="li_tut"><a href="tut_29.php" title="Lekce 29 - Blitter, nahrávání .RAW textur">29</a></li>
<li class="li_tut"><a href="tut_30.php" title="Lekce 30 - Detekce kolizí">30</a></li>
<li class="li_tut"><a href="tut_31.php" title="Lekce 31 - Nahrávání a renderování modelù">31</a></li>
<li class="li_tut"><a href="tut_32.php" title="Lekce 32 - Picking, alfa blending, alfa testing, sorting">32</a></li>
<li class="li_tut"><a href="tut_33.php" title="Lekce 33 - Nahrávání komprimovaných i nekomprimovaných obrázkù TGA">33</a></li>
<li class="li_tut"><a href="tut_34.php" title="Lekce 34 - Generování terénù a krajin za pou¾ití vý¹kového mapování textur">34</a></li>
<li class="li_tut"><a href="tut_35.php" title="Lekce 35 - Pøehrávání videa ve formátu AVI">35</a></li>
<li class="li_tut"><a href="tut_36.php" title="Lekce 36 - Radial Blur, renderování do textury">36</a></li>
<li class="li_tut"><a href="tut_37.php" title="Lekce 37 - Cel-Shading">37</a></li>
<li class="li_tut"><a href="tut_38.php" title="Lekce 38 - Nahrávání textur z resource souboru &amp; texturování trojúhelníkù">38</a></li>
<li class="li_tut"><a href="tut_39.php" title="Lekce 39 - Úvod do fyzikálních simulací">39</a></li>
<li class="li_tut"><a href="tut_40.php" title="Lekce 40 - Fyzikální simulace lana">40</a></li>
<li class="li_tut"><a href="tut_41.php" title="Lekce 41 - Volumetrická mlha a nahrávání obrázkù pomocí IPicture">41</a></li>
<li class="li_tut"><a href="tut_42.php" title="Lekce 42 - Více viewportù">42</a></li>
<li class="li_tut"><a href="tut_43.php" title="Lekce 43 - FreeType Fonty v OpenGL">43</a></li>
<li class="li_tut"><a href="tut_44.php" title="Lekce 44 - Èoèkové efekty">44</a></li>
<li class="li_tut"><a href="tut_45.php" title="Lekce 45 - Vertex Buffer Object (VBO)">45</a></li>
<li class="li_tut"><a href="tut_46.php" title="Lekce 46 - Fullscreenový antialiasing">46</a></li>
<li class="li_tut"><a href="tut_47.php" title="Lekce 47 - CG vertex shader">47</a></li>
<li class="li_tut"><a href="tut_48.php" title="Lekce 48 - ArcBall rotace">48</a></li>
</ul>

</div>
</div>
<!-- Pravý sloupec (konec) -->

<!-- Vlastní obsah stránky -->
<div class="stred">

<!--[if IE ]>
<div style="text-align: center;">
<a href="http://firefox.czilla.cz/"><img alt="Mozilla Firefox: Objevte znovu web" title="Mozilla Firefox: Objevte znovu web" style="border:none; width:468px;height:60px" src="http://firefox.czilla.cz/img/p/cz-ff-468x60-w-objevte.png" /></a>
</div>
<![endif]-->

<img src="images/nehe_tut/tut_33.jpg" class="nehe_maly" alt="Lekce 33" />

<h1>Lekce 33 - Nahrávání komprimovaných i nekomprimovaných obrázkù TGA</h1>

<p class="nadpis_clanku">V lekci 24 jsem vám ukázal cestu, jak nahrávat nekomprimované 24/32 bitové TGA obrázky. Jsou velmi u¾iteèné, kdy¾ potøebujete alfa kanál, ale nesmíte se starat o jejich velikost, proto¾e byste je ihned pøestali pou¾ívat. K diskovému místu nejsou zrovna ¹etrné. Problém velikosti vyøe¹í nahrávání obrázkù komprimovaných metodou RLE. Kód pro loading a hlavièkové soubory jsou oddìleny od hlavního projektu, aby mohly být snadno pou¾ity i jinde.</p>

<p>Zaèneme dvìma hlavièkový soubory. Texture.h, první z nich, popisuje strukturu textury. Ka¾dý hlavièkový soubor by mìl obsahovat ochranu proti vícenásobnému vlo¾ení. Zaji¹»ují ji pøíkazy preprocesoru jazyka C. Pokud není definovaná symbolická konstanta __TEXTURE_H__, nadefinujeme ji a do stejného bloku podmínky vepí¹eme zdrojový kód. Pøi následujícím pokusu o inkludování hlavièkového souboru existence konstanty oznámí preprocesoru, ¾e u¾ byl soubor jednou vlo¾en, a tudí¾ ho nemá vkládat podruhé.</p>

<p class="src0">#ifndef __TEXTURE_H__</p>
<p class="src0">#define __TEXTURE_H__</p>

<p>Budeme potøebovat strukturu informací o obrázku, ze kterého se vytváøí textura. Ukazatel imageData obsahuje data obrázku, bpp barevnou hloubku, width a height rozmìry. TexID je identifikátorem OpenGL textury, který se pøedává funkci glBindTexture(). Type urèuje typ textury - GL_RGB nebo GL_RGBA.</p>

<p class="src0">typedef struct<span class="kom">// Struktura textury</span></p>
<p class="src0">{</p>
<p class="src1">GLubyte* imageData;<span class="kom">// Data</span></p>
<p class="src1">GLuint bpp;<span class="kom">// Barevná hloubka v bitech</span></p>
<p class="src1">GLuint width;<span class="kom">// ©íøka</span></p>
<p class="src1">GLuint height;<span class="kom">// Vý¹ka</span></p>
<p class="src1">GLuint type;<span class="kom">// Typ (GL_RGB, GL_RGBA)</span></p>
<p class="src1">GLuint texID;<span class="kom">// ID textury</span></p>
<p class="src0">} Texture;</p>
<p></p>
<p class="src0">#endif</p>

<p>Druhý hlavièkový soubor, tga.h, je speciálnì urèen pro loading TGA. Opìt zaèneme o¹etøením vícenásobného inkludování, poté vlo¾íme hlavièkový soubor textury.</p>

<p class="src0">#ifndef __TGA_H__</p>
<p class="src0">#define __TGA_H__</p>
<p></p>
<p class="src0">#include &quot;texture.h&quot;<span class="kom">// Hlavièkový soubor textury</span></p>

<p>Strukturu TGAHeader pøedstavuje pole dvanácti bytù, které ukládají hlavièku obrázku. Druhá struktura obsahuje pomocné promìnné pro nahrávání - napø. velikost dat, barevnou hloubku a podobnì.</p>

<p class="src0">typedef struct<span class="kom">// Hlavièka TGA souboru</span></p>
<p class="src0">{</p>
<p class="src1">GLubyte Header[12];<span class="kom">// Dvanáct bytù</span></p>
<p class="src0">} TGAHeader;</p>
<p></p>
<p class="src0">typedef struct<span class="kom">// Struktura obrázku</span></p>
<p class="src0">{</p>
<p class="src1">GLubyte header[6];<span class="kom">// ©est u¾iteèných bytù z hlavièky</span></p>
<p class="src1">GLuint bytesPerPixel;<span class="kom">// Barevná hloubka v bytech</span></p>
<p class="src1">GLuint imageSize;<span class="kom">// Velikost pamìti pro obrázek</span></p>
<p class="src1"><span class="kom">// GLuint temp;// Pøekl.: nikde není pou¾itá</span></p>
<p class="src1">GLuint type;<span class="kom">// Typ</span></p>
<p class="src1">GLuint Height;<span class="kom">// Vý¹ka</span></p>
<p class="src1">GLuint Width;<span class="kom">// ©íøka</span></p>
<p class="src1">GLuint Bpp;<span class="kom">// Barevná hloubka v bitech</span></p>
<p class="src0">} TGA;</p>

<p>Deklarujeme instance právì vytvoøených struktur, abychom je mohli pou¾ít v programu.</p>

<p class="src0">TGAHeader tgaheader;<span class="kom">// TGA hlavièka</span></p>
<p class="src0">TGA tga;<span class="kom">// TGA obrázek</span></p>

<p>Následující dvì pole pomohou urèit validitu nahrávaného souboru. Pokud se hlavièka obrázku neshoduje s nìkterou z nich, neumíme ho nahrát.</p>

<p class="src0">GLubyte uTGAcompare[12] = { 0,0, 2,0,0,0,0,0,0,0,0,0 };<span class="kom">// TGA hlavièka nekomprimovaného obrázku</span></p>
<p class="src0">GLubyte cTGAcompare[12] = { 0,0,10,0,0,0,0,0,0,0,0,0 };<span class="kom">// TGA hlavièka komprimovaného obrázku</span></p>

<p>Obì funkce nahrávají TGA - jedna nekomprimovaný druhá komprimovaný.</p>

<p class="src0">bool LoadUncompressedTGA(Texture*, char*, FILE*);<span class="kom">// Nekomprimovaný TGA</span></p>
<p class="src0">bool LoadCompressedTGA(Texture*, char*, FILE*);<span class="kom">// Komprimovaný TGA</span></p>
<p></p>
<p class="src0">#endif</p>

<p>Pøesuneme se k souboru TGALoader.cpp, který implementuje nahrávací funkce. Prvním øádkem kódu vlo¾íme hlavièkový soubor. Inkludujeme pouze tga.h, proto¾e texture.h jsme u¾ vlo¾ili v nìm.</p>

<p class="src0">#include &quot;tga.h&quot;<span class="kom">// Hlavièkový soubor TGA</span></p>

<p>Funkce LoadTGA() je ta, kterou v programu voláme, abychom nahráli obrázek. V parametrech se jí pøedává ukazatel na texturu a øetìzec diskové cesty. Nic dal¹ího nepotøebuje, proto¾e si v¹echny ostatní parametry detekuje sama (ze souboru). Deklarujeme handle souboru a otevøeme ho pro ètení v binárním módu. Pokud nìco sel¾e, napø. soubor neexistuje, vypí¹eme chybovou zprávu a vrátíme false jako indikaci chyby.</p>

<p class="src0">bool LoadTGA(Texture* texture, char* filename)<span class="kom">// Nahraje TGA soubor</span></p>
<p class="src0">{</p>
<p class="src1">FILE* fTGA;<span class="kom">// Handle souboru</span></p>
<p class="src1">fTGA = fopen(filename, &quot;rb&quot;);<span class="kom">// Otevøe soubor</span></p>
<p></p>
<p class="src1">if(fTGA == NULL)<span class="kom">// Nepodaøilo se ho otevøít?</span></p>
<p class="src1">{</p>
<p class="src2">MessageBox(NULL, &quot;Could not open texture file&quot;, &quot;ERROR&quot;, MB_OK);</p>
<p class="src2">return false;</p>
<p class="src1">}</p>

<p>Zkusíme naèíst hlavièku obrázku (prvních 12 bytù souboru), která urèuje jeho typ. Výsledek se ulo¾í do promìnné tgaheader.</p>

<p class="src1">if(fread(&amp;tgaheader, sizeof(TGAHeader), 1, fTGA) == 0)<span class="kom">// Naète hlavièku souboru</span></p>
<p class="src1">{</p>
<p class="src2">MessageBox(NULL, &quot;Could not read file header&quot;, &quot;ERROR&quot;, MB_OK);</p>
<p></p>
<p class="src2">if(fTGA != NULL)</p>
<p class="src2">{</p>
<p class="src3">fclose(fTGA);</p>
<p class="src2">}</p>
<p></p>
<p class="src2">return false;</p>
<p class="src1">}</p>

<p>Právì naètenou hlavièku porovnáme s hlavièkou nekomprimovaného obrázku. Jsou-li shodné nahrajeme obrázek funkcí LoadUncompressedTGA(). Pokud shodné nejsou zkusíme, jestli se nejedná o komprimovaný obrázek. V tomto pøípadì pou¾ijeme pro nahrávání funkci LoadCompressedTGA(). S jinými typy souborù pracovat neumíme, tak¾e jediné, co mù¾eme udìlat, je oznámení neúspìchu a ukonèení funkce.</p>

<p>Pøekl.: Mìla by se je¹tì testovat návratová hodnota, proto¾e, jak uvidíte dále, funkce v mnoha pøípadech vracejí false. Program by si bez kontroly nièeho nev¹iml a pokraèoval dále.</p>

<p class="src1">if(memcmp(uTGAcompare, &amp;tgaheader, sizeof(tgaheader)) == 0)<span class="kom">// Nekomprimovaný</span></p>
<p class="src1">{</p>
<p class="src2">LoadUncompressedTGA(texture, filename, fTGA);</p>
<p></p>
<p class="src2"><span class="kom">// Pøekl.: Testovat návratovou hodnotu !!!</span></p>
<p class="src2"><span class="kom">// if(!LoadUncompressedTGA(texture, filename, fTGA))// Test návratové hodnoty</span></p>
<p class="src2"><span class="kom">// {</span></p>
<p class="src3"><span class="kom">// return false;</span></p>
<p class="src2"><span class="kom">// }</span></p>
<p class="src1">}</p>
<p class="src1">else if(memcmp(cTGAcompare, &amp;tgaheader, sizeof(tgaheader)) == 0)<span class="kom">// Komprimovaný</span></p>
<p class="src1">{</p>
<p class="src2">LoadCompressedTGA(texture, filename, fTGA);</p>
<p></p>
<p class="src2"><span class="kom">// Pøekl.: Testovat návratovou hodnotu !!!</span></p>
<p class="src2"><span class="kom">// if(!LoadCompressedTGA(texture, filename, fTGA))// Test návratové hodnoty</span></p>
<p class="src2"><span class="kom">// {</span></p>
<p class="src3"><span class="kom">// return false;</span></p>
<p class="src2"><span class="kom">// }</span></p>
<p class="src1">}</p>
<p class="src1">else<span class="kom">// Ani jeden z nich</span></p>
<p class="src1">{</p>
<p class="src2">MessageBox(NULL, &quot;TGA file be type 2 or type 10 &quot;, &quot;Invalid Image&quot;, MB_OK);</p>
<p class="src2">fclose(fTGA);</p>
<p class="src2">return false;</p>
<p class="src1">}</p>

<p>Pokud dosud nenastala ¾ádná chyba, mù¾eme oznámit volajícímu kódu, ¾e obrázek byl v poøádku nahrán a ¾e mù¾e z jeho dat vytvoøit texturu.</p>

<p class="src1">return true;<span class="kom">// V¹e v poøádku</span></p>
<p class="src0">}</p>

<p>Pøistoupíme k opravdovému nahrávání obrázkù, zaèneme nekomprimovanými. Tato funkce je z velké èásti zalo¾ena na té z lekce 24, moc novinek v ní nenajdete. Zkusíme naèíst dal¹ích ¹est bytù ze souboru a ulo¾íme je do tga.header.</p>

<p class="src0">bool LoadUncompressedTGA(Texture* texture, char* filename, FILE* fTGA)<span class="kom">// Nahraje nekomprimovaný TGA</span></p>
<p class="src0">{</p>
<p class="src1">if(fread(tga.header, sizeof(tga.header), 1, fTGA) == 0)<span class="kom">// ©est u¾iteèných bytù</span></p>
<p class="src1">{</p>
<p class="src2">MessageBox(NULL, &quot;Could not read info header&quot;, &quot;ERROR&quot;, MB_OK);</p>
<p></p>
<p class="src2">if(fTGA != NULL)</p>
<p class="src2">{</p>
<p class="src3">fclose(fTGA);</p>
<p class="src2">}</p>
<p></p>
<p class="src2">return false;</p>
<p class="src1">}</p>

<p>Máme dost informací pro urèení vý¹ky, ¹íøky a barevné hloubky obrázku. Ulo¾íme je do obou struktur - textury i obrázku.</p>

<p class="src1">texture-&gt;width = tga.header[1] * 256 + tga.header[0];<span class="kom">// ©íøka</span></p>
<p class="src1">texture-&gt;height = tga.header[3] * 256 + tga.header[2];<span class="kom">// Vý¹ka</span></p>
<p class="src1">texture-&gt;bpp = tga.header[4];<span class="kom">// Barevná hloubka v bitech</span></p>
<p></p>
<p class="src1"><span class="kom">// Kopírování dat do struktury obrázku</span></p>
<p class="src1">tga.Width = texture-&gt;width;</p>
<p class="src1">tga.Height = texture-&gt;height;</p>
<p class="src1">tga.Bpp = texture-&gt;bpp;</p>

<p>Otestujeme, jestli má obrázek alespoò jeden pixel a jestli je barevná hloubka 24 nebo 32 bitù.</p>

<p class="src1"><span class="kom">// Platné hodnoty?</span></p>
<p class="src1">if((texture-&gt;width &lt;= 0) || (texture-&gt;height &lt;= 0) || ((texture-&gt;bpp != 24) &amp;&amp; (texture-&gt;bpp != 32)))</p>
<p class="src1">{</p>
<p class="src2">MessageBox(NULL, &quot;Invalid texture information&quot;, &quot;ERROR&quot;, MB_OK);</p>
<p class="src2"></p>
<p class="src2">if(fTGA != NULL)</p>
<p class="src2">{</p>
<p class="src3">fclose(fTGA);</p>
<p class="src2">}</p>
<p></p>
<p class="src2">return false;</p>
<p class="src1">}</p>

<p>Nyní nastavíme typ obrázku. V pøípadì 24 bitù je jím GL_RGB, u 32 bitù má obrázek i alfa kanál, tak¾e pou¾ijeme GL_RGBA.</p>

<p class="src1">if(texture-&gt;bpp == 24)<span class="kom">// 24 bitový obrázek?</span></p>
<p class="src1">{</p>
<p class="src2">texture-&gt;type = GL_RGB;</p>
<p class="src1">}</p>
<p class="src1">else<span class="kom">// 32 bitový obrázek</span></p>
<p class="src1">{</p>
<p class="src2">texture-&gt;type = GL_RGBA;</p>
<p class="src1">}</p>

<p>Spoèítáme barevnou hloubku v BYTECH a celkovou velikost pamìti potøebnou pro data. Vzápìtí se ji pokusíme alokovat.</p>

<p class="src1">tga.bytesPerPixel = (tga.Bpp / 8);<span class="kom">// BYTY na pixel</span></p>
<p class="src1">tga.imageSize = (tga.bytesPerPixel * tga.Width * tga.Height);<span class="kom">// Velikost pamìti</span></p>
<p></p>
<p class="src1">texture-&gt;imageData = (GLubyte *)malloc(tga.imageSize);<span class="kom">// Alokace pamìti pro data</span></p>
<p></p>
<p class="src1">if(texture-&gt;imageData == NULL)<span class="kom">// Alokace neúspì¹ná</span></p>
<p class="src1">{</p>
<p class="src2">MessageBox(NULL, &quot;Could not allocate memory for image&quot;, &quot;ERROR&quot;, MB_OK);</p>
<p class="src2">fclose(fTGA);</p>
<p class="src2">return false;</p>
<p class="src1">}</p>

<p>Pokud se podaøila alokace pamìti, nahrajeme do ní data obrázku.</p>

<p class="src1"><span class="kom">// Pokusí se nahrát data obrázku</span></p>
<p class="src1">if(fread(texture-&gt;imageData, 1, tga.imageSize, fTGA) != tga.imageSize)</p>
<p class="src1">{</p>
<p class="src2">MessageBox(NULL, &quot;Could not read image data&quot;, &quot;ERROR&quot;, MB_OK);</p>
<p></p>
<p class="src2">if(texture-&gt;imageData != NULL)</p>
<p class="src2">{</p>
<p class="src3">free(texture-&gt;imageData);<span class="kom">// Uvolnìní pamìti</span></p>
<p class="src2">}</p>
<p></p>
<p class="src2">fclose(fTGA);</p>
<p class="src2">return false;</p>
<p class="src1">}</p>

<p>Formát TGA se od formátu OpenGL li¹í tím, ¾e má v pixelech pøehozené R a B slo¾ky barvy (BGR místo RGB). Musíme tedy zamìnit první a tøetí byte v ka¾dém pixelu. Abychom tuto operace urychlili, provedeme tøi binární operace XOR. Výsledek je stejný jako pøi pou¾ití pomocné promìnné.</p>

<p class="src1"><span class="kom">// Pøevod BGR na RGB</span></p>
<p class="src1">for(GLuint cswap = 0; cswap &lt; (int)tga.imageSize; cswap += tga.bytesPerPixel)</p>
<p class="src1">{</p>
<p class="src2">texture-&gt;imageData[cswap] ^= texture-&gt;imageData[cswap+2] ^=</p>
<p class="src2">texture-&gt;imageData[cswap] ^= texture-&gt;imageData[cswap+2];</p>
<p class="src1">}</p>

<p>Obrázek jsme úspì¹nì nahráli, tak¾e zavøeme soubor a vrácením true oznámíme úspìch.</p>

<p class="src1">fclose(fTGA);<span class="kom">// Zavøení souboru</span></p>
<p class="src1">return true;<span class="kom">// Úspìch</span></p>
<p></p>
<p class="src1"><span class="kom">// Pamì» dat obrázku se uvolòuje a¾ po vytvoøení textury</span></p>
<p class="src0">}</p>

<p>Nyní pøistoupíme k nahrávání obrázku komprimovaného metodou RLE (RunLength Encoded). Zaèátek je stejný jako u nekomprimovaného obrázku - naèteme vý¹ku, ¹íøku a barevnou hloubku, o¹etøíme neplatné hodnoty a spoèítáme velikost potøebné pamìti, kterou opìt alokujeme. V¹imnìte si, ¾e velikost po¾adované pamìti je taková, aby do ní mohla být ulo¾ena data PO DEKOMPRIMOVÁNÍ, ne pøed dekomprimováním.</p>

<p class="src0">bool LoadCompressedTGA(Texture* texture, char* filename, FILE* fTGA)<span class="kom">// Nahraje komprimovaný obrázek</span></p>
<p class="src0">{ </p>
<p class="src1">if(fread(tga.header, sizeof(tga.header), 1, fTGA) == 0)<span class="kom">// ©est u¾iteèných bytù</span></p>
<p class="src1">{</p>
<p class="src2">MessageBox(NULL, &quot;Could not read info header&quot;, &quot;ERROR&quot;, MB_OK);</p>
<p></p>
<p class="src2">if(fTGA != NULL)</p>
<p class="src2">{</p>
<p class="src3">fclose(fTGA);</p>
<p class="src2">}</p>
<p></p>
<p class="src2">return false;</p>
<p class="src1">}</p>
<p></p>
<p class="src1">texture-&gt;width = tga.header[1] * 256 + tga.header[0];<span class="kom">// ©íøka</span></p>
<p class="src1">texture-&gt;height = tga.header[3] * 256 + tga.header[2];<span class="kom">// Vý¹ka</span></p>
<p class="src1">texture-&gt;bpp = tga.header[4];<span class="kom">// Barevná hloubka v bitech</span></p>
<p></p>
<p class="src1"><span class="kom">// Kopírování dat do struktury obrázku</span></p>
<p class="src1">tga.Width = texture-&gt;width;</p>
<p class="src1">tga.Height = texture-&gt;height;</p>
<p class="src1">tga.Bpp = texture-&gt;bpp;</p>
<p></p>
<p class="src1"><span class="kom">// Platné hodnoty?</span></p>
<p class="src1">if((texture-&gt;width &lt;= 0) || (texture-&gt;height &lt;= 0) || ((texture-&gt;bpp != 24) &amp;&amp; (texture-&gt;bpp != 32)))</p>
<p class="src1">{</p>
<p class="src2">MessageBox(NULL, &quot;Invalid texture information&quot;, &quot;ERROR&quot;, MB_OK);</p>
<p class="src2"></p>
<p class="src2">if(fTGA != NULL)</p>
<p class="src2">{</p>
<p class="src3">fclose(fTGA);</p>
<p class="src2">}</p>
<p></p>
<p class="src2">return false;</p>
<p class="src1">}</p>
<p></p>
<p class="src1">if(texture-&gt;bpp == 24)<span class="kom">// 24 bitový obrázek?</span></p>
<p class="src1">{</p>
<p class="src2">texture-&gt;type = GL_RGB;</p>
<p class="src1">}</p>
<p class="src1">else<span class="kom">// 32 bitový obrázek</span></p>
<p class="src1">{</p>
<p class="src2">texture-&gt;type = GL_RGBA;</p>
<p class="src1">}</p>
<p></p>
<p class="src1">tga.bytesPerPixel = (tga.Bpp / 8);<span class="kom">// BYTY na pixel</span></p>
<p class="src1">tga.imageSize = (tga.bytesPerPixel * tga.Width * tga.Height);<span class="kom">// Velikost pamìti</span></p>
<p></p>
<p class="src1">texture-&gt;imageData = (GLubyte *)malloc(tga.imageSize);<span class="kom">// Alokace pamìti pro data (po dekomprimování)</span></p>
<p></p>
<p class="src1">if(texture-&gt;imageData == NULL)<span class="kom">// Alokace neúspì¹ná</span></p>
<p class="src1">{</p>
<p class="src2">MessageBox(NULL, &quot;Could not allocate memory for image&quot;, &quot;ERROR&quot;, MB_OK);</p>
<p class="src2">fclose(fTGA);</p>
<p class="src2">return false;</p>
<p class="src1">}</p>

<p>Dále potøebujeme zjistit pøesný poèet pixelù, ze kterých je obrázek slo¾en. Jednodu¹e vynásobíme vý¹ku obrázku se ¹íøkou. Také musíme znát, na kterém pixelu se právì nacházíme a kam do pamìti zapisujeme.</p>

<p class="src1">GLuint pixelcount = tga.Height * tga.Width;<span class="kom">// Poèet pixelù</span></p>
<p class="src1">GLuint currentpixel = 0;<span class="kom">// Aktuální naèítaný pixel</span></p>
<p class="src1">GLuint currentbyte = 0;<span class="kom">// Aktuální naèítaný byte</span></p>

<p>Alokujeme pomocné pole tøí nebo ètyø bytù (podle barevné hloubky) k ulo¾ení jednoho pixelu. Pøekl.: Mìla by se testovat správnost alokace pamìti!</p>

<p class="src1">GLubyte* colorbuffer = (GLubyte *)malloc(tga.bytesPerPixel);<span class="kom">// Pamì» pro jeden pixel</span></p>
<p></p>
<p class="src1"><span class="kom">// Pøekl.: Test úspì¹nosti alokace pamìti !!!</span></p>
<p class="src1"><span class="kom">// if(colorbuffer == NULL)// Alokace neúspì¹ná</span></p>
<p class="src1"><span class="kom">// {</span></p>
<p class="src2"><span class="kom">// MessageBox(NULL, &quot;Could not allocate memory for color buffer&quot;, &quot;ERROR&quot;, MB_OK);</span></p>
<p class="src2"><span class="kom">// fclose(fTGA);</span></p>
<p class="src2"><span class="kom">// return false;</span></p>
<p class="src1"><span class="kom">// }</span></p>

<p>V hlavním cyklu deklarujeme promìnnou k ulo¾ení bytu hlavièky, který definuje, jestli je následující sekce obrázku ve formátu RAW nebo RLE a jak dlouhá je. Pokud je byte hlavièky men¹í nebo roven 127, jedná se o RAW hlavièku. Hodnota v ní ulo¾ená, urèuje poèet pixelù mínus jedna, které vzápìtí naèteme a zkopírujeme do pamìti. Po tìchto pixelech se v souboru vyskytuje dal¹í byte hlavièky. Pokud je byte hlavièky vìt¹í ne¾ 127, pøedstavuje toto èíslo (zmen¹ené o 127), kolikrát se má následující pixel v dekomprimovaném obrázku opakovat. Hned po nìm se bude vyskytovat dal¹í hlavièkový byte. Naèteme hodnoty tohoto pixelu a zkopírujeme ho do imageData tolikrát, kolikrát potøebujeme.</p>

<p>Podstatu komprese RLE tedy u¾ znáte, podívejme se na kód. Jak jsem ji¾ zmínil, zalo¾íme cyklus pøes celý soubor a pokusíme se naèíst byte první hlavièky.</p>

<p class="src1">do<span class="kom">// Prochází celý soubor</span></p>
<p class="src1">{</p>
<p class="src2">GLubyte chunkheader = 0;<span class="kom">// Byte hlavièky</span></p>
<p></p>
<p class="src2">if(fread(&amp;chunkheader, sizeof(GLubyte), 1, fTGA) == 0)<span class="kom">// Naète byte hlavièky</span></p>
<p class="src2">{</p>
<p class="src3">MessageBox(NULL, &quot;Could not read RLE header&quot;, &quot;ERROR&quot;, MB_OK);</p>
<p></p>
<p class="src3">if(fTGA != NULL)</p>
<p class="src3">{</p>
<p class="src4">fclose(fTGA);</p>
<p class="src3">}</p>
<p></p>
<p class="src3">if(texture-&gt;imageData != NULL)</p>
<p class="src3">{</p>
<p class="src4">free(texture-&gt;imageData);</p>
<p class="src3">}</p>
<p></p>
<p class="src3"><span class="kom">// Pøekl.: Uvolnìní dynamické pamìti !!!</span></p>
<p class="src3"><span class="kom">// if(colorbuffer != NULL)</span></p>
<p class="src3"><span class="kom">// {</span></p>
<p class="src4"><span class="kom">// free(colorbuffer);</span></p>
<p class="src3"><span class="kom">// }</span></p>
<p></p>
<p class="src3">return false;</p>
<p class="src2">}</p>

<p>Pokud se jedná o RAW hlavièku, pøièteme k bytu jednièku, abychom získali poèet pixelù následujících po hlavièce. Potom zalo¾íme dal¹í cyklus, který naèítá v¹echny po¾adovaného pixely do pomocného pole colorbuffer a vzápìtí je ve správném formátu ukládá do imageData.</p>

<p class="src2">if(chunkheader &lt; 128)<span class="kom">// RAW èást obrázku</span></p>
<p class="src2">{</p>
<p class="src3">chunkheader++;<span class="kom">// Poèet pixelù v sekci pøed výskytem dal¹ího bytu hlavièky</span></p>
<p></p>
<p class="src3">for(short counter = 0; counter &lt; chunkheader; counter++)<span class="kom">// Jednotlivé pixely</span></p>
<p class="src3">{</p>
<p class="src4"><span class="kom">// Naèítání po jednom pixelu</span></p>
<p class="src4">if(fread(colorbuffer, 1, tga.bytesPerPixel, fTGA) != tga.bytesPerPixel)</p>
<p class="src4">{</p>
<p class="src5">MessageBox(NULL, &quot;Could not read image data&quot;, &quot;ERROR&quot;, MB_OK);</p>
<p></p>
<p class="src5">if(fTGA != NULL)</p>
<p class="src5">{</p>
<p class="src6">fclose(fTGA);</p>
<p class="src5">}</p>
<p></p>
<p class="src5">if(colorbuffer != NULL)</p>
<p class="src5">{</p>
<p class="src6">free(colorbuffer);</p>
<p class="src5">}</p>
<p></p>
<p class="src5">if(texture-&gt;imageData != NULL)</p>
<p class="src5">{</p>
<p class="src6">free(texture-&gt;imageData);</p>
<p class="src5">}</p>
<p></p>
<p class="src5">return false;</p>
<p class="src4">}</p>

<p>Pøi kopírování do imageData prohodíme poøadí bytù z formátu BGR na RGB. Pokud je v obrázku i alfa kanál, zkopírujeme i ètvrtý byte. Abychom se pøesunuli na dal¹í pixel popø. byte hlavièky, zvìt¹íme aktuální byte o barevnou hloubku (+3 nebo +4). Inkrementujeme také poèet naètených pixelù.</p>

<p class="src4"><span class="kom">// Zápis do pamìti, prohodí R a B slo¾ku barvy</span></p>
<p class="src4">texture-&gt;imageData[currentbyte] = colorbuffer[2];</p>
<p class="src4">texture-&gt;imageData[currentbyte + 1] = colorbuffer[1];</p>
<p class="src4">texture-&gt;imageData[currentbyte + 2] = colorbuffer[0];</p>
<p></p>
<p class="src4">if(tga.bytesPerPixel == 4)<span class="kom">// 32 bitový obrázek?</span></p>
<p class="src4">{</p>
<p class="src5">texture-&gt;imageData[currentbyte + 3] = colorbuffer[3];<span class="kom">// Kopírování alfy</span></p>
<p class="src4">}</p>
<p></p>
<p class="src4">currentbyte += tga.bytesPerPixel;<span class="kom">// Aktualizuje byte</span></p>
<p class="src4">currentpixel++;<span class="kom">// Pøesun na dal¹í pixel</span></p>

<p>Zjistíme, jestli je poøadová èíslo aktuálního pixelu vìt¹í ne¾ celkový poèet pixelù. Pokud ano, je soubor obrázku po¹kozen nebo je v nìm nìkde chyba. Jak jsme na to pøi¹li? Máme naèítat dal¹í pixel, ale defakto je u¾ máme v¹echny naètené, proto¾e aktuální hodnota je vìt¹í ne¾ maximální. Nestaèila by alokovaná pamì» pro dekomprimovanou verzi obrázku. Tuto skuteènost musíme ka¾dopádnì o¹etøit.</p>

<p class="src4">if(currentpixel &gt; pixelcount)<span class="kom">// Jsme za hranicí obrázku?</span></p>
<p class="src4">{</p>
<p class="src5">MessageBox(NULL, &quot;Too many pixels read&quot;, &quot;ERROR&quot;, NULL);</p>
<p></p>
<p class="src5">if(fTGA != NULL)</p>
<p class="src5">{</p>
<p class="src6">fclose(fTGA);</p>
<p class="src5">}</p>
<p></p>
<p class="src5">if(colorbuffer != NULL)</p>
<p class="src5">{</p>
<p class="src6">free(colorbuffer);</p>
<p class="src5">}</p>
<p></p>
<p class="src5">if(texture-&gt;imageData != NULL)</p>
<p class="src5">{</p>
<p class="src6">free(texture-&gt;imageData);</p>
<p class="src5">}</p>
<p></p>
<p class="src5">return false;</p>
<p class="src4">}</p>
<p class="src3">}</p>
<p class="src2">}</p>

<p>Vyøe¹ili jsme èást RAW, nyní implementujeme sekci RLE. Ze v¹eho nejdøíve od bytu hlavièky odeèteme èíslo 127, abychom získali kolikrát se má následující pixel opakovat.</p>

<p class="src2">else<span class="kom">// RLE èást obrázku</span></p>
<p class="src2">{</p>
<p class="src3">chunkheader -= 127;<span class="kom">// Poèet pixelù v sekci</span></p>

<p>Naèteme jeden pixel po hlavièce a potom ho po¾adovanì-krát vlo¾íme do imageData. Opìt zamìòujeme formát BGR za RGB. Stejnì jako minule inkrementujeme aktuální byte i pixel a o¹etøujeme pøeteèení.</p>

<p class="src3">if(fread(colorbuffer, 1, tga.bytesPerPixel, fTGA) != tga.bytesPerPixel)<span class="kom">// Naète jeden pixel</span></p>
<p class="src3">{</p>
<p class="src4">MessageBox(NULL, &quot;Could not read from file&quot;, &quot;ERROR&quot;, MB_OK);</p>
<p></p>
<p class="src4">if(fTGA != NULL)</p>
<p class="src4">{</p>
<p class="src5">fclose(fTGA);</p>
<p class="src4">}</p>
<p></p>
<p class="src4">if(colorbuffer != NULL)</p>
<p class="src4">{</p>
<p class="src5">free(colorbuffer);</p>
<p class="src4">}</p>
<p></p>
<p class="src4">if(texture-&gt;imageData != NULL)</p>
<p class="src4">{</p>
<p class="src5">free(texture-&gt;imageData);</p>
<p class="src4">}</p>
<p></p>
<p class="src4">return false;</p>
<p class="src3">}</p>
<p></p>
<p class="src3">for(short counter = 0; counter &lt; chunkheader; counter++)<span class="kom">// Kopírování pixelu</span></p>
<p class="src3">{</p>
<p class="src4"><span class="kom">// Zápis do pamìti, prohodí R a B slo¾ku barvy</span></p>
<p class="src4">texture-&gt;imageData[currentbyte] = colorbuffer[2];</p>
<p class="src4">texture-&gt;imageData[currentbyte + 1] = colorbuffer[1];</p>
<p class="src4">texture-&gt;imageData[currentbyte + 2] = colorbuffer[0];</p>
<p></p>
<p class="src4">if(tga.bytesPerPixel == 4)<span class="kom">// 32 bitový obrázek?</span></p>
<p class="src4">{</p>
<p class="src5">texture-&gt;imageData[currentbyte + 3] = colorbuffer[3];<span class="kom">// Kopírování alfy</span></p>
<p class="src4">}</p>
<p></p>
<p class="src4">currentbyte += tga.bytesPerPixel;<span class="kom">// Aktualizuje byte</span></p>
<p class="src4">currentpixel++;<span class="kom">// Pøesun na dal¹í pixel</span></p>
<p></p>
<p class="src4">if(currentpixel &gt; pixelcount)<span class="kom">// Jsme za hranicí obrázku?</span></p>
<p class="src4">{</p>
<p class="src5">MessageBox(NULL, &quot;Too many pixels read&quot;, &quot;ERROR&quot;, NULL);</p>
<p></p>
<p class="src5">if(fTGA != NULL)</p>
<p class="src5">{</p>
<p class="src6">fclose(fTGA);</p>
<p class="src5">}</p>
<p></p>
<p class="src5">if(colorbuffer != NULL)</p>
<p class="src5">{</p>
<p class="src6">free(colorbuffer);</p>
<p class="src5">}</p>
<p></p>
<p class="src5">if(texture-&gt;imageData != NULL)</p>
<p class="src5">{</p>
<p class="src6">free(texture-&gt;imageData);</p>
<p class="src5">}</p>
<p></p>
<p class="src5">return false;</p>
<p class="src4">}</p>
<p class="src3">}</p>
<p class="src2">}</p>

<p>Hlavní cyklus opakujeme tak dlouho, dokud v souboru zbývají nenaètené pixely. Po konci loadingu soubor zavøeme a vrácením true indikujeme úspìch.</p>

<p class="src1">} while(currentpixel &lt; pixelcount);<span class="kom">// Pokraèuj dokud zbývají pixely</span></p>
<p></p>
<p class="src1"><span class="kom">// Pøekl.: Uvolnìní dynamické pamìti !!!</span></p>
<p class="src1"><span class="kom">// if(colorbuffer != NULL)</span></p>
<p class="src1"><span class="kom">// {</span></p>
<p class="src2"><span class="kom">// free(colorbuffer);</span></p>
<p class="src1"><span class="kom">// }</span></p>
<p></p>
<p class="src1">fclose(fTGA);<span class="kom">// Zavøení souboru</span></p>
<p class="src1">return true;<span class="kom">// Úspìch</span></p>
<p></p>
<p class="src1"><span class="kom">// Pamì» dat obrázku se uvolòuje a¾ po vytvoøení textury</span></p>
<p class="src0">}</p>

<p>Nyní jsou data obrázku pøipravena pro vytvoøení textury a to u¾ jistì zvládnete sami. V tomto tutoriálu nám ¹lo pøedev¹ím o nahrávání TGA obrázkù. Ukázkové demo bylo vytvoøeno jen proto, abyste vidìli, ¾e kód opravdu funguje.</p>

<p>A jak je to s úspì¹ností komprimace metody RLE? Je jasné, ¾e nejmen¹í pamì» bude zabírat obrázek s rozsáhlými plochami stejných pixelù (na øádcích). Pokud chcete èísla, tak si vezmeme na pomoc obrázky pou¾ité v tomto demu: oba jsou 128x128 pixelù veliké, nekomprimovaný zabírá na disku 48,0 kB a komprimovaný pouze 5,29 kB. Na obou je sice nìco jiného, ale devítinásobné zmen¹ení velikosti mluví za v¹e.</p>

<p class="autor">napsal: Evan Pipho - Terminate <span class="transform_email">&lt;terminate (zavináè) gdnmail.net&gt;</span><br />
pøelo¾il: Michal Turek - Woq <span class="transform_email">&lt;WOQ (zavináè) seznam.cz&gt;</span></p>

<h3 class="zdroj_kody_nadpis">Zdrojové kódy</h3>

<ul class="zdroj_kody">
<li><a href="http://nehe.gamedev.net/data/lessons/vc/lesson33.zip">Visual C++</a> kód této lekce.</li>
<li><a href="http://nehe.gamedev.net/data/lessons/bcb6/lesson33_bcb6.zip">Borland C++ Builder 6</a> kód této lekce. ( <a href="mailto:christian@tugzip.com">Christian Kindahl</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/cwarrior/lesson33.zip">Code Warrior 5.3</a> kód této lekce. ( <a href="mailto:DelusionalBeing@hotmail.com">Scott Lupton</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/devc/lesson33.zip">Dev C++</a> kód této lekce. ( <a href="mailto:danprogram@hotmail.com">Dan</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/linuxglx/lesson33.tar.gz">Linux/GLX</a> kód této lekce. ( <a href="mailto:Schubert_P@Yahoo.de">Patrick Schubert</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/macosxcocoa/lesson33.zip">Mac OS X/Cocoa</a> kód této lekce. ( <a href="mailto:blb@pobox.com">Bryan Blackburn</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/vs_net/lesson33.zip">Visual Studio .NET</a> kód této lekce. ( <a href="mailto:ultimatezeus@hotmail.com">Grant James</a> )</li>
</ul>

<div class="okolo_img"><img src="images/nehe_tut/tut_33_big.jpg" class="nehe_velky" alt="Lekce 33" /></div>
<p class="okolni_lekce"><a href="tut_32.php">&lt;&lt;&lt; Lekce 32</a> | <a href="tut_34.php">Lekce 34 &gt;&gt;&gt;</a></p>


<div class="netisk">
<h3 class="d_nadpis">Diskuze ke èlánku</h3>

<form action="d_view.php" method="post" class="d_o_obsah">

<div class="d_o_zprava">
<div class="d_o_jmeno">GereG</div>
<div class="d_o_datumcas">01.04.2005 - 16:54:28</div>
<div>
<input type="checkbox" name="id_0" id="id_0" value="1" />
<span class="d_o_nadpis" style="margin-left: 0px;"><a href="d_view.php?f=tut_33.php&j=0">editor</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">Woq</div>
<div class="d_o_datumcas">10.04.2005 - 16:36:53</div>
<div>
<input type="checkbox" name="id_1" id="id_1" value="1" />
<span class="d_o_nadpis" style="margin-left: 20px;"><a href="d_view.php?f=tut_33.php&j=1">Re: editor</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">Jan16</div>
<div class="d_o_datumcas">27.07.2007 - 16:18:26</div>
<div>
<input type="checkbox" name="id_3" id="id_3" value="1" />
<span class="d_o_nadpis" style="margin-left: 40px;"><a href="d_view.php?f=tut_33.php&j=3">Re: editor</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">Xennus</div>
<div class="d_o_datumcas">20.10.2006 - 15:56:48</div>
<div>
<input type="checkbox" name="id_2" id="id_2" value="1" />
<span class="d_o_nadpis" style="margin-left: 0px;"><a href="d_view.php?f=tut_33.php&j=2">Could not read info header</a></span>
</div>
</div>

<div class="okolo_img" style="margin-top: 20px;">
<input type="submit" name="zobrazit_vybrane" id="zobrazit_vybrane" value="Zobrazit vybrané" class="tlacitko" />
<input type="submit" name="zobrazit_vse" id="zobrazit_vse" value="Zobrazit v¹e" class="tlacitko" />
<input type="submit" name="vlozit_novy" id="vlozit_novy" value="Vlo¾it nový" class="tlacitko" />
<input type="hidden" name="f" id="f" value="tut_33.php" />
</div>
</form>
</div>
<!-- Informace o webu -->
<center><div id="informace">
<img src="images/my/woq.gif" width="60" height="60" align="left" alt="Woq logo" />
<div style="margin-left: 70px">
<div><strong>CZ NeHe OpenGL, v¹e o programování 3D grafiky</strong></div>
<div>Copyright &copy; 2002-2007 Michal Turek <span class="transform_email">&lt;WOQ (zavináè) seznam.cz&gt;</span></div>
<div style="margin-top: 5px">Komerèní publikování v ti¹tìné, elektronické nebo jiné podobì je bez výslovného souhlasu zakázáno. Redistribuce pro výukové úèely nebo osobní pou¾ití je v¹ak povolena.</div>
</div>
</div></center>
<!-- Informace o webu (konec) -->

</div>
<!-- Vlastní obsah stránky (konec) -->

<script src="http://c1.navrcholu.cz/code?site=56575;t=b14"
type="text/javascript"></script><noscript><div><a
href="http://navrcholu.cz/"><img
src="http://c1.navrcholu.cz/hit?site=56575;t=b14;ref=;jss=0"
width="14" height="14" alt="NAVRCHOLU.cz"
style="border:none" /></a></div></noscript>

</body>
</html>
