<?xml version="1.0" encoding="ISO-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">
<head>

<meta http-equiv="content-type" content="text/html; charset=ISO-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta http-equiv="content-script-type" content="text/javascript" />
<meta http-equiv="content-style-type" content="text/css" />

<meta name="robots" content="all, follow" />
<meta name="resource-type" content="document" />

<meta name="description" content="NeHe OpenGL Tutoriály v èe¹tinì, programování 3D grafiky, èlánky, programy se zdrojovými kódy..." />
<meta name="keywords" content="opengl, nehe, tutoriály, woq, programování, 3D" />
<meta name="author" content="all: Michal Turek - Woq; woq (zavináè) seznam.cz" />
<meta name="copyright" content="Copyright (c) 2002, 2003, 2004 Michal Turek - Woq" />

<title>CZ NeHe OpenGL - Lekce 22 - Bump Mapping &amp; Multi Texturing</title>

<link rel="shortcut icon" href="skin/default/web.ico" type="image/x-icon" />
<link href="skin/default.css" rel="stylesheet" type="text/css" media="all" />
<link href="skin/print.css" rel="stylesheet" type="text/css" media="print" />

</head>

<body>

<!-- Levý sloupec -->
<div class="levy">
<div id="main_menu">
<a href="http://nehe.ceske-hry.cz/"><img src="skin/default/web_logo.gif" width="135" height="135" style="margin-left: 5px;" alt="CZ NeHe OpenGL" /></a>

<div class="main_menu_bez_loga">

<ul class="text_main_menu">
<li><a href="my.php" title="Pøekladatelé NeHe Tutoriálù a autoøi èlánkù">My</a></li>
<li><a href="novinky.php" title="Co je nového">Novinky</a></li>
<li><a href="navigacni_mapa.php" title="Pøehledná navigace na jednotlivé stránky, které dohromady tvoøí tento web">Navigaèní mapa</a></li>
<li><a href="kontakt.php" title="Kontakt na správce tohoto webu">Kontakt</a></li>
<li><a href="http://forum.programovani.com/" title="Diskusní fórum">Fórum</a></li>
</ul>

<ul class="text_main_menu">
<li><a href="clanky.php" title="Obsah èlánkù">Èlánky</a></li>
<li><a href="tut_obsah.php" title="Obsah NeHe OpenGL Tutoriálù">NeHe Tutoriály</a></li>
<li><a href="33D_index.php" title="Obsah Free3D (33D) Basecode">33D Basecode</a></li>
<li><a href="programy.php" title="Programy od èeských autorù">Èeské programy</a></li>
<li><a href="cl_gl_zacinam.php" title="Kde zaèít pøi uèení OpenGL">Pomoc, zaèínám</a></li>
<li><a href="odkazy.php" title="Jiné zdroje informací">Odkazy</a></li>
<li><a href="cl_gl_faq.php" title="FAQ: Èasto kladené dotazy">FAQ</a></li>
</ul>

<ul class="text_main_menu">
<li><a href="spoluprace.php" title="Nechcete se podílet na tvorbì tìchto webových stránek?">Spolupráce...?</a></li>
<li><a href="download.php" title="Stahujte">Download</a></li>
<li><a href="skiny.php" title="Nastavte si jiný layout a design stránek">Skiny</a></li>
<li><a href="javascript:window.print();" title="Vytiskne tuto stránku">Tisk</a></li>
</ul>

<ul class="text_main_menu">
<li>
<form action="p_fulltext.php" method="post" onsubmit="if(!this.najit.value || this.najit.value=='výraz ...') { alert('Byl zadán prázdný øetìzec!'); this.najit.focus(); return false; }">
<input type="text" name="najit" size="12" value="výraz ..." onclick="this.value=''" /><br />
<input type="submit" value="Najít" />
</form>
</li>
</ul>

<ul class="text_main_menu">
<li>Online ètenáøù: 2</li>
</ul>

</div>

</div>
</div>
<!-- Levý sloupec (konec) -->

<!-- Pravý sloupec -->
<div class="pravy">
<div id="tut_menu">

<ul class="text_tut_menu">
<li class="li_tut"><a href="tut_00.php" title="Lekce 0 - Pøedmluva k NeHe Tutoriálùm">00</a></li>
<li class="li_tut"><a href="tut_01.php" title="Lekce 1 - Vytvoøení OpenGL okna ve Windows">01</a></li>
<li class="li_tut"><a href="tut_02.php" title="Lekce 2 - Vytváøení trojúhelníkù a ètyøúhelníkù">02</a></li>
<li class="li_tut"><a href="tut_03.php" title="Lekce 3 - Barvy">03</a></li>
<li class="li_tut"><a href="tut_04.php" title="Lekce 4 - Rotace">04</a></li>
<li class="li_tut"><a href="tut_05.php" title="Lekce 5 - Pevné objekty">05</a></li>
<li class="li_tut"><a href="tut_06.php" title="Lekce 6 - Textury">06</a></li>
<li class="li_tut"><a href="tut_07.php" title="Lekce 7 - Texturové filtry, osvìtlení, ovládání pomocí klávesnice">07</a></li>
<li class="li_tut"><a href="tut_08.php" title="Lekce 8 - Blending">08</a></li>
<li class="li_tut"><a href="tut_09.php" title="Lekce 9 - Pohyb bitmap ve 3D prostoru">09</a></li>
<li class="li_tut"><a href="tut_10.php" title="Lekce 10 - Vytvoøení 3D svìta a pohyb v nìm">10</a></li>
<li class="li_tut"><a href="tut_11.php" title="Lekce 11 - Efekt vlnící se vlajky">11</a></li>
<li class="li_tut"><a href="tut_12.php" title="Lekce 12 - Display list">12</a></li>
<li class="li_tut"><a href="tut_13.php" title="Lekce 13 - Bitmapové fonty">13</a></li>
<li class="li_tut"><a href="tut_14.php" title="Lekce 14 - Outline fonty">14</a></li>
<li class="li_tut"><a href="tut_15.php" title="Lekce 15 - Mapování textur na fonty">15</a></li>
<li class="li_tut"><a href="tut_16.php" title="Lekce 16 - Mlha">16</a></li>
<li class="li_tut"><a href="tut_17.php" title="Lekce 17 - 2D fonty z textur">17</a></li>
<li class="li_tut"><a href="tut_18.php" title="Lekce 18 - Kvadriky">18</a></li>
<li class="li_tut"><a href="tut_19.php" title="Lekce 19 - Èásticové systémy">19</a></li>
<li class="li_tut"><a href="tut_20.php" title="Lekce 20 - Maskování">20</a></li>
<li class="li_tut"><a href="tut_21.php" title="Lekce 21 - Pøímky, antialiasing, èasování, pravoúhlá projekce, základní zvuky a jednoduchá herní logika">21</a></li>
<li class="li_tut"><a href="tut_22.php" title="Lekce 22 - Bump Mapping &amp; Multi Texturing">22</a></li>
<li class="li_tut"><a href="tut_23.php" title="Lekce 23 - Mapování textur na kulové kvadriky">23</a></li>
<li class="li_tut"><a href="tut_24.php" title="Lekce 24 - Výpis OpenGL roz¹íøení, oøezávací testy a textury z TGA obrázkù">24</a></li>
<li class="li_tut"><a href="tut_25.php" title="Lekce 25 - Morfování objektù a jejich nahrávání z textového souboru">25</a></li>
<li class="li_tut"><a href="tut_26.php" title="Lekce 26 - Odrazy a jejich oøezávání za pou¾ití stencil bufferu">26</a></li>
<li class="li_tut"><a href="tut_27.php" title="Lekce 27 - Stíny">27</a></li>
<li class="li_tut"><a href="tut_28.php" title="Lekce 28 - Bezierovy køivky a povrchy, fullscreen fix">28</a></li>
<li class="li_tut"><a href="tut_29.php" title="Lekce 29 - Blitter, nahrávání .RAW textur">29</a></li>
<li class="li_tut"><a href="tut_30.php" title="Lekce 30 - Detekce kolizí">30</a></li>
<li class="li_tut"><a href="tut_31.php" title="Lekce 31 - Nahrávání a renderování modelù">31</a></li>
<li class="li_tut"><a href="tut_32.php" title="Lekce 32 - Picking, alfa blending, alfa testing, sorting">32</a></li>
<li class="li_tut"><a href="tut_33.php" title="Lekce 33 - Nahrávání komprimovaných i nekomprimovaných obrázkù TGA">33</a></li>
<li class="li_tut"><a href="tut_34.php" title="Lekce 34 - Generování terénù a krajin za pou¾ití vý¹kového mapování textur">34</a></li>
<li class="li_tut"><a href="tut_35.php" title="Lekce 35 - Pøehrávání videa ve formátu AVI">35</a></li>
<li class="li_tut"><a href="tut_36.php" title="Lekce 36 - Radial Blur, renderování do textury">36</a></li>
<li class="li_tut"><a href="tut_37.php" title="Lekce 37 - Cel-Shading">37</a></li>
<li class="li_tut"><a href="tut_38.php" title="Lekce 38 - Nahrávání textur z resource souboru &amp; texturování trojúhelníkù">38</a></li>
<li class="li_tut"><a href="tut_39.php" title="Lekce 39 - Úvod do fyzikálních simulací">39</a></li>
<li class="li_tut"><a href="tut_40.php" title="Lekce 40 - Fyzikální simulace lana">40</a></li>
<li class="li_tut"><a href="tut_41.php" title="Lekce 41 - Volumetrická mlha a nahrávání obrázkù pomocí IPicture">41</a></li>
<li class="li_tut"><a href="tut_42.php" title="Lekce 42 - Více viewportù">42</a></li>
<li class="li_tut"><a href="tut_43.php" title="Lekce 43 - FreeType Fonty v OpenGL">43</a></li>
<li class="li_tut"><a href="tut_44.php" title="Lekce 44 - Èoèkové efekty">44</a></li>
<li class="li_tut"><a href="tut_45.php" title="Lekce 45 - Vertex Buffer Object (VBO)">45</a></li>
<li class="li_tut"><a href="tut_46.php" title="Lekce 46 - Fullscreenový antialiasing">46</a></li>
<li class="li_tut"><a href="tut_47.php" title="Lekce 47 - CG vertex shader">47</a></li>
<li class="li_tut"><a href="tut_48.php" title="Lekce 48 - ArcBall rotace">48</a></li>
</ul>

</div>
</div>
<!-- Pravý sloupec (konec) -->

<!-- Vlastní obsah stránky -->
<div class="stred">

<!--[if IE ]>
<div style="text-align: center;">
<a href="http://firefox.czilla.cz/"><img alt="Mozilla Firefox: Objevte znovu web" title="Mozilla Firefox: Objevte znovu web" style="border:none; width:468px;height:60px" src="http://firefox.czilla.cz/img/p/cz-ff-468x60-w-objevte.png" /></a>
</div>
<![endif]-->

<img src="images/nehe_tut/tut_22.jpg" class="nehe_maly" alt="Lekce 22" />

<h1>Lekce 22 - Bump Mapping &amp; Multi Texturing</h1>

<p class="nadpis_clanku">Pravý èas vrátit se zpátky na zaèátek a zaèít si opakovat. Nováèkùm v OpenGL se absolutnì nedoporuèuje! Pokud, ale máte odvahu, mù¾ete zkusit dobrodru¾ství s nadupanou grafikou. V této lekci modifikujeme kód z ¹esté lekce, aby podporoval hardwarový multi texturing pøes opravdu skvìlý vizuální efekt nazvaný bump mapping.</p>

<p>Pøi pøekladu této lekce jsem zva¾oval zda mám nìkteré termíny pøekládat do èe¹tiny. Ale vzhledem k tomu, ¾e jsou to vìt¹inou názvy, které se bì¾nì v oboru poèítaèové grafiky objevují, rozhodl jsem se nechat je v pùvodním znìní. Aby v¹ak i ti, kteøí se s nimi setkávají poprvé, vìdìli o èem je øeè, tak je zde v rychlosti vysvìtlím:</p>

<p><b>OpenGL extension</b> je funkce, která není v bì¾né specifikaci OpenGL dostupná, ale kvùli novým mo¾nostem grafických akcelerátorù a novým postupùm pøi programování byla do OpenGL dodateènì pøidána. Tyto funkce ve svém názvu obsahují EXT nebo ARB. Firmy se samozøejmì sna¾í, aby jejich akcelerátor podporoval tìchto roz¹íøení co nejvíce, proto¾e mnohé z nich zrychlují práci, pøidávají nové mo¾nosti nebo zvy¹ují výkon.</p>

<p><b>Bumpmapa</b> je textura, která obsahuje informace o reliéfu. Vìt¹inou bývá ve stupních ¹edi, kde tmavá místa udávají vyvý¹eniny a svìtlá rýhy, nebo naopak - to zále¾í na programátorovi.</p>

<p><b>Emboss bumpmapping</b> je postup vytváøení reliéfovaných textur, u kterých se zdá, ¾e jsou tvarované i do hloubky - hlavní téma této lekce.</p>

<p><b>Alpha kanál</b> je poslední slo¾ka RGBA barvy, která obsahuje informace o prùhlednosti. Pokud je alpha maximální (255 nebo 1.0f), tak není objekt vùbec prùhledný. Pokud je alpha nulová je objekt neviditelný.</p>

<p><b>Blending</b> je míchání alpha kanálu s barevnou texturou. Dociluje se jím prùhlednosti.</p>

<p><b>Artefakt</b> je nìjaký vizuální prvek, který by se v renderované scénì nemìl objevovat. Nicménì vzhledem k tomu, ¾e postupy, které by je nezanechávaly jsou vìt¹inou velmi pomalé, musí se pou¾ívat jiné, které na úkor kvality zvý¹í rychlost renderování.</p>

<p>Dal¹í názvy typu <b>vertex</b>, <b>pipeline</b>, ... by mìly být dobøe známé z pøedchozích tutoriálù.</p>

<p>Doufám, ¾e Vám pøeklad i téma budou srozumitelné a ¾e Vám pomohou vytváøet kvalitní OpenGL aplikace. Pokud byste narazili na nìjaký problém, není nic jednodu¹¹ího ne¾ poslat emailem dotaz. Rád Vám na v¹echny otázky odpovím, pøípadnì opravím nedostatky v textu.</p>

<p>Tato lekce byla napsána Jensem Schneiderem. Volnì vychází z 6. lekce, i kdy¾ vzniklo mnoho zmìn. Nauèíte se zde:</p>
<ul>
<li>Jak ovládat multitexturovací mo¾nosti grafického akcelerátoru.</li>
<li>Jak vytvoøit zdání emdoss bumpmappingu (reliéf na texturách).</li>
<li>Jak udìlat pomocí blendingu profesionálnì vypadající loga, která &quot;plují&quot; nad renderovanou scénou.</li>
<li>Základy multi-pass (nìkolika fázových) renderovacích technik.</li>
<li>Jak vyu¾ívat efektivnì transformace matice.</li>
</ul>

<p>Nejménì tøi z vý¹e uvedených bodù mohou být pova¾ovány za &quot;pokroèilé renderovací techniky&quot;. Mìli byste mít ji¾ základní pøedstavu o tom, jak funguje renderovací pipeline OpenGL. Mìli byste znát vìt¹inu pøíkazù u¾itých v tutoriálu a mìli byste být obeznámeni s vektorovou matematikou. Sekce, které zaèínají slovy "zaèátek teorie(...)" a konèí slovy "konec teorie(...)", se sna¾í vysvìtlit problematiku uvedenou v závorkách. Tohle je zde jen pro jistotu. Pokud danou problematiku znáte, mù¾ete tyto èásti jednodu¹e pøeskoèit. Pokud budete mít problémy s porozumìním kódu, zva¾te návrat zpìt k teoretickým èástem textu. Poslední, ale neménì dùle¾ité: Tato lekce obsahuje více ne¾ 1 200 øádek kódu a velká èást z nich je nejen nudná, ale i dobøe známá tìm, kteøí èetli pøedchozí tutoriály. Proto nebudu komentovat ka¾dý øádek, ale jen podstatu této lekce. Pokud narazíte na nìco jako <b>&gt;-&lt;</b>, znamená to, ¾e zde byly vynechány nìjaké nepodstatné øádky kódu.</p>

<p>Tak¾e, jdeme na to:</p>

<p class="src0">#include &lt;windows.h&gt;<span class="kom">// Hlavièkový soubor pro Windows</span></p>
<p class="src0">#include &lt;stdio.h&gt;<span class="kom">// Hlavièkový soubor pro standardní vstup/výstup</span></p>
<p class="src0">#include &lt;gl\gl.h&gt;<span class="kom">// Hlavièkový soubor pro OpenGL32 knihovnu</span></p>
<p class="src0">#include &lt;gl\glu.h&gt;<span class="kom">// Hlavièkový soubor pro Glu32 knihovnu</span></p>
<p class="src0">#include &lt;gl\glaux.h&gt;<span class="kom">// Hlavièkový soubor pro Glaux knihovnu</span></p>
<p></p>
<p class="src0">#include &quot;glext.h&quot;<span class="kom">// Hlavièkový soubor pro multitexturing</span></p>
<p></p>
<p class="src0">#include &lt;string.h&gt;<span class="kom">// Hlavièkový soubor pro øetìzce</span></p>
<p class="src0">#include &lt;math.h&gt;<span class="kom">// Hlavièkový soubor pro matematiku</span></p>

<p>GLfloat MAX_EMBOSS udává &quot;sílu&quot; bumpmappingu. Vy¹¹í hodnoty hodnì zvýrazní efekt, ale stejnì tak sní¾í kvalitu obrazu tím, ¾e zanechávají v rozích ploch takzvané &quot;artefakty&quot;.</p>

<p class="src0">#define MAX_EMBOSS (GLfloat)0.008f<span class="kom">// Maximální posunutí efektem</span></p>

<p>Fajn, pøipravíme se na pou¾ití GL_ARB_multitexture. Je to celkem jednoduché:</p>

<p>Vìt¹ina grafických akcelerátorù má dnes více ne¾ jednu texturovací jednotku. Abychom mohli této výhody vyu¾ít, musíme provìøit, zda akcelerátor podporuje GL_ARB_multitexture, který umo¾òuje namapovat dvì nebo více textur na jeden útvar pøi jednom prùchodu pipeline. Nezní to pøíli¹ významnì, ale opak je pravdou! Skoro v¾dy kdy¾ nìco programujete, pøidáním dal¹í textury na objekt, razantnì zvý¹íte jeho vizuální kvalitu. Døíve bylo nutno pou¾ít dvì prokládané textury pøi vícenásobném vykreslování geometrie, co¾ mù¾e vést k velkému poklesu výkonu. Dále v tutoriálu bude multitexturing je¹tì podrobnìji popsán.</p>

<p>Teï zpìt ke kódu: __ARB_ENABLE je u¾ito pro urèení toho, zda chceme vyu¾ít multitexturingu, kdy¾ bude dostupný. Pokud chcete poznat va¹í kartou podporovaná OpenGL roz¹íøení, pouze odkomentujte #define EXT_INFO. Dále chceme provìøit podporu extensions pøi bìhu programu, abychom zajistili pøenositelnost kódu. Proto potøebujeme místo pro pár øetìzcù. Dále chceme rozli¹ovat mezi mo¾ností pou¾ívat extensions a samotným pou¾íváním. Nakonec potøebujeme vìdìt, kolik texturovacích jednotek máme k dispozici (pou¾ijeme ale pouze dvì). Alespoò jedna texturovací jednotka je v¾dy pøítomna na akcelerátoru podporujícím OpenGL, tak¾e nastavíme maxTexelUnits na hodnotu 1.</p>

<p class="src0">#define __ARB_ENABLE true<span class="kom">// Pou¾ito pro vyøazení multitexturingu</span></p>
<p></p>
<p class="src0"><span class="kom">// #define EXT_INFO// Odkomentujte, pokud chcete pøi startu vidìt podporovaná roz¹íøení OpenGL
</span></p>
<p></p>
<p class="src0">#define MAX_EXTENSION_SPACE 10240<span class="kom">// Místo pro øetìzce s OpenGL roz¹íøeními</span></p>
<p class="src0">#define MAX_EXTENSION_LENGTH 256<span class="kom">// Maximum znakù v jednom øetìzci s roz¹íøením</span></p>
<p></p>
<p class="src0">bool multitextureSupported = false;<span class="kom">// Indikátor podpory multitexturingu</span></p>
<p class="src0">bool useMultitexture = true;<span class="kom">// Pou¾it multitexturing?</span></p>
<p></p>
<p class="src0">GLint maxTexelUnits = 1;<span class="kom">// Poèet texturovacích jednotek - nejménì 1</span></p>

<p>Následující øádky slou¾í k tomu, aby spojily roz¹íøení s voláním funkcí v C++. Pouze vyu¾ijeme PNF-kdo-to-kdy-pøeèetl jako pøeddefinovaného datového typu schopného popsat volání funkcí. Zpoèátku není jisté, zda získáme pøístup k tìmto prototypùm funkcí, tudí¾ je nastavíme na NULL. Pøíkazy glMultiTexCoordifARB odkazují na dobøe známé pøíkazy glTexCoordif(), udávající i-rozmìrné souøadnice textury. V¹imnìte si, ¾e proto mohou úplnì nahradit pøíkazy glTexCoordif. Døíve jsme pou¾ívali pouze verzi pro typ GLfloat, my potøebujeme pouze prototypy k pøíkazùm konèícím na "f" - ostatní jsou potom taky dostupné (fv, i, ...). Poslední dva prototypy slou¾í k urèení texturovací jednotky, která bude pøijímat informace o textuøe (glActiveTextureARB()) a k urèení, která texturovací jednotka je asociována s pøíkazem ArrayPointer (glClientActiveTextureARB). Mimochodem: ARB je zkratkou &quot;Architectural Review Board&quot;. Roz¹íøení s ARB v názvu nejsou vy¾adovány pro implementaci kompatibilní s OpenGL, ale jsou ¹iroce vyu¾ívány a podporovány.</p>

<p class="src0">PFNGLMULTITEXCOORD1FARBPROC glMultiTexCoord1fARB = NULL;</p>
<p class="src0">PFNGLMULTITEXCOORD2FARBPROC glMultiTexCoord2fARB = NULL;</p>
<p class="src0">PFNGLMULTITEXCOORD3FARBPROC glMultiTexCoord3fARB = NULL;</p>
<p class="src0">PFNGLMULTITEXCOORD4FARBPROC glMultiTexCoord4fARB = NULL;</p>
<p></p>
<p class="src0">PFNGLACTIVETEXTUREARBPROC glActiveTextureARB = NULL;</p>
<p class="src0">PFNGLCLIENTACTIVETEXTUREARBPROC glClientActiveTextureARB = NULL;</p>

<p>Potøebujeme globální promìnné:</p>

<ul>
<li>filter - udává, jaký filtr se má pou¾ít. Pou¾ijeme nejspí¹e GL_LINEAR, tak¾e filter inicializujeme èíslem 1.</li>
<li>texture - textury, potøebujeme 3 - na ka¾dý filtr jednu</li>
<li>bump - bumpmapy</li>
<li>invbump - pøevrácené bump mapy - jejich význam je popsán v jedné z teoretických èástí této lekce</li>
<li>glLogo a multiLogo - vyu¾ijeme pro textury, které budou pøidány do scény v poslední fázi rendrování</li>
<li>promìnné s Light v názvu - jsou pole nesoucí informace o osvìtlení scény</li>
</ul>

<p class="src0">GLuint filter=1;<span class="kom">// Jaký filtr pou¾ít</span></p>
<p class="src0">GLuint texture[3];<span class="kom">// Místo pro tøi textury</span></p>
<p></p>
<p class="src0">GLuint bump[3];<span class="kom">// Na¹e bumpmapy</span></p>
<p class="src0">GLuint invbump[3];<span class="kom">// Invertované bumpmapy</span></p>
<p></p>
<p class="src0">GLuint glLogo;<span class="kom">// Místo pro OpenGL Logo</span></p>
<p class="src0">GLuint multiLogo;<span class="kom">// Místo pro logo s multitexturingem</span></p>
<p></p>
<p class="src0">GLfloat LightAmbient[] = { 0.2f, 0.2f, 0.2f};<span class="kom">// Barva ambientního svìtla je 20% bílá</span></p>
<p class="src0">GLfloat LightDiffuse[] = { 1.0f, 1.0f, 1.0f};<span class="kom">// Difúzní svìtlo je bílé</span></p>
<p class="src0">GLfloat LightPosition[] = { 0.0f, 0.0f, 2.0f};<span class="kom">// Pozice je nìkde uprostøed scény</span></p>
<p></p>
<p class="src0">GLfloat Gray[] = { 0.5f, 0.5f, 0.5f, 1.0f };<span class="kom">// Barva okraje textury</span></p>
<p></p>
<p class="src0">bool emboss = false;<span class="kom">// Jenom Emboss, ¾ádná základní textura</span></p>
<p class="src0">bool bumps = true;<span class="kom">// Pou¾ívat bumpmapping?</span></p>
<p></p>
<p class="src0">GLfloat xrot;<span class="kom">// X rotace</span></p>
<p class="src0">GLfloat yrot;<span class="kom">// Y rotace</span></p>
<p></p>
<p class="src0">GLfloat xspeed;<span class="kom">// Rychlost x rotace</span></p>
<p class="src0">GLfloat yspeed;<span class="kom">// Rychlost y rotace</span></p>
<p></p>
<p class="src0">GLfloat z = -5.0f;<span class="kom">// Hloubka v obrazovce</span></p>

<p>Dal¹í èást kódu obsahuje souøadnice kostky sestavené z GL_QUADS. Ka¾dých pìt èísel reprezentuje jednu sadu 2D texturovacích souøadnic a jednu sadu 3D vertexových souøadnic bodu. Data jsou uvedena v poli kvùli snaz¹ímu vykreslování ve for smyèkách. Bìhem jednoho renderovacího cyklu budeme tyto souøadnice potøebovat vícekrát.</p>

<p class="src0">GLfloat data[] =</p>
<p class="src0">{</p>
<p class="src1"><span class="kom">// Pøední stìna</span></p>
<p class="src1">0.0f, 0.0f, -1.0f, -1.0f, +1.0f,</p>
<p class="src1">1.0f, 0.0f, +1.0f, -1.0f, +1.0f,</p>
<p class="src1">1.0f, 1.0f, +1.0f, +1.0f, +1.0f,</p>
<p class="src1">0.0f, 1.0f, -1.0f, +1.0f, +1.0f,</p>
<p class="src1"><span class="kom">// Zadní stìna</span></p>
<p class="src1">1.0f, 0.0f, -1.0f, -1.0f, -1.0f,</p>
<p class="src1">1.0f, 1.0f, -1.0f, +1.0f, -1.0f,</p>
<p class="src1">0.0f, 1.0f, +1.0f, +1.0f, -1.0f,</p>
<p class="src1">0.0f, 0.0f, +1.0f, -1.0f, -1.0f,</p>
<p class="src1"><span class="kom">// Horní stìna</span></p>
<p class="src1">0.0f, 1.0f, -1.0f, +1.0f, -1.0f,</p>
<p class="src1">0.0f, 0.0f, -1.0f, +1.0f, +1.0f,</p>
<p class="src1">1.0f, 0.0f, +1.0f, +1.0f, +1.0f,</p>
<p class="src1">1.0f, 1.0f, +1.0f, +1.0f, -1.0f,</p>
<p class="src1"><span class="kom">// Dolní stìna</span></p>
<p class="src1">1.0f, 1.0f, -1.0f, -1.0f, -1.0f,</p>
<p class="src1">0.0f, 1.0f, +1.0f, -1.0f, -1.0f,</p>
<p class="src1">0.0f, 0.0f, +1.0f, -1.0f, +1.0f,</p>
<p class="src1">1.0f, 0.0f, -1.0f, -1.0f, +1.0f,</p>
<p class="src1"><span class="kom">// Pravá stìna</span></p>
<p class="src1">1.0f, 0.0f, +1.0f, -1.0f, -1.0f,</p>
<p class="src1">1.0f, 1.0f, +1.0f, +1.0f, -1.0f,</p>
<p class="src1">0.0f, 1.0f, +1.0f, +1.0f, +1.0f,</p>
<p class="src1">0.0f, 0.0f, +1.0f, -1.0f, +1.0f,</p>
<p class="src1"><span class="kom">// Levá stìna</span></p>
<p class="src1">0.0f, 0.0f, -1.0f, -1.0f, -1.0f,</p>
<p class="src1">1.0f, 0.0f, -1.0f, -1.0f, +1.0f,</p>
<p class="src1">1.0f, 1.0f, -1.0f, +1.0f, +1.0f,</p>
<p class="src1">0.0f, 1.0f, -1.0f, +1.0f, -1.0f</p>
<p class="src0">};</p>

<p>Dal¹í èást kódu rozhoduje o pou¾ití OpenGL extensions za bìhu programu.</p>
<p>Pøedpokládejme, ¾e máme dlouhý øetìzec obsahující názvy v¹ech podporovaných roz¹íøení oddìlených znakem nového øádku -'\n'. Potøebujeme vyhledat znak nového øádku a tuto èást zaèít porovnávat s hledaným øetìzcem, dokud nenarazíme na dal¹í znak nového øádku, nebo dokud nalezený øetìzec neodpovídá tomu hledanému. V prvním pøípadì vrátíme true, v druhém pøípadì vezmeme dal¹í sub-øetìzec dokud nenarazíme na konec øetìzce. Budeme si muset dát pozor na to, zda øetìzec nezaèíná znakem nového øádku.</p>
<p>Poznámka: Kontrola podpory roz¹íøení by se mìla V®DY provádìt a¾ za bìhu programu.</p>

<p class="src0">bool isInString(char *string, const char *search)</p>
<p class="src0">{</p>
<p class="src1">int pos = 0;</p>
<p class="src1">int maxpos = strlen(search)-1;</p>
<p class="src1">int len = strlen(string);</p>
<p class="src1">char *other;</p>
<p></p>
<p class="src1">for (int i=0; i&lt;len; i++)</p>
<p class="src1">{</p>
<p class="src2">if ((i==0) || ((i&gt;1) &amp;&amp; string[i-1]=='\n'))<span class="kom">// Nové roz¹íøení zaèíná zde</span></p>
<p class="src2">{</p>
<p class="src3">other = &amp;string[i];</p>
<p class="src3">pos=0;<span class="kom">// Zaèít nové hledání</span></p>
<p></p>
<p class="src3">while (string[i]!='\n')<span class="kom">// Hledání celého øetìzce jména roz¹íøení</span></p>
<p class="src3">{</p>
<p class="src4">if (string[i]==search[pos])</p>
<p class="src5">pos++;<span class="kom">// Dal¹í znak</span></p>
<p></p>
<p class="src4">if ((pos&gt;maxpos) &amp;&amp; string[i+1]=='\n')</p>
<p class="src5">return true; <span class="kom">// A máme to!</span></p>
<p></p>
<p class="src4">i++;</p>
<p class="src3">}</p>
<p class="src2">}</p>
<p class="src1">}</p>
<p></p>
<p class="src1">return false;<span class="kom">// Smùla, nic jsme nena¹li!</span></p>
<p class="src0">}</p>

<p>Teï musíme získat øetìzec obsahující názvy extensions a pøevést ho tak, aby jednotlivé názvy byly oddìleny znakem nového øádku. Pokud najdeme sub-øetìzec &quot;GL_ARB_multitexture&quot;, tak je tato funkce podporovaná. Ale my jí pou¾ijeme, jen kdy¾ je __ARB_ENABLE nastaveno na true. Je¹tì potøebujeme zjistit podporu GL_EXT_texture_env_combine. Toto roz¹íøení zavádí nový zpùsob interakce s texturovacími jednotkami. My to potøebujeme, proto¾e GL_ARB_multitexture pouze pøená¹í výstup z jedné texturovací jednotky do dal¹í s vy¹¹ím èíslem. Ne¾ abychom pou¾ívali dal¹í komplexní rovnice pro výpoèet blendingu (které by ale mohly mít odli¹ný efekt), radìji zajistíme podporu tohoto roz¹íøení. Pokud jsou v¹echna roz¹íøení podporována, zjistíme kolik texturovacích jednotek máme k dispozici a hodnotu ulo¾íme do maxTexelUnits. Pak musíme spojit funkce s na¹imi jmény. To provedeme pomocí funkce wglGetProcAdress() s parametrem obsahujícím název funkce.</p>

<p class="src0">bool initMultitexture(void)</p>
<p class="src0">{</p>
<p class="src1">char *extensions;</p>
<p></p>
<p class="src1">extensions = strdup((char *) glGetString(GL_EXTENSIONS));<span class="kom">// Získání øetìzce s roz¹íøeními</span></p>
<p class="src1">int len = strlen(extensions);<span class="kom">// Délka øetìzce</span></p>
<p></p>
<p class="src1">for (int i = 0; i&lt;len; i++)<span class="kom">// Rozdìlit znakem nového øádku místo mezery</span></p>
<p class="src2">if (extensions[i] == ' ')</p>
<p class="src3">extensions[i] = '\n';</p>
<p></p>
<p class="src0">#ifdef EXT_INFO</p>
<p class="src1">MessageBox(hWnd,extensions,&quot;supported GL extensions&quot;,MB_OK | MB_ICONINFORMATION);</p>
<p class="src0">#endif</p>
<p></p>
<p class="src1">if (isInString(extensions,&quot;GL_ARB_multitexture&quot;)<span class="kom">// Je multitexturing podporován?
</span></p>
<p class="src1">&amp;&amp; __ARB_ENABLE<span class="kom">// Pøíznak pro povolení multitexturingu</span></p>
<p class="src1">&amp;&amp; isInString(extensions,&quot;GL_EXT_texture_env_combine&quot;))<span class="kom">// Je podporováno texture-environment-combining?</span></p>
<p class="src1">{</p>
<p class="src2">glGetIntegerv(GL_MAX_TEXTURE_UNITS_ARB, &amp;maxTexelUnits);</p>
<p></p>
<p class="src2">glMultiTexCoord1fARB = (PFNGLMULTITEXCOORD1FARBPROC)wglGetProcAddress(&quot;glMultiTexCoord1fARB&quot;);</p>
<p class="src2">glMultiTexCoord2fARB = (PFNGLMULTITEXCOORD2FARBPROC)wglGetProcAddress(&quot;glMultiTexCoord2fARB&quot;);</p>
<p class="src2">glMultiTexCoord3fARB = (PFNGLMULTITEXCOORD3FARBPROC)wglGetProcAddress(&quot;glMultiTexCoord3fARB&quot;);</p>
<p class="src2">glMultiTexCoord4fARB = (PFNGLMULTITEXCOORD4FARBPROC)wglGetProcAddress(&quot;glMultiTexCoord4fARB&quot;);</p>
<p></p>
<p class="src2">glActiveTextureARB = (PFNGLACTIVETEXTUREARBPROC)wglGetProcAddress(&quot;glActiveTextureARB&quot;);</p>
<p></p>
<p class="src2">glClientActiveTextureARB = (PFNGLCLIENTACTIVETEXTUREARBPROC)wglGetProcAddress(&quot;glClientActiveTextureARB&quot;);</p>
<p></p>
<p class="src0">#ifdef EXT_INFO</p>
<p class="src2">MessageBox(hWnd,&quot;The GL_ARB_multitexture extension will be used.&quot;,&quot;feature supported!&quot;,MB_OK | MB_ICONINFORMATION);</p>
<p class="src0">#endif</p>
<p></p>
<p class="src2">return true;</p>
<p class="src1">}</p>
<p></p>
<p class="src1">useMultitexture = false;<span class="kom">// Nemù¾eme to pou¾ívat, pokud to není podporováno!</span></p>
<p class="src1">return false;</p>
<p class="src0">}</p>

<p>InitLights() pouze inicializuje osvìtlení. Je volána funkcí initGL().</p>

<p class="src0">void initLights(void)</p>
<p class="src0">{</p>
<p class="src1">glLightfv(GL_LIGHT1, GL_AMBIENT, LightAmbient);<span class="kom">// Naètení informace o svìtlech do GL_LIGHT1</span></p>
<p class="src1">glLightfv(GL_LIGHT1, GL_DIFFUSE, LightDiffuse);</p>
<p class="src1">glLightfv(GL_LIGHT1, GL_POSITION, LightPosition);</p>
<p></p>
<p class="src1">glEnable(GL_LIGHT1);</p>
<p class="src0">}</p>

<p>V této lekci vytvoøíme hodnì textur. Nyní k na¹í naèítací funkci. Nejdøíve loadujeme základní bitmapu a pøipravíme z ní tøi filtrované textury (GL_NEAREST, GL_LINEAR, GL_LINEAR_MIPMAP_NEAREST). Pou¾ijeme pouze jednu datovou strukturu na ulo¾ení bitmap. Navíc zavedeme novou strukturu nazvanou alpha, která bude obsahovat informace o alpha kanálu (prùhlednosti) textury. Proto ulo¾íme RGBA obrázky jako dvì bitmapy: jednu 24 bitovou RGB a jednu osmi bitovou ve stupních ¹edi pro alpha kanál. Aby fungovalo naèítání správnì, musíme po ka¾dém naètení smazat Image, jinak nebudeme upozornìni na pøípadné chyby pøi nahrávání textur.</p>

<div class="okolo_img"><img src="images/nehe_tut/tut_22_base.gif" width="128" height="128" alt="Textura Base" /></div>

<p>Také je u specifikace typu textury vhodné uvést místo èísla 3 promìnnou GL_RGB8, a to kvùli lep¹í kompatibilitì s dal¹ími verzemi OpenGL. Tato zmìna je oznaèena v kódu <span class="warning">takto</span>.</p>

<p class="src0">int LoadGLTextures()<span class="kom">// Loading bitmapy a konverze na texturu</span></p>
<p class="src0">{</p>
<p class="src1">bool status=true;<span class="kom">// Indikuje chyby</span></p>
<p class="src1">AUX_RGBImageRec *Image=NULL;<span class="kom">// Ukládá bitmapu</span></p>
<p class="src1">char *alpha=NULL;</p>
<p></p>
<p class="src1">if (Image = auxDIBImageLoad(&quot;Data/Base.bmp&quot;))<span class="kom">// Nahraje bitmapu</span></p>
<p class="src1">{</p>
<p class="src2">glGenTextures(3, texture);<span class="kom">// Generuje tøi textury</span></p>
<p></p>
<p class="src2"><span class="kom">// Vytvoøení nelineárnì filtrované textury</span></p>
<p class="src2">glBindTexture(GL_TEXTURE_2D, texture[0]);</p>
<p class="src2">glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);</p>
<p class="src2">glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);</p>
<p class="src2">glTexImage2D(GL_TEXTURE_2D, 0, <span class="warning">GL_RGB8</span>, Image-&gt;sizeX, Image-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, Image-&gt;data);</p>
<p></p>
<p class="src2"><span class="kom">// Vytvoøení lineárnì filtrované textury</span></p>
<p class="src2">glBindTexture(GL_TEXTURE_2D, texture[1]);</p>
<p class="src2">glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);</p>
<p class="src2">glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);</p>
<p class="src2">glTexImage2D(GL_TEXTURE_2D, 0, <span class="warning">GL_RGB8</span>, Image-&gt;sizeX, Image-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, Image-&gt;data);</p>
<p></p>
<p class="src2"><span class="kom">// Vytvoøení mipmapované textury</span></p>
<p class="src2">glBindTexture(GL_TEXTURE_2D, texture[2]);</p>
<p class="src2">glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);</p>
<p class="src2">glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);</p>
<p class="src2">gluBuild2DMipmaps(GL_TEXTURE_2D, <span class="warning">GL_RGB8</span>, Image-&gt;sizeX, Image-&gt;sizeY, GL_RGB, GL_UNSIGNED_BYTE, Image-&gt;data);</p>
<p class="src1">}</p>
<p></p>
<p class="src1">else</p>
<p class="src2">status = false;</p>
<p></p>
<p class="src1">if (Image)<span class="kom">// Pokud obrázek existuje</span></p>
<p class="src1">{</p>
<p class="src2">if (Image-&gt;data)<span class="kom">// Pokud existují data obrázku</span></p>
<p class="src3">delete Image-&gt;data;<span class="kom">// Uvolní data obrázku</span></p>
<p></p>
<p class="src2">delete Image;<span class="kom">// Uvolní strukturu obrázku</span></p>
<p></p>
<p class="src2">Image = NULL;<span class="kom">// Nastaví ukazatel na NULL</span></p>
<p class="src1">}</p>

<p>Naèteme bumpmapu. Z dùvodù uvedených ní¾e musí mít pouze 50% intenzitu, tak¾e ji musíme nìjakým zpùsobem ztmavit. Já jsem se rozhodl pou¾ít funkci glPixelTransferf(), která udává jakým zpùsobem budou bitmapy pøevedeny na textury. My tuto funkci pou¾ijeme na ztmavení jednotlivých RGB kanálù bitmapy na 50% pùvodní intenzity. Pokud dosud nepou¾íváte rodinu funkcí glPixelTransfer(), mìli byste se na nì podívat - jsou celkem u¾iteèné.</p>

<div class="okolo_img"><img src="images/nehe_tut/tut_22_bump.gif" width="128" height="128" alt="Textura Bumpmapy" /></div>

<p class="src1"><span class="kom">// Loading bumpmap</span></p>
<p class="src1">if (Image = auxDIBImageLoad(&quot;Data/Bump.bmp&quot;))</p>
<p class="src1">{</p>
<p class="src2">glPixelTransferf(GL_RED_SCALE,0.5f);<span class="kom">// Sní¾ení intenzity RGB na 50% - polovièní intenzita</span></p>
<p class="src2">glPixelTransferf(GL_GREEN_SCALE,0.5f);</p>
<p class="src2">glPixelTransferf(GL_BLUE_SCALE,0.5f);</p>

<p>Dal¹í problém je, ¾e nechceme, aby se bitmapa v textuøe poøád opakovala, chceme ji namapovat pouze jednou na texturovací souøadnice od (0.0f,0.0f) do (1.0f,1.0f). V¹e kolem nich by mìlo být namapováno èernou barvou. Toho dosáhneme zavoláním dvou funkcí glTexParameteri(), které není tøeba popisovat.</p>

<p class="src2">glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP);<span class="kom">// Bez wrappingu (zalamování)</span></p>
<p class="src2">glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP);</p>
<p></p>
<p class="src2">glTexParameterfv(GL_TEXTURE_2D,GL_TEXTURE_BORDER_COLOR,Gray);<span class="kom">// Barva okraje textury</span></p>
<p></p>
<p class="src2">glGenTextures(3, bump);<span class="kom">// Vytvoøí tøi textury</span></p>
<p></p>
<p class="src2"><span class="kom">// Vytvoøení nelineárnì filtrované textury</span></p>
<p class="src2">&gt;-&lt;</p>
<p></p>
<p class="src2"><span class="kom">// Vytvoøení lineárnì filtrované textury</span></p>
<p class="src2">&gt;-&lt;</p>
<p></p>
<p class="src2"><span class="kom">// Vytvoøení mipmapované textury</span></p>
<p class="src2">&gt;-&lt;</p>

<p>Nyní musíme vytvoøit je¹tì invertovanou bumpmapu, o které jsme ji¾ psali a její¾ význam bude vysvìtlen dále. Odeètením barvy ka¾dého bodu bumpmapy od bílé barvy {255, 255, 255} získáme obrázek s invertovanými barvami. Pøedtím nesmíme nastavit intenzitu zpìt na 100% (ne¾ jsem na to pøi¹el strávil jsem nad tím asi 3 hodiny), invertovaná bitmapa musí být tedy také ztmavená na 50%.</p>

<p class="src2">for (int i = 0; i &lt; 3 * Image-&gt;sizeX * Image-&gt;sizeY; i++)<span class="kom">// Invertování bumpmapy</span></p>
<p class="src3">Image-&gt;data[i] = 255 - Image-&gt;data[i];</p>
<p></p>
<p class="src2">glGenTextures(3, invbump);<span class="kom">// Vytvoøí tøi textury</span></p>
<p></p>
<p class="src2"><span class="kom">// Vytvoøení nelineárnì filtrované textury</span></p>
<p class="src2">&gt;-&lt;</p>
<p></p>
<p class="src2"><span class="kom">// Vytvoøení lineárnì filtrované textury</span></p>
<p class="src2">&gt;-&lt;</p>
<p></p>
<p class="src2"><span class="kom">// Vytvoøení mipmapované textury</span></p>
<p class="src2">&gt;-&lt;</p>
<p></p>
<p class="src2">glPixelTransferf(GL_RED_SCALE,1.0f);<span class="kom">// Vrácení intenzity RGB zpìt na 100%</span></p>
<p class="src2">glPixelTransferf(GL_GREEN_SCALE,1.0f);</p>
<p class="src2">glPixelTransferf(GL_BLUE_SCALE,1.0f);</p>
<p></p>
<p class="src1">}</p>
<p class="src1">else</p>
<p class="src2">status = false;</p>
<p></p>
<p class="src1">if (Image)<span class="kom">// Pokud obrázek existuje</span></p>
<p class="src1">{</p>
<p class="src2">if (Image-&gt;data)<span class="kom">// Pokud existují data obrázku</span></p>
<p class="src3">delete Image-&gt;data;<span class="kom">// Uvolní data obrázku</span></p>
<p></p>
<p class="src2">delete Image;<span class="kom">// Uvolní strukturu obrázku</span></p>
<p></p>
<p class="src2">Image = NULL;<span class="kom">// Nastaví ukazatel na NULL</span></p>
<p class="src1">}</p>

<p>Naèítání bitmap log je velmi jednoduché a¾ na zkombinování RGB-A kanálù, nicménì kód by mìl být dostateènì jasný. V¹imnìte si, ¾e tato textura je vytvoøena z dat alpha, nikoliv z dat Image. Bude zde pou¾it pouze jeden filtr.</p>

<div class="okolo_img"><img src="images/nehe_tut/tut_22_opengl_alpha.gif" width="128" height="64" alt="Textura OpenGL_ALPHA" /></div>

<p class="src1"><span class="kom">// Naète bitmapy log</span></p>
<p class="src1">if (Image = auxDIBImageLoad(&quot;Data/OpenGL_ALPHA.bmp&quot;))</p>
<p class="src1">{</p>
<p class="src2">alpha = new char[4*Image-&gt;sizeX*Image-&gt;sizeY];<span class="kom">// Alokuje pamì» pro RGBA8-Texturu</span></p>
<p></p>
<p class="src2">for (int a=0; a &lt; Image-&gt;sizeX * Image-&gt;sizeY; a++)</p>
<p class="src3">alpha[4*a+3] = Image-&gt;data[a*3];<span class="kom">// Vezme pouze èervenou barvu jako alpha kanál</span></p>

<div class="okolo_img"><img src="images/nehe_tut/tut_22_opengl.gif" width="128" height="64" alt="Textura OpenGL" /></div>

<p></p>
<p class="src2">if (!(Image = auxDIBImageLoad(&quot;Data/OpenGL.bmp&quot;)))</p>
<p class="src3">status = false;</p>
<p></p>
<p class="src2">for (a = 0; a &lt; Image-&gt;sizeX * Image-&gt;sizeY; a++)</p>
<p class="src2">{</p>
<p class="src3">alpha[4*a]=Image-&gt;data[a*3];<span class="kom">// R</span></p>
<p class="src3">alpha[4*a+1]=Image-&gt;data[a*3+1];<span class="kom">// G</span></p>
<p class="src3">alpha[4*a+2]=Image-&gt;data[a*3+2];<span class="kom">// B</span></p>
<p class="src2">}</p>
<p></p>
<p class="src2">glGenTextures(1, &amp;glLogo);<span class="kom">// Vytvoøí jednu texturu</span></p>
<p></p>
<p class="src2"><span class="kom">// Vytvoøí lineárnì filtrovanou RGBA8-Texturu</span></p>
<p class="src2">glBindTexture(GL_TEXTURE_2D, glLogo);</p>
<p class="src2">glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);</p>
<p class="src2">glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);</p>
<p class="src2">glTexImage2D(GL_TEXTURE_2D, 0, <span class="warning">GL_RGBA8</span>, Image-&gt;sizeX, Image-&gt;sizeY, 0, GL_RGBA, GL_UNSIGNED_BYTE, alpha);</p>
<p></p>
<p class="src2">delete alpha;<span class="kom">// Uvolní alokovanou pamì»</span></p>
<p class="src1">}</p>
<p class="src1">else</p>
<p class="src2">status = false;</p>
<p></p>
<p class="src1">if (Image)<span class="kom">// Pokud obrázek existuje</span></p>
<p class="src1">{</p>
<p class="src2">if (Image-&gt;data)<span class="kom">// Pokud existují data obrázku</span></p>
<p class="src3">delete Image-&gt;data;<span class="kom">// Uvolní data obrázku</span></p>
<p></p>
<p class="src2">delete Image;<span class="kom">// Uvolní strukturu obrázku</span></p>
<p></p>
<p class="src2">Image = NULL;<span class="kom">// Nastaví ukazatel na NULL</span></p>
<p class="src1">}</p>

<div class="okolo_img"><img src="images/nehe_tut/tut_22_multi_on_alpha.gif" width="256" height="64" alt="Textura Extension Enabled ALFA" /></div>

<p class="src1">if (Image = auxDIBImageLoad(&quot;Data/multi_on_alpha.bmp&quot;))</p>
<p class="src1">{</p>
<p class="src2">alpha = new char[4*Image-&gt;sizeX*Image-&gt;sizeY];<span class="kom">// Alokuje pamì» pro RGBA8-Texturu</span></p>
<p></p>
<p class="src2">for (int a = 0; a &lt; Image-&gt;sizeX * Image-&gt;sizeY; a++)</p>
<p class="src3">alpha[4*a+3]=Image-&gt;data[a*3];<span class="kom">// Vezme pouze èervenou barvu jako alpha kanál</span></p>

<div class="okolo_img"><img src="images/nehe_tut/tut_22_multi_on.gif" width="256" height="64" alt="Textura Extension Enabled" /></div>

<p class="src2">if (!(Image=auxDIBImageLoad(&quot;Data/multi_on.bmp&quot;)))</p>
<p class="src3">status = false;</p>
<p></p>
<p class="src2">for (a=0; a &lt; Image-&gt;sizeX * Image-&gt;sizeY; a++)</p>
<p class="src3">{</p>
<p class="src3">alpha[4*a] = Image-&gt;data[a*3];<span class="kom">// R</span></p>
<p class="src3">alpha[4*a+1] = Image-&gt;data[a*3+1];<span class="kom">// G</span></p>
<p class="src3">alpha[4*a+2] = Image-&gt;data[a*3+2];<span class="kom">// B</span></p>
<p class="src2">}</p>
<p class="src0"></p>
<p></p>
<p class="src2">glGenTextures(1, &amp;multiLogo);<span class="kom">// Vytvoøí jednu texturu</span></p>
<p></p>
<p class="src2"><span class="kom">// Vytvoøí lineárnì filtrovanou RGBA8-Texturu</span></p>
<p class="src2">glBindTexture(GL_TEXTURE_2D, multiLogo);</p>
<p class="src2">glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);</p>
<p class="src2">glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);</p>
<p class="src2">glTexImage2D(GL_TEXTURE_2D, 0, <span class="warning">GL_RGBA8</span>, Image-&gt;sizeX, Image-&gt;sizeY, 0, GL_RGBA, GL_UNSIGNED_BYTE, alpha);</p>
<p></p>
<p class="src2">delete alpha;</p>
<p class="src1">}</p>
<p class="src1">else</p>
<p class="src2">status = false;</p>
<p></p>
<p class="src1">if (Image)<span class="kom">// Pokud obrázek existuje</span></p>
<p class="src1">{</p>
<p class="src2">if (Image-&gt;data)<span class="kom">// Pokud existují data obrázku</span></p>
<p class="src3">delete Image-&gt;data;<span class="kom">// Uvolní data obrázku</span></p>
<p></p>
<p class="src2">delete Image;<span class="kom">// Uvolní strukturu obrázku</span></p>
<p></p>
<p class="src2">Image = NULL;<span class="kom">// Nastaví ukazatel na NULL</span></p>
<p class="src1">}</p>
<p></p>
<p class="src1">return status;<span class="kom">// Vrátí status</span></p>
<p class="src0">}</p>

<p>Následuje funkce doCube(), která kreslí krychli spolu s normálami. V¹imnìte si, ¾e tato verze zatì¾uje pouze texturovací jednotku #0, glTexCoord(s, t) pracuje stejnì jako glMultiTexCoord(GL_TEXTURE0_ARB, s, t). Krychle mù¾e být taky vykreslena pomocí prokládaných polí, to ale teï nebudeme øe¹it. Nemù¾e v¹ak být ulo¾ena na display listu, ty pou¾ívají pravdìpodobnì pøesnost rùznou od GLfloat, co¾ vede k nepìkným vedlej¹ím efektùm.</p>

<p class="src0">void doCube(void)</p>
<p class="src0">{</p>
<p class="src1">int i;</p>
<p></p>
<p class="src1">glBegin(GL_QUADS);</p>
<p></p>
<p class="src2"><span class="kom">// Pøední stìna</span></p>
<p class="src2">glNormal3f( 0.0f, 0.0f, +1.0f);</p>
<p class="src2">for (i=0; i&lt;4; i++)</p>
<p class="src2">{</p>
<p class="src3">glTexCoord2f(data[5*i],data[5*i+1]);</p>
<p class="src3">glVertex3f(data[5*i+2],data[5*i+3],data[5*i+4]);</p>
<p class="src2">}</p>
<p></p>
<p class="src2"><span class="kom">// Zadní stìna</span></p>
<p class="src2">glNormal3f( 0.0f, 0.0f,-1.0f);</p>
<p class="src2">for (i=4; i&lt;8; i++)</p>
<p class="src2">{</p>
<p class="src3">glTexCoord2f(data[5*i],data[5*i+1]);</p>
<p class="src3">glVertex3f(data[5*i+2],data[5*i+3],data[5*i+4]);</p>
<p class="src2">}</p>
<p></p>
<p class="src2"><span class="kom">// Horní stìna</span></p>
<p class="src2">glNormal3f( 0.0f, 1.0f, 0.0f);</p>
<p class="src2">for (i=8; i&lt;12; i++)</p>
<p class="src2">{</p>
<p class="src3">glTexCoord2f(data[5*i],data[5*i+1]);</p>
<p class="src3">glVertex3f(data[5*i+2],data[5*i+3],data[5*i+4]);</p>
<p class="src2">}</p>
<p></p>
<p class="src2"><span class="kom">// Spodní stìna</span></p>
<p class="src2">glNormal3f( 0.0f,-1.0f, 0.0f);</p>
<p class="src2">for (i=12; i&lt;16; i++)</p>
<p class="src2">{</p>
<p class="src3">glTexCoord2f(data[5*i],data[5*i+1]);</p>
<p class="src3">glVertex3f(data[5*i+2],data[5*i+3],data[5*i+4]);</p>
<p class="src2">}</p>
<p></p>
<p class="src2"><span class="kom">// Pravá stìna</span></p>
<p class="src2">glNormal3f( 1.0f, 0.0f, 0.0f);</p>
<p class="src2">for (i=16; i&lt;20; i++)</p>
<p class="src2">{</p>
<p class="src3">glTexCoord2f(data[5*i],data[5*i+1]);</p>
<p class="src3">glVertex3f(data[5*i+2],data[5*i+3],data[5*i+4]);</p>
<p class="src2">}</p>
<p></p>
<p class="src2"><span class="kom">// Levá stìna</span></p>
<p class="src2">glNormal3f(-1.0f, 0.0f, 0.0f);</p>
<p class="src2">for (i=20; i&lt;24; i++)</p>
<p class="src2">{</p>
<p class="src3">glTexCoord2f(data[5*i],data[5*i+1]);</p>
<p class="src3">glVertex3f(data[5*i+2],data[5*i+3],data[5*i+4]);</p>
<p class="src2">}</p>
<p></p>
<p class="src1">glEnd();</p>
<p class="src0">}</p>

<p>Pøichází èas na inicializaci OpenGL. V¹e je jako v lekci 06, kromì toho, ¾e zavoláme funkci initLights(), místo toho, abychom svìtla nastavovali zde. A je¹tì samozøejmì voláme nastavení pøípadného multitexturingu.</p>

<p class="src0">int InitGL(GLvoid)<span class="kom">// V¹echno nastavení OpenGL</span></p>
<p class="src0">{</p>
<p class="src1">multitextureSupported = initMultitexture();</p>
<p></p>
<p class="src1">if (!LoadGLTextures())<span class="kom">// Vytvoøení textur</span></p>
<p class="src2">return false;</p>
<p></p>
<p class="src1">glEnable(GL_TEXTURE_2D);<span class="kom">// Zapne texturové mapování</span></p>
<p class="src1">glShadeModel(GL_SMOOTH);<span class="kom">// Zapne smooth shading</span></p>
<p class="src1">glClearColor(0.0f, 0.0f, 0.0f, 0.5f);<span class="kom">// Èerné pozadí</span></p>
<p class="src1">glClearDepth(1.0f);<span class="kom">// Nastavení hloubkového bufferu</span></p>
<p class="src1">glEnable(GL_DEPTH_TEST);<span class="kom">// Povolení testování hloubky</span></p>
<p class="src1">glDepthFunc(GL_LEQUAL);<span class="kom">// Typ testování hloubky</span></p>
<p class="src1">glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);<span class="kom">// Kvalitní výpoèty perspektivy</span></p>
<p></p>
<p class="src1">initLights();<span class="kom">// Inicializace svìtel</span></p>
<p></p>
<p class="src1">return true;<span class="kom">// V¹e v poøádku</span></p>
<p class="src0">}</p>

<hr />

<p><b>Zaèátek teorie (Emboss Bump Mapping)</b></p>

<p>Zde je asi 95% práce. V¹e u èeho bylo napsáno, ¾e bude vysvìtleno pozdìji, je v následující teoretické sekci. Jedná se o pøepsání prezentace v PowerPointu do HTML.</p>

<p><b>Emboss Bump Mapping</b></p>

<p>Michael I. Gold - NVidia Corporation</p>

<p><b>Bump Mapping</b></p>

<p>Skuteèný bump mapping pou¾ívá per-pixel osvìtlení.</p>

<ul>
<li>Výpoèet osvìtlení na ka¾dém pixelu zalo¾ené na rùzných normálových vektorech.</li>
<li>Výpoèetnì velmi nároèné.</li>
<li>Pro více informací se podívejte na: Blinn, J. : Simulation of Wrinkled Surfaces, Computer Graphics. 12,3 (August 1978) 286-292.</li>
<li>Pro informace na webu zajdìte na: <a href="http://www.r3.nu/" target="_blank">http://www.r3.nu/</a> a podívejte se na Cass Everitt's Orthogonal Illumination Thesis. (pozn.: Jens)</li>
</ul>

<p><b>Emboss Bump Mapping</b></p>

<p>Emboss Bump Mapping je pouze náhra¾ka.</p>

<ul>
<li>Pouze difuzní osvìtlení, ¾ádné odra¾ené.</li>
<li>Výskyt artefaktù (mù¾e vést k rozmazanému pohybu pozn.: Jens)</li>
<li>Dostupné na dne¹ním hardwaru</li>
<li>Vypadá celkem slu¹nì</li>
</ul>

<p><b>Výpoèet difúzního osvìtlení</b></p>

<p>C = (L * N) x Dl x Dm</p>

<ul>
<li>L je vektor svìtla</li>
<li>N je normálový vektor</li>
<li>Dl je barva difusního svìtla</li>
<li>Dm je difusní barva materiálu</li>
<li>Bump Mapping mìní pro ka¾dý pixel N</li>
<li>Emboss Bump Mapping se blí¾í L * N</li>
</ul>

<p><b>Pøibli¾ný stupeò rozptylu L * N</b></p>

<p>Textura reprezentuje vý¹kovou mapu</p>

<ul>
<li>[0,1] urèuje interval prohybu (vý¹kového rozdílu)</li>
<li>První odvození reprezentuje sklon (úhel) m - m je pouze jednorozmìrné - reprezentuje sklon na souøadnicích (s,t) dané textury (pozn.: Jens)</li>
<li>m zvy¹uje nebo sni¾uje základní stupeò rozptylu Fd</li>
<li>(Fd + m) se blí¾í (L * N) na pixel</li>
</ul>

<p><b>Pøibli¾né odvození</b></p>

<p>Zohlednìní pøibli¾ných údajù</p>

<ul>
<li>Vyvý¹ení H0 v bodì o souøadnicích (s,t)</li>
<li>Vyvý¹ení H1 v bodì mírnì posunutém ke zdroji svìtla (s + ds, t + dt)</li>
<li>Odeètení pùvodní vý¹ky H0 od posunuté H1</li>
<li>Rozdíl je okam¾itým sklonem m = H1 - H0</li>
</ul>


<p><b>Spoèítání reliéfu</b></p>

<p>1) Pùvodní reliéf (H0).</p>
<div class="okolo_img"><img src="images/nehe_tut/tut_22_image002.jpg" width="140" height="48" alt="Pùvodní reliéf (H0)" /></div>

<p>2) Pùvodní reliéf (H0) prolo¾ený druhým (H1), který je mírnì posunutý smìrem ke svìtlu.</p>

<div class="okolo_img"><img src="images/nehe_tut/tut_22_image004.jpg" width="216" height="91" alt="Pùvodní reliéf (H0) prolo¾ený druhým (H1), který je mírnì posunutý smìrem ke svìtlu" /></div>

<p>3) Odeètení pùvodního od posunutého reliéfu (H0-H1) - vede ke vzniku svìtlých (B) a tmavých (D) ploch.</p>

<div class="okolo_img"><img src="images/nehe_tut/tut_22_image006.jpg" width="173" height="48" alt="Odeètení pùvodního od posunutého reliéfu (H0-H1) - vede ke vzniku svìtlých (B) a tmavých (D) ploch" /></div>

<p><b>Výpoèet osvìtlení</b></p>

<p>Urèíme hodnotu barvy (Cf) dané plochy</p>

<ul>
<li>Cf = (L * N) x Dl x Dm</li>
<li>(L * N) ~ (Fd + (H0 - H1))</li>
<li>Dm x Dl je vlastnì ji¾ urèen texturou Ct. Jinak mù¾ete pracovat s Dl a Dm samostatnì, pokud jste dostateènì zdatní. (To se provádí pomocí OpenGL-Lighting! pozn.: Jens)</li>
<li>Cf = (Fd + (H0 - H1)) x Ct</li>
</ul>

<p><b>Je to v¹e? Takhle jednoduché?!</b></p>

<p>Je¹tì nejsme úplnì hotoví. Stále musíme:</p>

<ul>
<li>Vytvoøit texturu (pomocí grafického editoru pozn.: Jens)</li>
<li>Spoèítat posunutí textury (ds,dt)</li>
<li>Spoèítat stupeò rozptylu Fd (pomocí OpenGL-Lighting! pozn.: Jens)</li>
<li>Obojí je odvozeno z normály N a vektoru svìtla L (v na¹em pøípadì se spoèítá pøesnì pouze (ds,dt)! pozn.: Jens)</li>
<li>Teï si dáme tro¹ku matematiky</li>
</ul>

<p><b>Tvorba textury</b></p>

<p>Uchovávejte textury!</p>

<ul>
<li>Souèasný multitexturovací hardware podporuje pouze dvì textury!</li>
<li>Bumpmapa v alpha kanálu (my to tímto zpùsobem nedìláme, ale mù¾ete si to zkusit jako takové cvièení, pokud máte TNT chipset pozn.:Jens)</li>
<li>Maximální prohyb = 1.0</li>
<li>Základní vý¹ka = 0.5</li>
<li>Maximální pokles = 0.0</li>
<li>Barva povrchu v RGB kanálech</li>
<li>Nastavit interní formát na GL_RGBA8 !!</li>
</ul>

<p><b>Výpoèet offsetu textury</b></p>

<p>Pootoèení vektoru svìtla</p>

<ul>
<li>Potøeba je normální souøadnicový systém</li>
<li>Odvození souøadnicového systému z normálového a "horního" vektoru (my pøedáme smìr texturovacích souøadnic do na¹eho generátoru posunutí explicitnì pozn.: Jens)</li>
<li>Normála je osa z</li>
<li>Meziprodukt je osa x</li>
<li>Zahození &quot;horního&quot; vektoru, odvození osy y z os x a z</li>
<li>Vytvoøení matice Mn 3x3 ze spoèítaných os</li>
<li>Transformace vektoru svìtla do normálního prostoru (Mn se taky nazývá ortonormální základ pozn.: Jens)</li>
</ul>

<p><b>Výpoèet offsetu textury (pokraèování)</b></p>

<p>Pou¾ijte pro posunutí vektor svìtla normálního prostoru</p>

<ul>
<li>L' = Mn x L</li>
<li>Pou¾ít L'x, L'y pro (ds, dt)</li>
<li>Pou¾ít L'z pro stupeò rozptylu! (Radìji ne! Pokud nevlastníte TNT, pou¾ijte místo toho OpenGL-Lighting, jinak byste museli renderovat jeden cyklus navíc! pozn.: Jens)</li>
<li>Pokud je vektor svìtla blízký normále, L'x, L'y jsou nízké</li>
<li>Pokud se vektor svìtla blí¾í tangentové rovinì, L'x, L'y jsou vysoké</li>
<li>Co kdy¾ je L'z men¹í ne¾ nula?</li>
<li>Svìtlo je na opaèné stranì ne¾ normála</li>
<li>Pak se bude rovnat nule.</li>
</ul>

<p><b>Implementace na TNT</b></p>

<p>Spoèítejte vektory, texturovací souøadnice na hostiteli</p>

<ul>
<li>Pøedejte stupeò rozptylu v alpha kanálu</li>
<li>Mohli byste vyu¾ít barvu vertexu pro barvu rozptýleného svìtla</li>
<li>H0 a barvu z texturovací jednotky 0</li>
<li>H1 z texturovací jednotky 1 (stejná textura jiné souøadnice)</li>
<li>ARB_multitexture extension</li>
<li>Zkombinuje extension (preciznìji: NVIDIA_multitexture_combiners extension, podporované v¹emi akcelerátory rodiny TNT pozn.: Jens)</li>
</ul>

<p><b>Implementace na TNT (pokraèování)</b></p>

<p>Nastavení alpha kanálu na combineru</p>

<ul>
<li>(1-T0a) + T1a - 0.5 (T0a zastupuje &quot;texturovací jednotku 0, alpha kanál&quot; pozn.: Jens)</li>
<li>(T1a-T0a) se namapuje na (-1,1), ale hardware ji pøipevní na (0,1)</li>
<li>Pøednastavení 0.5 vyva¾uje ztrátu oproti uchycení (zva¾te u¾ití 0.5, mohli byste dosáhnout vìt¹í rozmanitosti bumpmap, pozn.: Jens)</li>
<li>Mù¾ete pøizpùsobit barvu rozptýleného svìtla T0c</li>
<li>RGB nastavení combineru 0:</li>
<li>(T0c * C0a + T0c * Fda - 0.5)*2</li>
<li>0.5 vyva¾uje ztrátu oproti uchycení</li>
<li>Násobení dvìma prosvìtlí obraz</li>
</ul>

<p><b>Konec teorie (Emboss Bump Mapping)</b></p>

<hr />

<p>My to ale udìláme trochu jinak ne¾ podle TNT implementace, abychom umo¾nili na¹emu programu bì¾et na V©ECH akcelerátorech. Zde se mù¾eme pøiuèit dvì nebo tøi vìci. Jedna z nich je, ¾e bumpmapping je více fázový algoritmus na vìt¹inì karet (ne na TNT, kde se to dá nahradit jednou dvou-texturovací fází). U¾ byste si mìli být schopni pøedstavit, jak hezký multitexturing ve skuteènosti je. Nyní implementujeme 3-fázový netexturovací algoritmus, který pak mù¾e být (a bude) vylep¹en na 2 fázový texturovací algoritmus.</p>

<p>Teï byste si mìli uvìdomit, ¾e musíme udìlat nìjaké násobení matice maticí (a násobení vektoru maticí). Ale to není nic èeho bychom se mìli obávat: OpenGL zvládne násobení matice maticí za nás a násobení vektoru maticí je celkem jednoduché: funkce VMatMult(M,v) vynásobí matici M s vektorem v a výsledek ulo¾í zpìt ve v: v = M * v. V¹echny matice a vektory pøedané funkci musejí mít stejný tvar: matice 4x4 a 4-rozmìrné vektory. To je pro zaji¹tìní kompatibility s OpenGL.</p>

<p class="src0">void VMatMult(GLfloat *M, GLfloat *v)</p>
<p class="src0">{</p>
<p class="src1">GLfloat res[3];</p>
<p></p>
<p class="src1">res[0] = M[0]*v[0]+M[1]*v[1]+M[ 2]*v[2]+M[ 3]*v[3];</p>
<p class="src1">res[1] = M[4]*v[0]+M[5]*v[1]+M[ 6]*v[2]+M[ 7]*v[3];</p>
<p class="src1">res[2] = M[8]*v[0]+M[9]*v[1]+M[10]*v[2]+M[11]*v[3];</p>
<p></p>
<p class="src1">v[0]=res[0];</p>
<p class="src1">v[1]=res[1];</p>
<p class="src1">v[2]=res[2];</p>
<p></p>
<p class="src1">v[3]=M[15];<span class="kom">// Homogenní souøadnice</span></p>
<p class="src0">}</p>

<hr />

<p><b>Zaèátek teorie (algoritmy pro Emboss Bump Mapping)</b></p>

<p>Zde se zmíníme o dvou odli¹ných algoritmech. První popisuje program, který se jmenuje GL_BUMP a napsal ho Diego Tártara v roce 1999. I pøes pár nevýhod velmi pìknì implementuje bumpmapping. Teï se na tento algoritmus podíváme:</p>

<ol>
<li>V¹echny vektory musí být BUÏ v prostoru objektu NEBO v prostoru scény</li>
<li>Spoèítání vektoru v z aktuální pozice vertexu vzhledem ke svìtlu</li>
<li>Normalizace v</li>
<li>Promítnutí v do tangenoidního prostoru. (To je plocha, která se dotýká daného vertexu. Pokud pracujete s rovnými plochami, tak je to zpravidla plocha samotná.)</li>
<li>Posuneme souøadnice (s,t) o slo¾ky x,y vektoru v</li>
</ol>

<p>To nevypadá ¹patnì! V podstatì je to algoritmus popsaný Michaelem I. Goldem vý¹e. Má v¹ak zásadní nevýhodu: Támara pou¾ívá projekci pouze pro rovinu xy. To pro na¹e potøeby nestaèí, proto¾e zjednodu¹uje promítací krok pouze na slo¾ky x a y a se slo¾kou z vektoru v vùbec nepoèítá.</p>

<p>Ale tato implementace vytvoøí rozptýlené svìtlo stejným zpùsobem, jako ho budeme dìlat my: s pou¾itím v OpenGL zabudované podpory osvìtlení. Tak¾e nemù¾eme pou¾ít metodu kombinerù, jakou navrhuje Gold (Chceme, aby na¹e programy bì¾ely i na jiných ne¾ TNT kartách!), nemù¾eme ulo¾it stupeò rozptylu do alpha kanálu. Tak ji¾ máme problém s 3 fázovým netexturovaním a 2 fázovým texturováním, proè na poslední prùchod nepou¾ít OpenGL-Lighting, aby za nás dodìlal ambientní svìtlo a barvy? Je to mo¾né (a výsledek vypadá celkem dobøe), ale jen proto, ¾e nyní nepou¾íváme slo¾itou geometrii. Tohle byste si mìli zapamatovat. Pokud budete chtít renderovat nìkolik tisíc bumpmapovaných trojúhelníkù, zkuste objevit nìco jiného.</p>

<p>Navíc, pou¾ívá multitexturing (jak mù¾eme vidìt) ne tak jednodu¹e jako my s ohledem na tento speciální pøípad.</p>

<p>Ale teï k na¹í implementaci. Vypadá podobnì jako algoritmus pøedtím, kromì projekèní fáze, kde pou¾ijeme vlastní postup:</p>

<ul>
<li>Pou¾ijeme SOUØADNICE OBJEKTU, to znamená, ¾e nepou¾ijeme matici modelu pøi výpoètech. Tohle má za pøíèinu nemilý vedlej¹í efekt: kdy¾ chceme otáèet krychlí, souøadnice v objektu se nezmìní, ale souøadnice vertexu v souøadnicích scény (vzhledem k oèím) se zmìní. Ale pozice na¹eho svìtla by se nemìla pohybovat s krychlí, mìla by být statická, co¾ znamená, ¾e souøadnice by se nemìly mìnit. Abychom to vykompenzovali, pou¾ijeme malý trik, bì¾nì u¾ívaný s poèítaèové grafice: místo transformace ka¾dého vertexu do prostoru svìta kvùli bumpmapám, pøevedeme souøadnice svìtla do prostoru objektu s pou¾itím inverzní matice modelu. Tohle je velmi snadné, vzhledem k tomu, ¾e pøesnì víme, jak jsme vytvoøili matici modelu, není problém tento postup obrátit. K tomu se je¹tì dostaneme.</li>
<li>Spoèítáme daný vertex c na povrchu.</li>
<li>Pak spoèítáme normálu n s délkou 1 (vìt¹inou známe n pro ka¾dou stìnu krychle). To je dùle¾ité, mù¾eme tak u¹etøit èas pøi zji¹»ování normalizovaných vektorù. Spoèítáme vektor svìtla v z vektoru c smìøujícímu k pozici svìtla l.</li>
<li>Pokud je tøeba je¹tì nìco udìlat, sestavíme matici Mn reprezentující ortonormální projekci.</li>
<li>Spoèítáme posunutí souøadnic textury vynásobením daných souøadnic textury (s a t) a v a MAX_EMBOSS: ds = s*v*MAX_EMBOSS, dt= t*v*MAX_EMBOSS. V¹imnìte si, ¾e s,t a v jsou vektory, ale MAX_EMBOSS není.</li>
<li>V druhé fázi pøidáme posunutí k souøadnicím textury.</li>
</ul>

<p><b>Proè je to dobré?</b></p>

<ul>
<li>Rychlost (jen pár odmocnin a násobení vertexù)</li>
<li>Vypadá dobøe!</li>
<li>Funguje se v¹emi povrchy, nejen s rovinami.</li>
<li>Bì¾í na v¹ech akcelerátorech.</li>
<li>Je glBegin/glEnd pøátelská: nepotøebuje &quot;zakázané&quot; GL pøíkazy.</li>
</ul>

<p><b>Nevýhody:</b></p>

<ul>
<li>Není úplnì fyzíkálnì správné.</li>
<li>Zanechává men¹í artefakty.</li>
</ul>

<p>Tento náèrtek ukazuje, kde se nacházejí jednotlivé vektory. Mù¾ete jednodu¹e získat t a s odeètením jesnosti jednotlivých vektorù, ale ujistìte se, ¾e jsou správnì natoèené a normalizované. Modrý bod oznaèuje vertex, kde je namapován texCoord2f(0.0f, 0.0f).</p>

<div class="okolo_img"><img src="images/nehe_tut/tut_22_image008.jpg" width="412" height="243" alt="Lokace vektorù" /></div>

<p><b>Konec teorie (algoritmy pro Emboss Bump Mapping)</b></p>

<hr />

<p>Teï se podívejme na generátor posunutí textury. Tato funkce se jmenuje SetUpBumps().</p>

<p class="src0"><span class="kom">// Funkce nastaví posunutí textury</span></p>
<p class="src0"><span class="kom">// n : normála k plo¹e, musí mít délku 1</span></p>
<p class="src0"><span class="kom">// c : nìjaký bod na povrchu</span></p>
<p class="src0"><span class="kom">// l : pozice svìtla</span></p>
<p class="src0"><span class="kom">// s : smìr texturovacích souøadnic s (musí být normalizován!)</span></p>
<p class="src0"><span class="kom">// t : smìr texturovacích souøadnic t (musí být normalizován!)</span></p>
<p></p>
<p class="src0">void SetUpBumps(GLfloat *n, GLfloat *c, GLfloat *l, GLfloat *s, GLfloat *t)</p>
<p class="src0">{</p>
<p class="src1">GLfloat v[3];<span class="kom">// Vertex z aktuální pozice ke svìtlu</span></p>
<p class="src1">GLfloat lenQ;<span class="kom">// Pou¾ito pøi normalizaci</span></p>
<p></p>
<p class="src1"><span class="kom">// Spoèítání v z aktuálního vertexu c ke svìtlu a jeho normalizace</span></p>
<p class="src1">v[0] = l[0] - c[0];</p>
<p class="src1">v[1] = l[1] - c[1];</p>
<p class="src1">v[2] = l[2] - c[2];</p>
<p></p>
<p class="src1">lenQ = (GLfloat) sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);</p>
<p></p>
<p class="src1">v[0] /= lenQ;</p>
<p class="src1">v[1] /= lenQ;</p>
<p class="src1">v[2] /= lenQ;</p>
<p></p>
<p class="src1"><span class="kom">// Zohlednìní v tak, abychom dostali texturovací souøadnice</span></p>
<p class="src1">c[0] = (s[0]*v[0] + s[1]*v[1] + s[2]*v[2]) * MAX_EMBOSS;</p>
<p class="src1">c[1] = (t[0]*v[0] + t[1]*v[1] + t[2]*v[2]) * MAX_EMBOSS;</p>
<p class="src0">}</p>

<p>Nepøipadá vám to tak komplikované jako pøedtím? Teorie je ale dùle¾itá, abyste pochopili jak efekt funguje a jak ho ovládat. Bìhem psaní tutoriálu jsem se to sám nauèil :-]</p>

<p>V¾dycky jsem chtìl zobrazit logo pøi bìhu ukázkového programu. My teï taky dvì zobrazíme. Zavoláme funkci doLogo(). Ta vyresetuje GL_MODELVIEW matici, která musí být pøi posledním prùchodu zavolána.</p>

<p>Tato funkce zobrazí dvì loga: OpenGl logo a logo multitexturingu, pokud je povolen. Loga jsou zèásti prùhledná. Proto¾e mají alpha kanál, smícháme je pomocí GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA podle OpenGL dokumentace. Obì dvì jsou ploché, nemáme pro nì souøadnici z. Èísla pou¾itá pro hrany jsou zji¹tìny "empiricky" (pokus-chyba), tak aby loga padla pìknì do ro¾kù. Musíme zapnout blending a vypnout svìtla, abychom se vyhli chybným efektùm. Abychom zajistili, ¾e loga budou v¾dy vepøedu, vyresetujeme GL_MODELVIEW matici a nastavíme funkci na testování hloubky na GL_ALWAYS.</p>

<p class="src0">void doLogo(void)<span class="kom">// MUSÍ SE ZAVOLAT A® NAKONEC!!! Zobrazí dvì loga</span></p>
<p class="src0">{</p>
<p class="src1">glDepthFunc(GL_ALWAYS);</p>
<p class="src1">glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);</p>
<p></p>
<p class="src1">glEnable(GL_BLEND);</p>
<p class="src1">glDisable(GL_LIGHTING);</p>
<p></p>
<p class="src1">glLoadIdentity();</p>
<p></p>
<p class="src1">glBindTexture(GL_TEXTURE_2D,glLogo);</p>
<p></p>
<p class="src1">glBegin(GL_QUADS);</p>
<p class="src2">glTexCoord2f(0.0f,0.0f); glVertex3f(0.23f, -0.4f,-1.0f);</p>
<p class="src2">glTexCoord2f(1.0f,0.0f); glVertex3f(0.53f, -0.4f,-1.0f);</p>
<p class="src2">glTexCoord2f(1.0f,1.0f); glVertex3f(0.53f, -0.25f,-1.0f);</p>
<p class="src2">glTexCoord2f(0.0f,1.0f); glVertex3f(0.23f, -0.25f,-1.0f);</p>
<p class="src1">glEnd();</p>
<p></p>
<p class="src1">if (useMultitexture)</p>
<p class="src1">{</p>
<p class="src2">glBindTexture(GL_TEXTURE_2D,multiLogo);</p>
<p></p>
<p class="src2">glBegin(GL_QUADS);</p>
<p class="src3">glTexCoord2f(0.0f,0.0f); glVertex3f(-0.53f, -0.4f,-1.0f);</p>
<p class="src3">glTexCoord2f(1.0f,0.0f); glVertex3f(-0.33f, -0.4f,-1.0f);</p>
<p class="src3">glTexCoord2f(1.0f,1.0f); glVertex3f(-0.33f, -0.3f,-1.0f);</p>
<p class="src3">glTexCoord2f(0.0f,1.0f); glVertex3f(-0.53f, -0.3f,-1.0f);</p>
<p class="src2">glEnd();</p>
<p class="src1">}</p>
<p></p>
<p class="src1">glDepthFunc(GL_LEQUAL);</p>
<p class="src0">}</p>

<p>Teï pøichází funkce na bumpmapping bez texturingu. Je to tøí-prùchodová implementace. Jako první GL_MODELVIEW matice se pøevrátí pomocí aplikace v¹ech provedených krokù v opaèném poøadí a obrácenì na matici dané identity. Výsledkem je matice, která pøi aplikaci na objekt &quot;vrací&quot; GL_MODELVIEW. My jí jednodu¹e získáme funkcí glGetFloatv(). Pamatujte, ¾e matice musí být pole s 16 prvky a ¾e je tato matice &quot;pøesunuta&quot;!</p>

<p>Mimochodem: Kdy¾ pøesnì nevíte, jak se s maticí manipuluje, zva¾te pou¾ití globálních souøadnic, proto¾e pøevracení matice je slo¾ité a nároèné na èas. Ale pokud pou¾íváte mnoho vertexù, pøevracení matice mù¾e být daleko rychlej¹í.</p>

<p class="src0">bool doMesh1TexelUnits(void)</p>
<p class="src0">{</p>
<p class="src1">GLfloat c[4] = {0.0f, 0.0f, 0.0f, 1.0f};<span class="kom">// Aktuální vertex</span></p>
<p class="src1">GLfloat n[4] = {0.0f, 0.0f, 0.0f, 1.0f};<span class="kom">// Normalizovaná normála daného povrchu</span></p>
<p class="src1">GLfloat s[4] = {0.0f, 0.0f, 0.0f, 1.0f};<span class="kom">// Smìr texturovacích souøadnic s, normalizováno</span></p>
<p class="src1">GLfloat t[4] = {0.0f, 0.0f, 0.0f, 1.0f};<span class="kom">// Smìr texturovacích souøadnic t, normalizováno</span></p>
<p></p>
<p class="src1">GLfloat l[4];<span class="kom">// Pozice svìtla, která bude transformována do prostoru objektu</span></p>
<p class="src1">GLfloat Minv[16];<span class="kom">// Pøevrácená modelview matice</span></p>
<p></p>
<p class="src1">int i;</p>
<p></p>
<p class="src1">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<span class="kom">// Sma¾e obrazovku a hloubkový buffer</span></p>
<p></p>
<p class="src1"><span class="kom">// Sestavení pøevrácené modelview matice; nahradí funkce Push a Pop jednou funkcí glLoadIdentity()</span></p>
<p class="src1"><span class="kom">// Jednoduché sestavení tím, ¾e v¹echny transformace provedeme opaènì a v opaèném poøadí</span></p>
<p></p>
<p class="src1">glLoadIdentity();</p>
<p></p>
<p class="src1">glRotatef(-yrot,0.0f,1.0f,0.0f);</p>
<p class="src1">glRotatef(-xrot,1.0f,0.0f,0.0f);</p>
<p class="src1">glTranslatef(0.0f,0.0f,-z);</p>
<p></p>
<p class="src1">glGetFloatv(GL_MODELVIEW_MATRIX,Minv);</p>
<p></p>
<p class="src1">glLoadIdentity();</p>
<p></p>
<p class="src1">glTranslatef(0.0f,0.0f,z);</p>
<p class="src1">glRotatef(xrot,1.0f,0.0f,0.0f);</p>
<p class="src1">glRotatef(yrot,0.0f,1.0f,0.0f);</p>
<p></p>
<p class="src1"><span class="kom">// Transformace pozice svìtla do souøadnic objektu:</span></p>
<p class="src1">l[0] = LightPosition[0];</p>
<p class="src1">l[1] = LightPosition[1];</p>
<p class="src1">l[2] = LightPosition[2];</p>
<p class="src1">l[3] = 1.0f;<span class="kom">// Homogení souøadnice</span></p>
<p></p>
<p class="src1">VMatMult(Minv,l);</p>

<p>První fáze:</p>

<ul>
<li>Pou¾ití bump textury</li>
<li>Vypnutí blendingu</li>
<li>Vypnutí svìtel</li>
<li>Pou¾ití texturovacích souøadnic bez posunutí</li>
<li>Vytvoøení geometrie</li>
</ul>

<p>Tohle vyrenderuje krychli pouze z bumpmap.</p>

<p class="src1">glBindTexture(GL_TEXTURE_2D, bump[filter]);</p>
<p class="src1">glDisable(GL_BLEND);</p>
<p class="src1">glDisable(GL_LIGHTING);</p>
<p class="src1">doCube();</p>
<p></p>

<p>Druhá fáze:</p>

<ul>
<li>Pou¾ití pøevrácené bumpmapy</li>
<li>Povolení blendingu GL_ONE, GL_ONE</li>
<li>Ponechá vypnutá svìtla</li>
<li>Pou¾ití posunutých texturovacích souøadnic (Pøed ka¾dou stìnou krychle musíme zavolat funkci SetUpBumps())</li>
<li>Vytvoøení geometrie</li>
</ul>

<p>Tohle vyrendruje krychli se správným emboss bumpmappingem, ale bez barev.</p>
<p>Mohli bychom u¹etøit èas rotací vektoru svìtla opaèným smìrem. To v¹ak nefunguje úplnì správnì, tak to udìláme jinou cestou: otoèíme ka¾dou normálu a prostøední bod stejnì jako na¹i geometrii.</p>

<p class="src1">glBindTexture(GL_TEXTURE_2D,invbump[filter]);</p>
<p class="src1">glBlendFunc(GL_ONE,GL_ONE);</p>
<p class="src1">glDepthFunc(GL_LEQUAL);</p>
<p class="src1">glEnable(GL_BLEND);</p>
<p></p>
<p class="src1">glBegin(GL_QUADS);</p>
<p class="src2"><span class="kom">// Pøední stìna</span></p>
<p class="src2">n[0] = 0.0f;</p>
<p class="src2">n[1] = 0.0f;</p>
<p class="src2">n[2] = 1.0f;</p>
<p></p>
<p class="src2">s[0] = 1.0f;</p>
<p class="src2">s[1] = 0.0f;</p>
<p class="src2">s[2] = 0.0f;</p>
<p></p>
<p class="src2">t[0] = 0.0f;</p>
<p class="src2">t[1] = 1.0f;</p>
<p class="src2">t[2] = 0.0f;</p>
<p></p>
<p class="src2">for (i=0; i&lt;4; i++)</p>
<p class="src2">{</p>
<p class="src3">c[0] = data[5*i+2];</p>
<p class="src3">c[1] = data[5*i+3];</p>
<p class="src3">c[2] = data[5*i+4];</p>
<p></p>
<p class="src3">SetUpBumps(n,c,l,s,t);</p>
<p class="src3">glTexCoord2f(data[5*i]+c[0], data[5*i+1]+c[1]);</p>
<p class="src3">glVertex3f(data[5*i+2], data[5*i+3], data[5*i+4]);</p>
<p class="src2">}</p>
<p></p>
<p class="src2"><span class="kom">// Zadní stìna</span></p>
<p class="src2">n[0] = 0.0f;</p>
<p class="src2">n[1] = 0.0f;</p>
<p class="src2">n[2] = -1.0f;</p>
<p></p>
<p class="src2">s[0] = -1.0f;</p>
<p class="src2">s[1] = 0.0f;</p>
<p class="src2">s[2] = 0.0f;</p>
<p></p>
<p class="src2">t[0] = 0.0f;</p>
<p class="src2">t[1] = 1.0f;</p>
<p class="src2">t[2] = 0.0f;</p>
<p></p>
<p class="src2">for (i=4; i&lt;8; i++)</p>
<p class="src2">{</p>
<p class="src3">c[0] = data[5*i+2];</p>
<p class="src3">c[1] = data[5*i+3];</p>
<p class="src3">c[2] = data[5*i+4];</p>
<p></p>
<p class="src3">SetUpBumps(n,c,l,s,t);</p>
<p class="src3">glTexCoord2f(data[5*i]+c[0], data[5*i+1]+c[1]); </p>
<p class="src3">glVertex3f(data[5*i+2], data[5*i+3], data[5*i+4]);</p>
<p class="src2">}</p>
<p></p>
<p class="src2"><span class="kom">// Horní stìna</span></p>
<p class="src2">n[0] = 0.0f;</p>
<p class="src2">n[1] = 1.0f;</p>
<p class="src2">n[2] = 0.0f;</p>
<p></p>
<p class="src2">s[0] = 1.0f;</p>
<p class="src2">s[1] = 0.0f;</p>
<p class="src2">s[2] = 0.0f;</p>
<p></p>
<p class="src2">t[0] = 0.0f;</p>
<p class="src2">t[1] = 0.0f;</p>
<p class="src2">t[2] = -1.0f;</p>
<p></p>
<p class="src2">for (i=8; i&lt;12; i++)</p>
<p class="src2">{</p>
<p class="src3">c[0] = data[5*i+2];</p>
<p class="src3">c[1] = data[5*i+3];</p>
<p class="src3">c[2] = data[5*i+4];</p>
<p></p>
<p class="src3">SetUpBumps(n,c,l,s,t);</p>
<p class="src3">glTexCoord2f(data[5*i]+c[0], data[5*i+1]+c[1]);</p>
<p class="src3">glVertex3f(data[5*i+2], data[5*i+3], data[5*i+4]);</p>
<p class="src2">}</p>
<p></p>
<p class="src2"><span class="kom">// Spodní stìna</span></p>
<p class="src2">n[0] = 0.0f;</p>
<p class="src2">n[1] = -1.0f;</p>
<p class="src2">n[2] = 0.0f;</p>
<p></p>
<p class="src2">s[0] = -1.0f;</p>
<p class="src2">s[1] = 0.0f;</p>
<p class="src2">s[2] = 0.0f;</p>
<p></p>
<p class="src2">t[0] = 0.0f;</p>
<p class="src2">t[1] = 0.0f;</p>
<p class="src2">t[2] = -1.0f;</p>
<p></p>
<p class="src2">for (i=12; i&lt;16; i++)</p>
<p class="src2">{</p>
<p class="src3">c[0] = data[5*i+2];</p>
<p class="src3">c[1] = data[5*i+3];</p>

<p class="src3">c[2] = data[5*i+4];</p>
<p></p>
<p class="src3">SetUpBumps(n,c,l,s,t);</p>
<p class="src3">glTexCoord2f(data[5*i]+c[0], data[5*i+1]+c[1]);</p>
<p class="src3">glVertex3f(data[5*i+2], data[5*i+3], data[5*i+4]);</p>
<p class="src2">}</p>
<p></p>
<p class="src2"><span class="kom">// Pravá stìna</span></p>
<p class="src2">n[0] = 1.0f;</p>
<p class="src2">n[1] = 0.0f;</p>
<p class="src2">n[2] = 0.0f;</p>
<p></p>
<p class="src2">s[0] = 0.0f;</p>
<p class="src2">s[1] = 0.0f;</p>
<p class="src2">s[2] = -1.0f;</p>
<p></p>
<p class="src2">t[0] = 0.0f;</p>
<p class="src2">t[1] = 1.0f;</p>
<p class="src2">t[2] = 0.0f;</p>
<p></p>
<p class="src2">for (i=16; i&lt;20; i++)</p>
<p class="src2">{</p>
<p class="src3">c[0] = data[5*i+2];</p>
<p class="src3">c[1] = data[5*i+3];</p>
<p class="src3">c[2] = data[5*i+4];</p>
<p></p>
<p class="src3">SetUpBumps(n,c,l,s,t);</p>
<p class="src3">glTexCoord2f(data[5*i]+c[0], data[5*i+1]+c[1]);</p>
<p class="src3">glVertex3f(data[5*i+2], data[5*i+3], data[5*i+4]);</p>
<p class="src2">}</p>
<p></p>
<p class="src2"><span class="kom">// Levá stìna</span></p>
<p class="src2">n[0] = -1.0f;</p>
<p class="src2">n[1] = 0.0f;</p>
<p class="src2">n[2] = 0.0f;</p>
<p></p>
<p class="src2">s[0] = 0.0f;</p>
<p class="src2">s[1] = 0.0f;</p>
<p class="src2">s[2] = 1.0f;</p>
<p></p>
<p class="src2">t[0] = 0.0f;</p>
<p class="src2">t[1] = 1.0f;</p>
<p class="src2">t[2] = 0.0f;</p>
<p></p>
<p class="src2">for (i=20; i&lt;24; i++)</p>
<p class="src2">{</p>
<p class="src3">c[0] = data[5*i+2];</p>
<p class="src3">c[1] = data[5*i+3];</p>
<p class="src3">c[2] = data[5*i+4];</p>
<p></p>
<p class="src3">SetUpBumps(n,c,l,s,t);</p>
<p class="src3">glTexCoord2f(data[5*i]+c[0], data[5*i+1]+c[1]);</p>
<p class="src3">glVertex3f(data[5*i+2], data[5*i+3], data[5*i+4]);</p>
<p class="src2">}</p>
<p class="src1">glEnd();</p>

<p>Tøetí fáze:</p>

<ul>
<li>Pou¾ití základní barevné textury</li>
<li>Povoluní blendingu GL_DST_COLOR, GL_SRC_COLOR</li>
<li>Tuto blending rovnici násobit dvìma: (Cdst*Csrc)+(Csrc*Cdst) = 2(Csrc*Cdst)!</li>
<li>Povolení svìtel, aby vytvoøily ambientní a rozptýlené svìtlo</li>
<li>Vrácení GL_TEXTURE matice zpìt na "normální" texturovací souøadnice</li>
<li>Vytvoøit geometrii</li>
</ul>

<p>Tohle dokonèí renderování krychle s osvìtlením. Nejdøíve musíme nastavit texture environment na GL_MODULATE. Mù¾eme zapínat a vypínat multitexturing. Tuto fázi provedeme, jen pokud u¾ivatel nechce vidìt pouze emboss.</p>

<p class="src1">if (!emboss)</p>
<p class="src1">{</p>
<p class="src2">glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);</p>
<p class="src2">glBindTexture(GL_TEXTURE_2D,texture[filter]);</p>
<p class="src2">glBlendFunc(GL_DST_COLOR,GL_SRC_COLOR);</p>
<p class="src2">glEnable(GL_LIGHTING);</p>
<p></p>
<p class="src2">doCube();</p>
<p class="src1">}</p>

<p>Poslední fáze:</p>

<ul>
<li>Pootoèení krychle pro pøí¹tí kreslení</li>
<li>Nakreslení log</li>
</ul>

<p class="src1">xrot += xspeed;</p>
<p class="src1">yrot += yspeed;</p>
<p></p>
<p class="src1">if (xrot &gt; 360.0f)</p>
<p class="src2">xrot -= 360.0f;</p>
<p></p>
<p class="src1">if (xrot &lt; 0.0f)</p>
<p class="src2">xrot += 360.0f;</p>
<p></p>
<p class="src1">if (yrot &gt; 360.0f)</p>
<p class="src2">yrot -= 360.0f;</p>
<p></p>
<p class="src1">if (yrot &lt; 0.0f)</p>
<p class="src2">yrot += 360.0f;</p>
<p></p>
<p class="src1">doLogo();<span class="kom">// Nakonec loga</span></p>
<p></p>
<p class="src1">return true;</p>
<p class="src0">}</p>

<p>Dal¹í funkce udìlá tohle v¹echno ve dvou fázích s podporou multitexturingu. Pou¾ijeme dvì texturovací jednotky. Více by bylo extrémnì obtí¾né vzhledem k blendingovým rovnicím. Lépe pou¾ít TNT. V¹imnìte si, ¾e se funkce li¹í od doMesh1TexelUnits() jen tím, ¾e posíláme dvì sady texturovacích souøadnich na ka¾dý vertex!</p>

<p class="src0">bool doMesh2TexelUnits(void)</p>
<p class="src0">{</p>
<p class="src1">GLfloat c[4] = {0.0f,0.0f,0.0f,1.0f};<span class="kom">// Aktuální vertex</span></p>
<p class="src1">GLfloat n[4] = {0.0f,0.0f,0.0f,1.0f};<span class="kom">// Normalizovaná normála povrchu</span></p>
<p class="src1">GLfloat s[4] = {0.0f,0.0f,0.0f,1.0f};<span class="kom">// Smìr texturovacích souøadnic s, normalizováno</span></p>
<p class="src1">GLfloat t[4] = {0.0f,0.0f,0.0f,1.0f};<span class="kom">// Smìr texturovacích souøadnic t, normalizováno</span></p>
<p></p>
<p class="src1">GLfloat l[4];<span class="kom">// Pozice svìtla k pøevedení na souøadnice objektu</span></p>
<p class="src1">GLfloat Minv[16];<span class="kom">// Pøevrácená modelview matice</span></p>
<p></p>
<p class="src1">int i;</p>
<p></p>
<p class="src1">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<span class="kom">// Sma¾e obrazovku a hloubkový buffer</span></p>
<p></p>
<p class="src1"><span class="kom">// Sestavení pøevrácené modelview matice, tohle nahradí funkce Push a Pop jednou funkcí glLoadIdentity()</span></p>
<p class="src1"><span class="kom">// Jednoduché sestavení tím, ¾e v¹echny transformace provedeme opaènì a v opaèném poøadí</span></p>
<p></p>
<p class="src1">glLoadIdentity();</p>
<p></p>
<p class="src1">glRotatef(-yrot,0.0f,1.0f,0.0f);</p>
<p class="src1">glRotatef(-xrot,1.0f,0.0f,0.0f);</p>
<p class="src1">glTranslatef(0.0f,0.0f,-z);</p>
<p></p>
<p class="src1">glGetFloatv(GL_MODELVIEW_MATRIX,Minv);</p>
<p></p>
<p class="src1">glLoadIdentity();</p>
<p></p>
<p class="src1">glTranslatef(0.0f,0.0f,z);</p>
<p></p>
<p class="src1">glRotatef(xrot,1.0f,0.0f,0.0f);</p>
<p class="src1">glRotatef(yrot,0.0f,1.0f,0.0f);</p>
<p></p>
<p class="src1"><span class="kom">// Transformace pozice svìtla na souøadnice objektu:</span></p>
<p class="src1">l[0] = LightPosition[0];</p>
<p class="src1">l[1] = LightPosition[1];</p>
<p class="src1">l[2] = LightPosition[2];</p>
<p class="src1">l[3] = 1.0f;<span class="kom">// Homogení souøadnice</span></p>
<p></p>
<p class="src1">VMatMult(Minv,l);</p>

<p>První fáze:</p>

<ul>
<li>Bez blendingu</li>
<li>Bez svìtel</li>
</ul>

<p>Nastavení texture combineru 0 na</p>

<ul>
<li>Pou¾ití bumpmapy</li>
<li>Pou¾ití neposunutých texturovacích souøadnic</li>
<li>Nastaveví operace s texturou na GL_REPLACE, která pouze vykreslí texturu</li>
</ul>

<p>Nastavení texture combineru 1 na</p>

<ul>
<li>Posunuté texturovací souøadnice</li>
<li>Nastavení operace s texturou na GL_ADD, co¾ je multitexturovacím ekvivalentem k ONE, ONE blendingu</li>
</ul>

<p>Tohle vyrenderuje krychli skládající se z ¹edých map.</p>

<p class="src1"><span class="kom">// TEXTUROVACÍ JEDNOTKA #0:</span></p>
<p class="src1">glActiveTextureARB(GL_TEXTURE0_ARB);</p>
<p class="src1">glEnable(GL_TEXTURE_2D);</p>
<p class="src1">glBindTexture(GL_TEXTURE_2D, bump[filter]);</p>
<p class="src1">glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);</p>
<p class="src1">glTexEnvf (GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_REPLACE);</p>
<p></p>
<p class="src1"><span class="kom">// TEXTUROVACÍ JEDNOTKA #1:</span></p>
<p class="src1">glActiveTextureARB(GL_TEXTURE1_ARB);</p>
<p class="src1">glEnable(GL_TEXTURE_2D);</p>
<p class="src1">glBindTexture(GL_TEXTURE_2D, invbump[filter]);</p>
<p class="src1">glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_EXT);</p>
<p class="src1">glTexEnvf (GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_ADD);</p>
<p></p>
<p class="src1"><span class="kom">// Obecné pøepínaèe</span></p>
<p class="src1">glDisable(GL_BLEND);</p>
<p class="src1">glDisable(GL_LIGHTING);</p>

<p>Teï pouze vyrenderujeme stìny jednu po druhé jako v doMesh1TexelUnits(). Pouze jedna novinka: pou¾ívá glMultiTexCoordfARB() místo glTexCoord2f(). V¹imnìte si, ¾e v prvním parametru je uvedeno, které texturovací jednotce pøíslu¹í souøadnice. Parametr musí být GL_TEXTUREi_ARB, kde i je v intervalu od 0 do 31.</p>

<p class="src1">glBegin(GL_QUADS);</p>
<p class="src2"><span class="kom">// Pøední stìna</span></p>
<p class="src2">n[0] = 0.0f;</p>
<p class="src2">n[1] = 0.0f;</p>
<p class="src2">n[2] = 1.0f;</p>
<p></p>
<p class="src2">s[0] = 1.0f;</p>
<p class="src2">s[1] = 0.0f;</p>
<p class="src2">s[2] = 0.0f;</p>
<p></p>
<p class="src2">t[0] = 0.0f;</p>
<p class="src2">t[1] = 1.0f;</p>
<p class="src2">t[2] = 0.0f;</p>
<p></p>
<p class="src2">for (i=0; i&lt;4; i++)</p>
<p class="src2">{</p>
<p class="src3">c[0] = data[5*i+2];</p>
<p class="src3">c[1] = data[5*i+3];</p>
<p class="src3">c[2] = data[5*i+4];</p>
<p></p>
<p class="src3">SetUpBumps(n,c,l,s,t);</p>
<p class="src3">glMultiTexCoord2fARB(GL_TEXTURE0_ARB, data[5*i], data[5*i+1]);</p>
<p class="src3">glMultiTexCoord2fARB(GL_TEXTURE1_ARB, data[5*i]+c[0], data[5*i+1]+c[1]);</p>
<p class="src3">glVertex3f(data[5*i+2], data[5*i+3], data[5*i+4]);</p>
<p class="src2">}</p>
<p></p>
<p class="src2"><span class="kom">// Zadní stìna</span></p>
<p class="src2">n[0] = 0.0f;</p>
<p class="src2">n[1] = 0.0f;</p>
<p class="src2">n[2] = -1.0f;</p>
<p></p>
<p class="src2">s[0] = -1.0f;</p>
<p class="src2">s[1] = 0.0f;</p>
<p class="src2">s[2] = 0.0f;</p>
<p></p>
<p class="src2">t[0] = 0.0f;</p>
<p class="src2">t[1] = 1.0f;</p>
<p class="src2">t[2] = 0.0f;</p>
<p></p>
<p class="src2">for (i=4; i&lt;8; i++)</p>
<p class="src2">{</p>
<p class="src3">c[0] = data[5*i+2];</p>
<p class="src3">c[1] = data[5*i+3];</p>
<p class="src3">c[2] = data[5*i+4];</p>
<p></p>
<p class="src3">SetUpBumps(n,c,l,s,t);</p>
<p class="src3">glMultiTexCoord2fARB(GL_TEXTURE0_ARB,data[5*i], data[5*i+1]);</p>
<p class="src3">glMultiTexCoord2fARB(GL_TEXTURE1_ARB,data[5*i]+c[0], data[5*i+1]+c[1]);</p>
<p class="src3">glVertex3f(data[5*i+2], data[5*i+3], data[5*i+4]);</p>
<p class="src2">}</p>
<p></p>
<p class="src2"><span class="kom">// Horní stìna</span></p>
<p class="src2">n[0] = 0.0f;</p>
<p class="src2">n[1] = 1.0f;</p>
<p class="src2">n[2] = 0.0f;</p>
<p></p>
<p class="src2">s[0] = 1.0f;</p>
<p class="src2">s[1] = 0.0f;</p>
<p class="src2">s[2] = 0.0f;</p>
<p></p>
<p class="src2">t[0] = 0.0f;</p>
<p class="src2">t[1] = 0.0f;</p>
<p class="src2">t[2] = -1.0f;</p>
<p></p>
<p class="src2">for (i=8; i&lt;12; i++)</p>
<p class="src2">{</p>
<p class="src3">c[0] = data[5*i+2];</p>
<p class="src3">c[1] = data[5*i+3];</p>
<p class="src3">c[2] = data[5*i+4];</p>
<p></p>
<p class="src3">SetUpBumps(n,c,l,s,t);</p>
<p class="src3">glMultiTexCoord2fARB(GL_TEXTURE0_ARB,data[5*i], data[5*i+1]);</p>
<p class="src3">glMultiTexCoord2fARB(GL_TEXTURE1_ARB,data[5*i]+c[0], data[5*i+1]+c[1]);</p>
<p class="src3">glVertex3f(data[5*i+2], data[5*i+3], data[5*i+4]);</p>
<p class="src2">}</p>
<p></p>
<p class="src2"><span class="kom">// Dolní stìna</span></p>
<p class="src2">n[0] = 0.0f;</p>
<p class="src2">n[1] = -1.0f;</p>
<p class="src2">n[2] = 0.0f;</p>
<p></p>
<p class="src2">s[0] = -1.0f;</p>
<p class="src2">s[1] = 0.0f;</p>
<p class="src2">s[2] = 0.0f;</p>
<p></p>
<p class="src2">t[0] = 0.0f;</p>
<p class="src2">t[1] = 0.0f;</p>
<p class="src2">t[2] = -1.0f;</p>
<p></p>
<p class="src2">for (i=12; i&lt;16; i++)</p>
<p class="src2">{</p>
<p class="src3">>c[0] = data[5*i+2];</p>
<p class="src3">c[1] = data[5*i+3];</p>
<p class="src3">c[2] = data[5*i+4];</p>
<p></p>
<p class="src3">SetUpBumps(n,c,l,s,t);</p>
<p class="src3">glMultiTexCoord2fARB(GL_TEXTURE0_ARB,data[5*i], data[5*i+1]);</p>
<p class="src3">glMultiTexCoord2fARB(GL_TEXTURE1_ARB,data[5*i]+c[0], data[5*i+1]+c[1]);</p>
<p class="src3">glVertex3f(data[5*i+2], data[5*i+3], data[5*i+4]);</p>
<p class="src2">}</p>
<p></p>
<p class="src2"><span class="kom">// Pravá stìna</span></p>
<p class="src2">n[0] = 1.0f;</p>
<p class="src2">n[1] = 0.0f;</p>
<p class="src2">n[2] = 0.0f;</p>
<p></p>
<p class="src2">s[0] = 0.0f;</p>
<p class="src2">s[1] = 0.0f;</p>
<p class="src2">s[2] = -1.0f;</p>
<p></p>
<p class="src2">t[0] = 0.0f;</p>
<p class="src2">t[1] = 1.0f;</p>
<p class="src2">t[2] = 0.0f;</p>
<p></p>
<p class="src2">for (i=16; i&lt;20; i++)</p>
<p class="src2">{</p>
<p class="src3">c[0] = data[5*i+2];</p>
<p class="src3">c[1] = data[5*i+3];</p>
<p class="src3">c[2] = data[5*i+4];</p>
<p></p>
<p class="src3">SetUpBumps(n,c,l,s,t);</p>
<p class="src3">glMultiTexCoord2fARB(GL_TEXTURE0_ARB,data[5*i], data[5*i+1]);</p>
<p class="src3">glMultiTexCoord2fARB(GL_TEXTURE1_ARB,data[5*i]+c[0], data[5*i+1]+c[1]);</p>
<p class="src3">glVertex3f(data[5*i+2], data[5*i+3], data[5*i+4]);</p>
<p class="src2">}</p>
<p></p>
<p class="src2"><span class="kom">// Levá stìna</span></p>
<p class="src2">n[0] = -1.0f;</p>
<p class="src2">n[1] = 0.0f;</p>
<p class="src2">n[2] = 0.0f;</p>
<p></p>
<p class="src2">s[0] = 0.0f;</p>
<p class="src2">s[1] = 0.0f;</p>
<p class="src2">s[2] = 1.0f;</p>
<p></p>
<p class="src2">t[0] = 0.0f;</p>
<p class="src2">t[1] = 1.0f;</p>
<p class="src2">t[2] = 0.0f;</p>
<p></p>
<p class="src2">for (i=20; i&lt;24; i++)</p>
<p class="src2">{</p>
<p class="src3">c[0] = data[5*i+2];</p>
<p class="src3">c[1] = data[5*i+3];</p>
<p class="src3">c[2] = data[5*i+4];</p>
<p></p>
<p class="src3">SetUpBumps(n,c,l,s,t);</p>
<p class="src3">glMultiTexCoord2fARB(GL_TEXTURE0_ARB,data[5*i], data[5*i+1]);</p>
<p class="src3">glMultiTexCoord2fARB(GL_TEXTURE1_ARB,data[5*i]+c[0], data[5*i+1]+c[1]);</p>
<p class="src3">glVertex3f(data[5*i+2], data[5*i+3], data[5*i+4]);</p>
<p class="src2">}</p>
<p class="src1">glEnd();</p>

<p>Druhá fáze:</p>

<ul>
<li>Pou¾ití základní textury</li>
<li>Povolení osvìtlení</li>
<li>Neposunuté texturovací souøadnice - vyresetovat GL_TEXTURE matice</li>
<li>Nastavení texture environment na GL_MODULATE</li>
</ul>

<p>Tohle vyrenderuje celou bumpmapovanou krychli.</p>

<p class="src1">glActiveTextureARB(GL_TEXTURE1_ARB);</p>
<p class="src1">glDisable(GL_TEXTURE_2D);</p>
<p class="src1">glActiveTextureARB(GL_TEXTURE0_ARB);</p>
<p></p>
<p class="src1">if (!emboss)</p>
<p class="src1">{</p>
<p class="src2">glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);</p>
<p></p>
<p class="src2">glBindTexture(GL_TEXTURE_2D,texture[filter]);</p>
<p class="src2">glBlendFunc(GL_DST_COLOR,GL_SRC_COLOR);</p>
<p></p>
<p class="src2">glEnable(GL_BLEND);</p>
<p class="src2">glEnable(GL_LIGHTING);</p>
<p></p>
<p class="src2">doCube();</p>
<p class="src1">}</p>

<p>Poslední fáze:</p>

<ul>
<li>Pootoèení krychle</li>
<li>Nakreslení log</li>
</ul>

<p class="src1">xrot += xspeed;</p>
<p class="src1">yrot += yspeed;</p>
<p></p>
<p class="src1">if (xrot&gt;360.0f)</p>
<p class="src2">xrot -= 360.0f;</p>
<p></p>
<p class="src1">if (xrot&lt;0.0f)</p>
<p class="src2">xrot += 360.0f;</p>
<p></p>
<p class="src1">if (yrot&gt;360.0f)</p>
<p class="src2">yrot -= 360.0f;</p>
<p></p>
<p class="src1">if (yrot&lt;0.0f)</p>
<p class="src2">yrot += 360.0f;</p>
<p></p>
<p class="src1">doLogo();<span class="kom">// Nakonec loga</span></p>
<p></p>
<p class="src1">return true;</p>
<p class="src0">}</p>

<p>Koneènì funkce na renderování bez bumpmappingu - abychom mohli vidìt ten rozdíl!</p>

<p class="src0">bool doMeshNoBumps(void)</p>
<p class="src0">{</p>
<p class="src1">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<span class="kom">// Sma¾e obrazovku a hloubkový buffer</span></p>
<p class="src1">glLoadIdentity();<span class="kom">// Reset matice</span></p>
<p class="src1">glTranslatef(0.0f,0.0f,z);</p>
<p></p>
<p class="src1">glRotatef(xrot,1.0f,0.0f,0.0f);</p>
<p class="src1">glRotatef(yrot,0.0f,1.0f,0.0f);</p>
<p></p>
<p class="src1">if (useMultitexture)</p>
<p class="src1">{</p>
<p class="src2">glActiveTextureARB(GL_TEXTURE1_ARB);</p>
<p class="src2">glDisable(GL_TEXTURE_2D);</p>
<p class="src2">glActiveTextureARB(GL_TEXTURE0_ARB);</p>
<p class="src1">}</p>
<p></p>
<p class="src1">glDisable(GL_BLEND);</p>
<p class="src1">glBindTexture(GL_TEXTURE_2D,texture[filter]);</p>
<p class="src1">glBlendFunc(GL_DST_COLOR,GL_SRC_COLOR);</p>
<p class="src1">glEnable(GL_LIGHTING);</p>
<p></p>
<p class="src1">doCube();</p>
<p></p>
<p class="src1">xrot += xspeed;</p>
<p class="src1">yrot += yspeed;</p>
<p></p>
<p class="src1">if (xrot&gt;360.0f)</p>
<p class="src2">xrot -= 360.0f;</p>
<p></p>
<p class="src1">if (xrot&lt;0.0f)</p>
<p class="src2">xrot += 360.0f;</p>
<p></p>
<p class="src1">if (yrot&gt;360.0f)</p>
<p class="src2">yrot -= 360.0f;</p>
<p></p>
<p class="src1">if (yrot&lt;0.0f)</p>
<p class="src2">yrot += 360.0f;</p>
<p></p>
<p class="src1">doLogo();<span class="kom">// Nakonec loga</span></p>
<p></p>
<p class="src1">return true;</p>
<p class="src0">}</p>

<p>V¹e co musí drawGLScene() udìlat je rozhodnout jakou doMesh funkci zavolat.</p>

<p class="src0">bool DrawGLScene(GLvoid)<span class="kom">// V¹echno kreslení</span></p>
<p class="src0">{</p>
<p class="src1">if (bumps)</p>
<p class="src1">{</p>
<p class="src2">if (useMultitexture &amp;&amp; maxTexelUnits &gt; 1)</p>
<p class="src3">return doMesh2TexelUnits();</p>
<p class="src2">else</p>
<p class="src3">return doMesh1TexelUnits();</p>
<p class="src1">}</p>
<p class="src1">else</p>
<p class="src2">return doMeshNoBumps();</p>
<p class="src0">}</p>

<p>Hlavní funkce Windows, pøidány nìkteré klávesy:</p>

<ul>
<li>E: pøepínání Emboss/bumpmapový mód</li>
<li>M: vypínání a zapínání multitexturingu</li>
<li>B: vypínání a zapínání bumpmappingu, pouze v emboss módu</li>
<li>F: pøepínání filtrù, GL_NEAREST není vhodný pro bumpmapping</li>
<li>KURSOROVÉ KLÁVESY: otáèení krychle</li>
</ul>

<p class="src0">int WINAPI WinMain(HINSTANCE hInstance,  HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)</p>
<p class="src0">{</p>
<p class="src1"><span class="kom">// Zaèátek zùstává nezmìnìn</span></p>
<p class="src4">if (keys['E'])</p>
<p class="src4">{</p>
<p class="src5">keys['E']=false;</p>
<p class="src5">emboss=!emboss;</p>
<p class="src4">}</p>
<p></p>
<p class="src4">if (keys['M'])</p>
<p class="src4">{</p>
<p class="src5">keys['M']=false;</p>
<p class="src5">useMultitexture=((!useMultitexture) &amp;&amp; multitextureSupported);</p>
<p class="src4">}</p>
<p></p>
<p class="src4">if (keys['B'])</p>
<p class="src4">{</p>
<p class="src5">keys['B']=false;</p>
<p class="src5">bumps=!bumps;</p>
<p class="src4">}</p>
<p></p>
<p class="src4">if (keys['F'])</p>
<p class="src4">{</p>
<p class="src5">keys['F']=false;</p>
<p class="src5">filter++;</p>
<p class="src5">filter%=3;</p>
<p class="src4">}</p>
<p></p>
<p class="src4">if (keys[VK_PRIOR])</p>
<p class="src4">{</p>
<p class="src5">z-=0.02f;</p>
<p class="src4">}</p>
<p></p>
<p class="src4">if (keys[VK_NEXT])</p>
<p class="src4">{</p>
<p class="src5">z+=0.02f;</p>
<p class="src4">}</p>
<p></p>
<p class="src4">if (keys[VK_UP])</p>
<p class="src4">{</p>
<p class="src5">xspeed-=0.01f;</p>
<p class="src4">}</p>
<p></p>
<p class="src4">if (keys[VK_DOWN])</p>
<p class="src4">{</p>
<p class="src5">xspeed+=0.01f;</p>
<p class="src4">}</p>
<p></p>
<p class="src4">if (keys[VK_RIGHT])</p>
<p class="src4">{</p>
<p class="src5">yspeed+=0.01f;</p>
<p class="src4">}</p>
<p></p>
<p class="src4">if (keys[VK_LEFT])</p>
<p class="src4">{</p>
<p class="src5">yspeed-=0.01f;</p>
<p class="src4">}</p>
<p class="src1"><span class="kom">// Konec také nezmìnìn</span></p>
<p class="src0">}</p>

<p>Teï kdy¾ jsme zvládli tento tutoriál, pár slov o generování textur a bumpmapových objektù. Pøedtím, ne¾ zaènete programovat ambiciózní hry a budete se divit, proè bumpmapping není tak rychlý a nevypadá tak dobøe, pøeètìte si toto:</p>

<ul>
<li>Nemìli byste pou¾ívat textury 256x256 jako v této lekci. To v¹e hodnì zpomalí. Pou¾ívejte je pouze pøi demonstracích.</li>
<li>Bumpmapovaná krychle není bì¾ná. Toèící se je¹tì ménì. Dùvodem je úhel pohledu: Èím ostøej¹í úhel, tím více optických chyb se kvùli filtrování objeví. Skoro v¹echny multifázové algoritmy tímto trpí. Abyste se vyhli pou¾ívání velmi detailních textur, zredukujte úhly viditelnosti na minimum a pøedfiltrujte textury tak, aby dokonale sedly na tento rozptyl úhlù.</li>
<li>Nejdøíve byste mìli mít barevnou texturu. Z ní se dá velmi snadno pomocí prùmìrnéno grafického programu udìlat textura ve stupních ¹edi.</li>
<li>Bumpmapa by mìla být &quot;ostøej¹í&quot; a mít vìt¹í kontrast ne¾ barevná textura. Toho vìt¹inou docílíte pou¾itím nìjakého &quot;sparpening filtru&quot;. Z poèátku to mo¾ná bude vypadat divnì, ale k dosa¾ení kvalitního efektu je to nutné.</li>
<li>Bumpmapa by se barvama mìla blí¾it 50% ¹edé (RGB 127,127,127). Tato barva znamená hladký povrch, svìtlej¹í místa reprezentují rýhy. Tohoto mù¾ete dosáhnout u¾itím histogramu v nìkterých grafických programech.</li>
<li>Bumpmapa mù¾e být ètyøikrát men¹í ne¾ barevná textura bez vá¾ného sní¾ení kvality obrazu.</li>
</ul>

<p>Podìkování:</p>

<ul>
<li>Michael I. Gold za dokumentaci o bumpmappingu</li>
<li>Diego Tártara za ukázkový kód</li>
<li>nVidia za ukázky na www</li>
<li>NeHe za to, ¾e mì nauèil mnoho o OpenGL</li>
</ul>

<p class="autor">napsal: Jens Schneider <span class="transform_email">&lt;schneide (zavináè) pool.informatik.rwth-aachen.de&gt;</span><br />
pøelo¾il: Václav Slováèek - Wessan <span class="transform_email">&lt;horizont (zavináè) host.sk&gt;</span></p>

<ul class="zdroj_kody">
<li><a href="http://nehe.gamedev.net/data/lessons/vc/lesson22.zip">Visual C++</a> kód této lekce.</li>
<li><a href="http://nehe.gamedev.net/data/lessons/bcb6/lesson22_bcb6.zip">Borland C++ Builder 6</a> kód této lekce. ( <a href="mailto:christian@tugzip.com">Christian Kindahl</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/cwarrior/lesson22.zip">Code Warrior 5.3</a> kód této lekce. ( <a href="mailto:DelusionalBeing@hotmail.com">Scott Lupton</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/delphi/lesson22.zip">Delphi</a> kód této lekce. ( <a href="mailto:marca@stack.nl">Marc Aarts</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/devc/lesson22.zip">Dev C++</a> kód této lekce. ( <a href="mailto:danprogram@hotmail.com">Dan</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/java/lesson22.zip">Java</a> kód této lekce. ( <a href="mailto:jeff@consunet.com.au">Jeff Kirby</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/jogl/lesson22.jar">JoGL</a> kód této lekce. ( <a href="mailto:abezrati@hotmail.com">Abdul Bezrati</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/linux/lesson22.tar.gz">Linux</a> kód této lekce. ( <a href="mailto:lucriz@inwind.it">Luca Rizzuti</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/linuxsdl/lesson22.tar.gz">Linux/SDL</a> kód této lekce. ( <a href="mailto:leggett@eecs.tulane.edu">Ti Leggett</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/mac/lesson22.sit">Mac OS</a> kód této lekce. ( <a href="mailto:classic@sover.net">Morgan Aldridge</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/macosxcocoa/lesson22.zip">Mac OS X/Cocoa</a> kód této lekce. ( <a href="mailto:blb@pobox.com">Bryan Blackburn</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/openil/lesson22.zip">Visual C++ / OpenIL</a> kód této lekce. ( <a href="mailto:doomwiz@ticnet.com">Denton Woods</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/vs_net/lesson22.zip">Visual Studio .NET</a> kód této lekce. ( <a href="mailto:ultimatezeus@hotmail.com">Grant James</a> )</li>
</ul>

<div class="okolo_img"><img src="images/nehe_tut/tut_22_big.jpg" class="nehe_velky" alt="Lekce 22" /></div>
<p class="okolni_lekce"><a href="tut_21.php">&lt;&lt;&lt; Lekce 21</a> | <a href="tut_23.php">Lekce 23 &gt;&gt;&gt;</a></p>


<div class="netisk">
<h3 class="d_nadpis">Diskuze ke èlánku</h3>

<form action="d_view.php" method="post" class="d_o_obsah">

<div class="d_o_zprava">
<div class="d_o_jmeno">Mantharis</div>
<div class="d_o_datumcas">05.07.2005 - 20:12:19</div>
<div>
<input type="checkbox" name="id_0" id="id_0" value="1" />
<span class="d_o_nadpis" style="margin-left: 0px;"><a href="d_view.php?f=tut_22.php&j=0">problém pøi pøevodu vertexù do prostor scény</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">jaja</div>
<div class="d_o_datumcas">17.08.2005 - 18:15:51</div>
<div>
<input type="checkbox" name="id_1" id="id_1" value="1" />
<span class="d_o_nadpis" style="margin-left: 0px;"><a href="d_view.php?f=tut_22.php&j=1">Chybi hlavickovy soubor</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">Woq</div>
<div class="d_o_datumcas">28.09.2005 - 22:14:37</div>
<div>
<input type="checkbox" name="id_2" id="id_2" value="1" />
<span class="d_o_nadpis" style="margin-left: 20px;"><a href="d_view.php?f=tut_22.php&j=2">Re: Chybi hlavickovy soubor</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">DarkEcho</div>
<div class="d_o_datumcas">19.01.2006 - 17:09:39</div>
<div>
<input type="checkbox" name="id_3" id="id_3" value="1" />
<span class="d_o_nadpis" style="margin-left: 0px;"><a href="d_view.php?f=tut_22.php&j=3">'Integer' and 'Pointer'</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">Dusan</div>
<div class="d_o_datumcas">25.04.2007 - 19:32:26</div>
<div>
<input type="checkbox" name="id_4" id="id_4" value="1" />
<span class="d_o_nadpis" style="margin-left: 0px;"><a href="d_view.php?f=tut_22.php&j=4">Chybny preklad?</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">woq</div>
<div class="d_o_datumcas">25.04.2007 - 19:36:17</div>
<div>
<input type="checkbox" name="id_5" id="id_5" value="1" />
<span class="d_o_nadpis" style="margin-left: 20px;"><a href="d_view.php?f=tut_22.php&j=5">Re: Chybny preklad?</a></span>
</div>
</div>

<div class="okolo_img" style="margin-top: 20px;">
<input type="submit" name="zobrazit_vybrane" id="zobrazit_vybrane" value="Zobrazit vybrané" class="tlacitko" />
<input type="submit" name="zobrazit_vse" id="zobrazit_vse" value="Zobrazit v¹e" class="tlacitko" />
<input type="submit" name="vlozit_novy" id="vlozit_novy" value="Vlo¾it nový" class="tlacitko" />
<input type="hidden" name="f" id="f" value="tut_22.php" />
</div>
</form>
</div>
<!-- Informace o webu -->
<center><div id="informace">
<img src="images/my/woq.gif" width="60" height="60" align="left" alt="Woq logo" />
<div style="margin-left: 70px">
<div><strong>CZ NeHe OpenGL, v¹e o programování 3D grafiky</strong></div>
<div>Copyright &copy; 2002-2007 Michal Turek <span class="transform_email">&lt;WOQ (zavináè) seznam.cz&gt;</span></div>
<div style="margin-top: 5px">Komerèní publikování v ti¹tìné, elektronické nebo jiné podobì je bez výslovného souhlasu zakázáno. Redistribuce pro výukové úèely nebo osobní pou¾ití je v¹ak povolena.</div>
</div>
</div></center>
<!-- Informace o webu (konec) -->

</div>
<!-- Vlastní obsah stránky (konec) -->

<script src="http://c1.navrcholu.cz/code?site=56575;t=b14"
type="text/javascript"></script><noscript><div><a
href="http://navrcholu.cz/"><img
src="http://c1.navrcholu.cz/hit?site=56575;t=b14;ref=;jss=0"
width="14" height="14" alt="NAVRCHOLU.cz"
style="border:none" /></a></div></noscript>

</body>
</html>
