<?xml version="1.0" encoding="ISO-8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="CS">
<head>

<meta http-equiv="content-type" content="text/html; charset=ISO-8859-2" />
<meta http-equiv="content-language" content="cs" />
<meta http-equiv="content-script-type" content="text/javascript" />
<meta http-equiv="content-style-type" content="text/css" />

<meta name="robots" content="all, follow" />
<meta name="resource-type" content="document" />

<meta name="description" content="NeHe OpenGL Tutoriály v èe¹tinì, programování 3D grafiky, èlánky, programy se zdrojovými kódy..." />
<meta name="keywords" content="opengl, nehe, tutoriály, woq, programování, 3D" />
<meta name="author" content="all: Michal Turek - Woq; woq (zavináè) seznam.cz" />
<meta name="copyright" content="Copyright (c) 2002, 2003, 2004 Michal Turek - Woq" />

<title>CZ NeHe OpenGL - Lekce 21 - Pøímky, antialiasing, èasování, pravoúhlá projekce, základní zvuky a jednoduchá herní logika</title>

<link rel="shortcut icon" href="skin/default/web.ico" type="image/x-icon" />
<link href="skin/default.css" rel="stylesheet" type="text/css" media="all" />
<link href="skin/print.css" rel="stylesheet" type="text/css" media="print" />

</head>

<body>

<!-- Levý sloupec -->
<div class="levy">
<div id="main_menu">
<a href="http://nehe.ceske-hry.cz/"><img src="skin/default/web_logo.gif" width="135" height="135" style="margin-left: 5px;" alt="CZ NeHe OpenGL" /></a>

<div class="main_menu_bez_loga">

<ul class="text_main_menu">
<li><a href="my.php" title="Pøekladatelé NeHe Tutoriálù a autoøi èlánkù">My</a></li>
<li><a href="novinky.php" title="Co je nového">Novinky</a></li>
<li><a href="navigacni_mapa.php" title="Pøehledná navigace na jednotlivé stránky, které dohromady tvoøí tento web">Navigaèní mapa</a></li>
<li><a href="kontakt.php" title="Kontakt na správce tohoto webu">Kontakt</a></li>
<li><a href="http://forum.programovani.com/" title="Diskusní fórum">Fórum</a></li>
</ul>

<ul class="text_main_menu">
<li><a href="clanky.php" title="Obsah èlánkù">Èlánky</a></li>
<li><a href="tut_obsah.php" title="Obsah NeHe OpenGL Tutoriálù">NeHe Tutoriály</a></li>
<li><a href="33D_index.php" title="Obsah Free3D (33D) Basecode">33D Basecode</a></li>
<li><a href="programy.php" title="Programy od èeských autorù">Èeské programy</a></li>
<li><a href="cl_gl_zacinam.php" title="Kde zaèít pøi uèení OpenGL">Pomoc, zaèínám</a></li>
<li><a href="odkazy.php" title="Jiné zdroje informací">Odkazy</a></li>
<li><a href="cl_gl_faq.php" title="FAQ: Èasto kladené dotazy">FAQ</a></li>
</ul>

<ul class="text_main_menu">
<li><a href="spoluprace.php" title="Nechcete se podílet na tvorbì tìchto webových stránek?">Spolupráce...?</a></li>
<li><a href="download.php" title="Stahujte">Download</a></li>
<li><a href="skiny.php" title="Nastavte si jiný layout a design stránek">Skiny</a></li>
<li><a href="javascript:window.print();" title="Vytiskne tuto stránku">Tisk</a></li>
</ul>

<ul class="text_main_menu">
<li>
<form action="p_fulltext.php" method="post" onsubmit="if(!this.najit.value || this.najit.value=='výraz ...') { alert('Byl zadán prázdný øetìzec!'); this.najit.focus(); return false; }">
<input type="text" name="najit" size="12" value="výraz ..." onclick="this.value=''" /><br />
<input type="submit" value="Najít" />
</form>
</li>
</ul>

<ul class="text_main_menu">
<li>Online ètenáøù: 2</li>
</ul>

</div>

</div>
</div>
<!-- Levý sloupec (konec) -->

<!-- Pravý sloupec -->
<div class="pravy">
<div id="tut_menu">

<ul class="text_tut_menu">
<li class="li_tut"><a href="tut_00.php" title="Lekce 0 - Pøedmluva k NeHe Tutoriálùm">00</a></li>
<li class="li_tut"><a href="tut_01.php" title="Lekce 1 - Vytvoøení OpenGL okna ve Windows">01</a></li>
<li class="li_tut"><a href="tut_02.php" title="Lekce 2 - Vytváøení trojúhelníkù a ètyøúhelníkù">02</a></li>
<li class="li_tut"><a href="tut_03.php" title="Lekce 3 - Barvy">03</a></li>
<li class="li_tut"><a href="tut_04.php" title="Lekce 4 - Rotace">04</a></li>
<li class="li_tut"><a href="tut_05.php" title="Lekce 5 - Pevné objekty">05</a></li>
<li class="li_tut"><a href="tut_06.php" title="Lekce 6 - Textury">06</a></li>
<li class="li_tut"><a href="tut_07.php" title="Lekce 7 - Texturové filtry, osvìtlení, ovládání pomocí klávesnice">07</a></li>
<li class="li_tut"><a href="tut_08.php" title="Lekce 8 - Blending">08</a></li>
<li class="li_tut"><a href="tut_09.php" title="Lekce 9 - Pohyb bitmap ve 3D prostoru">09</a></li>
<li class="li_tut"><a href="tut_10.php" title="Lekce 10 - Vytvoøení 3D svìta a pohyb v nìm">10</a></li>
<li class="li_tut"><a href="tut_11.php" title="Lekce 11 - Efekt vlnící se vlajky">11</a></li>
<li class="li_tut"><a href="tut_12.php" title="Lekce 12 - Display list">12</a></li>
<li class="li_tut"><a href="tut_13.php" title="Lekce 13 - Bitmapové fonty">13</a></li>
<li class="li_tut"><a href="tut_14.php" title="Lekce 14 - Outline fonty">14</a></li>
<li class="li_tut"><a href="tut_15.php" title="Lekce 15 - Mapování textur na fonty">15</a></li>
<li class="li_tut"><a href="tut_16.php" title="Lekce 16 - Mlha">16</a></li>
<li class="li_tut"><a href="tut_17.php" title="Lekce 17 - 2D fonty z textur">17</a></li>
<li class="li_tut"><a href="tut_18.php" title="Lekce 18 - Kvadriky">18</a></li>
<li class="li_tut"><a href="tut_19.php" title="Lekce 19 - Èásticové systémy">19</a></li>
<li class="li_tut"><a href="tut_20.php" title="Lekce 20 - Maskování">20</a></li>
<li class="li_tut"><a href="tut_21.php" title="Lekce 21 - Pøímky, antialiasing, èasování, pravoúhlá projekce, základní zvuky a jednoduchá herní logika">21</a></li>
<li class="li_tut"><a href="tut_22.php" title="Lekce 22 - Bump Mapping &amp; Multi Texturing">22</a></li>
<li class="li_tut"><a href="tut_23.php" title="Lekce 23 - Mapování textur na kulové kvadriky">23</a></li>
<li class="li_tut"><a href="tut_24.php" title="Lekce 24 - Výpis OpenGL roz¹íøení, oøezávací testy a textury z TGA obrázkù">24</a></li>
<li class="li_tut"><a href="tut_25.php" title="Lekce 25 - Morfování objektù a jejich nahrávání z textového souboru">25</a></li>
<li class="li_tut"><a href="tut_26.php" title="Lekce 26 - Odrazy a jejich oøezávání za pou¾ití stencil bufferu">26</a></li>
<li class="li_tut"><a href="tut_27.php" title="Lekce 27 - Stíny">27</a></li>
<li class="li_tut"><a href="tut_28.php" title="Lekce 28 - Bezierovy køivky a povrchy, fullscreen fix">28</a></li>
<li class="li_tut"><a href="tut_29.php" title="Lekce 29 - Blitter, nahrávání .RAW textur">29</a></li>
<li class="li_tut"><a href="tut_30.php" title="Lekce 30 - Detekce kolizí">30</a></li>
<li class="li_tut"><a href="tut_31.php" title="Lekce 31 - Nahrávání a renderování modelù">31</a></li>
<li class="li_tut"><a href="tut_32.php" title="Lekce 32 - Picking, alfa blending, alfa testing, sorting">32</a></li>
<li class="li_tut"><a href="tut_33.php" title="Lekce 33 - Nahrávání komprimovaných i nekomprimovaných obrázkù TGA">33</a></li>
<li class="li_tut"><a href="tut_34.php" title="Lekce 34 - Generování terénù a krajin za pou¾ití vý¹kového mapování textur">34</a></li>
<li class="li_tut"><a href="tut_35.php" title="Lekce 35 - Pøehrávání videa ve formátu AVI">35</a></li>
<li class="li_tut"><a href="tut_36.php" title="Lekce 36 - Radial Blur, renderování do textury">36</a></li>
<li class="li_tut"><a href="tut_37.php" title="Lekce 37 - Cel-Shading">37</a></li>
<li class="li_tut"><a href="tut_38.php" title="Lekce 38 - Nahrávání textur z resource souboru &amp; texturování trojúhelníkù">38</a></li>
<li class="li_tut"><a href="tut_39.php" title="Lekce 39 - Úvod do fyzikálních simulací">39</a></li>
<li class="li_tut"><a href="tut_40.php" title="Lekce 40 - Fyzikální simulace lana">40</a></li>
<li class="li_tut"><a href="tut_41.php" title="Lekce 41 - Volumetrická mlha a nahrávání obrázkù pomocí IPicture">41</a></li>
<li class="li_tut"><a href="tut_42.php" title="Lekce 42 - Více viewportù">42</a></li>
<li class="li_tut"><a href="tut_43.php" title="Lekce 43 - FreeType Fonty v OpenGL">43</a></li>
<li class="li_tut"><a href="tut_44.php" title="Lekce 44 - Èoèkové efekty">44</a></li>
<li class="li_tut"><a href="tut_45.php" title="Lekce 45 - Vertex Buffer Object (VBO)">45</a></li>
<li class="li_tut"><a href="tut_46.php" title="Lekce 46 - Fullscreenový antialiasing">46</a></li>
<li class="li_tut"><a href="tut_47.php" title="Lekce 47 - CG vertex shader">47</a></li>
<li class="li_tut"><a href="tut_48.php" title="Lekce 48 - ArcBall rotace">48</a></li>
</ul>

</div>
</div>
<!-- Pravý sloupec (konec) -->

<!-- Vlastní obsah stránky -->
<div class="stred">

<!--[if IE ]>
<div style="text-align: center;">
<a href="http://firefox.czilla.cz/"><img alt="Mozilla Firefox: Objevte znovu web" title="Mozilla Firefox: Objevte znovu web" style="border:none; width:468px;height:60px" src="http://firefox.czilla.cz/img/p/cz-ff-468x60-w-objevte.png" /></a>
</div>
<![endif]-->

<img src="images/nehe_tut/tut_21.jpg" class="nehe_maly" alt="Lekce 21" />

<h1>Lekce 21 - Pøímky, antialiasing, èasování, pravoúhlá projekce, základní zvuky a jednoduchá herní logika</h1>

<p class="nadpis_clanku">První opravdu rozsáhlý tutoriál - jak u¾ plyne z gigantického názvu. Doufejme, ¾e taková spousta informací a technik doká¾e udìlat ¹»astným opravdu ka¾dého. Strávil jsem dva dny kódováním a kolem dvou týdnù psaním tohoto HTML souboru. Pokud jste nìkdy hráli hru Admiar, lekce vás vrátí do vzpomínek. Úkol hry sestává z vyplnìní jednotlivých políèek møí¾ky. Samozøejmì se musíte vyhýbat v¹em nepøátelùm.</p>

<p>Námìt této lekce je vcelku slo¾itý. Vím, ¾e spousta z vás je unavena studiem základù. Ka¾dý by zemøel pro zvlá¹tnosti 3D objektù, multitexturingu a podobnì. Tìmto lidem se omlouvám, proto¾e chci zachovat postupné nabalování znalostí. Po velkém skoku vpøed není u krùèku zpìt snadné udr¾et zájem ètenáøù. Já osobnì preferuji konstantní tempo. Mo¾ná jsem ztratil nìkolik z vás, ale doufám, ¾e ne pøíli¹ mnoho. Do dne¹ka se ve v¹ech mých tutoriálech objevovaly polygony, obdélníky a trojúhelníky. Pravdìpodobnì jste si v¹imli neúmyslné diskriminace :-) èar, pøímek, linek a podobných jednorozmìrných útvarù. O nìkolik hodin pozdìji zaèal vznikat Line Tutoriál. Vypadal v klidu, ale totálnì nudný! Linky jsou skvìlé, ale v porovnání s nìkterými efekty nic moc. Shrnuto: rozhodl jsem se napsat multi-tutoriál. Na konci lekce bychom mìli mít vytvoøenu jednoduchou hru typu 'Admiar'. Misí bude vyplnit políèka møí¾ky. Hráèe nesmí chytit nepøátelé - jak jinak. Implementujeme levely, etapy, ¾ivoty, zvuky a kódy - k prùchodu skrz levely, kdy¾ se vìci stanou pøíli¹ obtí¾nými. Aèkoli hru spustíte i na Pentiu 166 s Voodoo 2, rychlej¹í procesor nebude na ¹kodu.</p>

<p>Roz¹íøíme standardní kód z lekce jedna. Pøidáme potøebné hlavièkové soubory - stdio.h pro souborové operace a stdarg.h kvùli výstupu promìnných (level, obtí¾nost ap.).</p>

<p class="src0">#include &lt;windows.h&gt;<span class="kom">// Hlavièkový soubor pro Windows</span></p>
<p class="src0">#include &lt;stdio.h&gt;<span class="kom">// Hlavièkový soubor pro standardní vstup/výstup</span></p>
<p class="src0">#include &lt;stdarg.h&gt;<span class="kom">// Hlavièkový soubor pro funkce s promìnným poètem parametrù</span></p>
<p class="src0">#include &lt;gl\gl.h&gt;<span class="kom">// Hlavièkový soubor pro OpenGL32 knihovnu</span></p>
<p class="src0">#include &lt;gl\glu.h&gt;<span class="kom">// Hlavièkový soubor pro Glu32 knihovnu</span></p>
<p class="src0">#include &lt;gl\glaux.h&gt;<span class="kom">// Hlavièkový soubor pro Glaux knihovnu</span></p>
<p></p>
<p class="src0">HDC hDC = NULL;<span class="kom">// Privátní GDI Device Context</span></p>
<p class="src0">HGLRC hRC = NULL;<span class="kom">// Trvalý Rendering Context</span></p>
<p class="src0">HWND hWnd = NULL;<span class="kom">// Obsahuje Handle na¹eho okna</span></p>
<p class="src0">HINSTANCE hInstance;<span class="kom">// Obsahuje instanci aplikace</span></p>
<p></p>
<p class="src0">bool keys[256];<span class="kom">// Pole pro ukládání vstupu z klávesnice</span></p>
<p class="src0">bool active = TRUE;<span class="kom">// Ponese informaci o tom, zda je okno aktivní</span></p>
<p class="src0">bool fullscreen = TRUE;<span class="kom">// Ponese informaci o tom, zda je program ve fullscreenu</span></p>

<p>Deklarujeme promìnné. Pole vline ukládá záznamy o 121 vertikálních linkách, které tvoøí møí¾ku. 11 pøímek zleva doprava a 11 èas ze shora dolù. Hline ukládá 121 horizontálních pøímek. Ap pou¾íváme ke zji¹tìní stisku klávesy A. Filled je nastaveno na FALSE, jestli¾e møí¾ka není kompletnì vyplnìní a TRUE pokud je. Gameover ukonèuje hru. Pokud se anti rovná TRUE je zapnut antialiasing objektù.</p>

<p class="src0">bool vline[11][10];<span class="kom">// Ukládá záznamy o vertikálních linkách</span></p>
<p class="src0">bool hline[10][11];<span class="kom">// Ukládá záznamy o horizontálních linkách</span></p>
<p class="src0">bool ap;<span class="kom">// Stisknuto 'A'?</span></p>
<p class="src0">bool filled;<span class="kom">// Bylo ukonèeno vyplòování møí¾ky?</span></p>
<p class="src0">bool gameover;<span class="kom">// Konec hry?</span></p>
<p class="src0">bool anti = TRUE;<span class="kom">// Antialiasing?</span></p>

<p>Pøicházejí na øadu celoèíselné promìnné. Loop1 a loop2 u¾íváme k oznaèení bodù v herní møí¾ce, zji¹tìní zda do nás nepøítel nevrazil  a k vygenerování randomové pozice. Zastavení pohybu nepøátel je implementováno èítaèem delay. Po dosa¾ení urèité hodnoty se zaènou znovu hýbat a delay se zpátky vynuluje.</p>

<p>Promìnná adjust je speciální. I kdy¾ program obsahuje timer, tento timer pouze zji¹»uje, zda je poèítaè (prùbìh programu) pøíli¹ rychlý a v takovém pøípadì ho zpomalíme. Na grafické kartì GeForce hra bì¾í hodnì rychle. Po testu s PIII/450 s Voodoo 3500 TV si nelze nev¹imnout extrémní lenosti. Problém spoèívá v kódu pro èasování, který hru pouze zpomaluje. Zrychlení jím nelze provést. Vytvoøil jsem promìnnou adjust, která mù¾e nabývat nuly a¾ pìti. Èím vy¹¹í hodnota, tím rychleji se objekty pohybují - podpora star¹ích systémù. Nicménì nezále¾í, jak rychlá je hra, absolutní rychlost provádìní programu se nikdy nezvý¹í. Nastavením adjust na trojku vytvoøíme kompromis pro pomalé i rychlé systémy. Více o èasování dále.</p>

<p>Lives ukládá poèet ¾ivotù, level u¾íváme k zaznamenávání obtí¾nosti. Není to level, který se zobrazuje na monitoru. Level2 zaèíná se stejnou hodnotou, ale mù¾e být inkrementován donekoneèna - zále¾í na obratnosti hráèe. Pokud doká¾e dosáhnout tøetího levelu, promìnná level se pøestane zvy¹ovat. urèuje pouze vnitøní obtí¾nost hry. Stage definuje konkrétní etapu hry.</p>

<p class="src0">int loop1;<span class="kom">// Øídící promìnná cyklù</span></p>
<p class="src0">int loop2;<span class="kom">// Øídící promìnná cyklù</span></p>
<p class="src0">int delay;<span class="kom">// Doba zastavení nepøátel</span></p>
<p class="src0">int adjust = 3;<span class="kom">// Rychlostní kompenzace pro pomalé systémy</span></p>
<p class="src0">int lives = 5;<span class="kom">// Poèet ¾ivotù hráèe</span></p>
<p class="src0">int level = 1;<span class="kom">// Vnitøní obtí¾nost hry</span></p>
<p class="src0">int level2 = level;<span class="kom">// Zobrazovaný level</span></p>
<p class="src0">int stage = 1;<span class="kom">// Etapa/fáze hry</span></p>

<p>Definujeme strukturu objektu - hráè, nepøítel ap. Vnitøní promìnné fx a fy ukládají pomocnou polohu pro plynulý pohyb (fx = fine x). X a y definují pozici na møí¾ce. Mohou nabývat hodnot od nuly do deseti. Kdybychom se s hráèem po scénì pohybovali pomocí tìchto dvou promìnných mìli bychom jedenáct pozic vodorovnì a jedenáct svisle. Hráè by pøeskakoval z jednoho místa na druhé. Proto pøi pohybu pou¾íváme upøesòující fx a fy. Poslední promìnnou spin pou¾íváme pro otáèení objektù okolo osy z.</p>

<p class="src0">struct object<span class="kom">// Struktura objektu ve høe</span></p>
<p class="src0">{</p>
<p class="src1">int fx, fy;<span class="kom">// Pohybová pozice</span></p>
<p class="src1">int x, y;<span class="kom">// Absolutní pozice</span></p>
<p class="src1">float spin;<span class="kom">// Otáèení objektu dokola</span></p>
<p class="src0">};</p>

<p>Na základì struktury vytvoøíme hráèe, devìt nepøátel a jeden speciální objekt - sklenìné pøesýpací hodiny, které se sem tam objeví. Pokud je stihnete sebrat, nepøítel se na chvíli zastaví.</p>

<p class="src0">struct object player;<span class="kom">// Hráè</span></p>
<p class="src0">struct object enemy[9];<span class="kom">// Nepøátelé</span></p>
<p class="src0">struct object hourglass;<span class="kom">// Sklenìné hodiny</span></p>

<p>Abychom promìnné pro èasovaè mìli pohromadì, slouèíme je do struktury. Frekvenci èasovaèe deklarujeme jako 64-bitové celé èíslo. Resolution je perioda (obrácená hodnota frekvence). Mm_timer_start a mm_timer_elapsed udr¾ují poèáteèní a uplynulý èas. Pou¾íváme je pouze tehdy, pokud poèítaè nemá performance counter (v pøekladu: èítaè provedení nebo výkonu, zùstanu u anglického termínu). Logická promìnná performance_timer bude nastavena na TRUE pokud program detekuje, ¾e poèítaè má performance counter. Pokud ho nenajde budeme pro èasování pou¾ívat ménì pøesný, ale celkovì dostaèující multimediální timer. Poslední dvì promìnné jsou opìt 64-bitové integery, které ukládají èas spu¹tìní a uplynulý èas performance counteru. Promìnnou na bázi této struktury pojmenujeme timer.</p>

<p class="src0">struct <span class="kom">// Informace pro èasovaè</span></p>
<p class="src0">{</p>
<p class="src1">__int64 frequency;<span class="kom">// Frekvence</span></p>
<p class="src1">float resolution;<span class="kom">// Perioda</span></p>
<p class="src1">unsigned long mm_timer_start;<span class="kom">// Startovní èas multimediálního timeru</span></p>
<p class="src1">unsigned long mm_timer_elapsed;<span class="kom">// Uplynulý èas multimediální timeru</span></p>
<p class="src1">bool performance_timer;<span class="kom">// U¾íváme Performance Timer?</span></p>
<p class="src1">__int64 performance_timer_start;<span class="kom">// Startovní èas Performance Timeru</span></p>
<p class="src1">__int64 performance_timer_elapsed;<span class="kom">// Uplynulý èas Performance Timeru</span></p>
<p class="src0">} timer;<span class="kom">// Struktura se jmenuje timer</span></p>

<p>Následující pole si mù¾eme pøedstavit jako tabulku rychlostí. objekt ve høe se mù¾e pohybovat rozdílnými rychlostmi. V¹e závisí na promìnné adjust (vý¹e). Pokud se její hodnota rovná nule pohybující se o pixel za urèitý èas, pokud pìti, rychlost èiní dvacet pixelù. Inkrementováním adjust se na pomalých poèítaèích zvý¹í rychlost (ale i &quot;trhanost&quot;) hry. Poèet pixelù kroku je v tabulce. Adjust pou¾íváme jako index do tohoto pole.</p>

<p class="src0">int steps[6]={ 1, 2, 4, 5, 10, 20 };<span class="kom">// Krokovací hodnota pro pøizpùsobení pomalého videa</span></p>

<p>Deklarujeme pole dvou textur - pozadí a bitmapový font. Base ukazuje na první display list fontu (viz. minulé tutoriály). Funkce pro nahrávání a vytváøení textur nebudu opisovat, byly tu u¾ tolikrát, ¾e je musíte znát na zpamì» (pøekladatel).</p>

<p class="src0">GLuint texture[2];<span class="kom">// Dvì textury</span></p>
<p class="src0">GLuint base;<span class="kom">// Základní display list pro font</span></p>

<p>Inicializujeme èasovaè. Zaèneme vynulováním v¹ech promìnných. Potom zjistíme, zda budeme moci pou¾ívat performance counter. Pokud ano,ulo¾íme frekvenci do timer.frequency, pokud ne budeme pou¾ívat multimediální timer - nastavíme timer.performance_timer na FALSE a naèteme do poèáteèní hodnoty aktuální èas. Timer.resolution definujeme na 0.001 (Pøekladatel: dìlení je celkem zbyteèné) a timer.frequency na 1000. Proto¾e je¹tì neuplynul ¾ádný èas, pøiøadíme uplynulému èasu startovní èas.</p>

<p class="src0">void TimerInit(void)<span class="kom">// Inicializace timeru</span></p>
<p class="src0">{</p>
<p class="src1">memset(&amp;timer, 0, sizeof(timer));<span class="kom">// Vynuluje promìnné struktury</span></p>
<p></p>
<p class="src1"><span class="kom">// Zjistí jestli je Performance Counter dostupný a pokud ano, bude naètena jeho frekvence</span></p>
<p class="src1">if (!QueryPerformanceFrequency((LARGE_INTEGER *) &amp;timer.frequency))</p>
<p class="src1">{</p>
<p class="src2"><span class="kom">// Performance Counter není dostupný</span></p>
<p class="src2">timer.performance_timer = FALSE;<span class="kom">// Nastaví Performance Timer na FALSE</span></p>
<p class="src2">timer.mm_timer_start = timeGetTime();<span class="kom">// Získání aktuálního èasu</span></p>
<p class="src2">timer.resolution = 1.0f/1000.0f;<span class="kom">// Nastavení periody</span></p>
<p class="src2">timer.frequency = 1000;<span class="kom">// Nastavení frekvence</span></p>
<p class="src2">timer.mm_timer_elapsed = timer.mm_timer_start;<span class="kom">// Uplynulý èas = poèáteèní</span></p>
<p class="src1">}</p>

<p>Má-li poèítaè performance counter projdeme touto vìtví. Nastavíme poèáteèní hodnotu a oznámíme, ¾e mù¾eme pou¾ívat performance counter. Poté spoèítáme periodu pomocí frekvence získané v if() vý¹e. Perioda je pøevrácená hodnota frekvence. Nakonec nastavíme uplynulý èas na startovní. V¹imnìte si, ¾e místo sdílení promìnných obou timerù, jsem se rozhodl pou¾ít rùzné. Obì cesty by pracovaly, ale tato je pøehlednìj¹í.</p>

<p class="src1">else</p>
<p class="src1">{</p>
<p class="src2"><span class="kom">// Performance Counter je mo¾né pou¾ívat</span></p>
<p class="src2">QueryPerformanceCounter((LARGE_INTEGER *) &amp;timer.performance_timer_start);<span class="kom">// Poèáteèní èas</span></p>
<p class="src2">timer.performance_timer = TRUE;<span class="kom">// Nastavení Performance Timer na TRUE</span></p>
<p class="src2">timer.resolution = (float) (((double)1.0f)/((double)timer.frequency));<span class="kom">// Spoèítání periody</span></p>
<p class="src2">timer.performance_timer_elapsed = timer.performance_timer_start;<span class="kom">//Nastaví uplynulý èas na poèáteèní</span></p>
<p class="src1">}</p>
<p class="src0">}</p>

<p>V následující funkci naèteme timer a vrátíme uplynulý èas v milisekundách. Deklarujeme 64-bitové celé èíslo, do kterého naèteme souèasnou hodnotu èítaèe. Opìt vìtvíme program podle pøítomnosti performance timeru. První øádkou v if() naèteme obsah èítaèe. Dále od nìj odeèteme poèáteèní èas, který jsme získali pøi inicializaci èasovaèe. Získaný rozdíl násobíme periodou èítaèe. Abychom výsledek v sekundách pøevedli na milisekundy násobíme ho tisícem. Tuto hodnotu vrátíme. Nepou¾íváme-li performance counter, provede se vìtev else, která dìlá analogicky to samé. Naèteme souèasný èas, odeèteme od nìj poèáteèní, násobíme periodou a poté tisícem. Opìt získáme uplynulý èas v milisekundách a vrátíme ho.</p>

<p class="src0">float TimerGetTime()<span class="kom">// Získá èas v milisekundách</span></p>
<p class="src0">{</p>
<p class="src1">__int64 time;<span class="kom">// Èas se ukládá do 64-bitového integeru</span></p>
<p></p>
<p class="src1">if (timer.performance_timer)<span class="kom">// Performance Timer</span></p>
<p class="src1">{</p>
<p class="src2">QueryPerformanceCounter((LARGE_INTEGER *) &amp;time);<span class="kom">// Naète aktuální èas</span></p>
<p class="src2"><span class="kom">// Vrátí uplynulý èas v milisekundách</span></p>
<p class="src2">return ((float)(time - timer.performance_timer_start) * timer.resolution)*1000.0f;</p>
<p class="src1">}</p>
<p class="src1">else<span class="kom">// Multimediální timer</span></p>
<p class="src1">{</p>
<p class="src2"><span class="kom">// Vrátí uplynulý èas v milisekundách</span></p>
<p class="src2">return ((float)(timeGetTime() - timer.mm_timer_start) * timer.resolution)*1000.0f;</p>
<p class="src1">}</p>
<p class="src0">}</p>

<p>V dal¹í funkci se resetuje pozice hráèe na levý horní roh a poloha nepøátel na randomové body. Levý horní roh scény má souøadnice [0;0]. Pøiøadíme je hráèovì x a y. Proto¾e je na zaèátku linek, nepohybuje se, tak¾e i upøesòující pohybové pozice nastavíme na nulu.</p>

<p class="src0">void ResetObjects(void)<span class="kom">// Reset hráèe a nepøátel</span></p>
<p class="src0">{</p>
<p class="src1">player.x = 0;<span class="kom">// Hráè bude vlevo nahoøe</span></p>
<p class="src1">player.y = 0;<span class="kom">// Hráè bude vlevo nahoøe</span></p>
<p class="src1">player.fx = 0;<span class="kom">// Pohybová pozice</span></p>
<p class="src1">player.fy = 0;<span class="kom">// Pohybová pozice</span></p>

<p>Pøejdeme k inicializaci polohy nepøátel. Jejich aktuální poèet (zobrazených) je roven vnitønímu levelu násobenému jeho souèasnou obtí¾ností/etapou. Zapamatujte si, ¾e maximální poèet levelù je tøi a maximální poèet etap v levelu je také tøi. Z toho plyne, ¾e mù¾eme mít nejvíce devìt nepøátel. V cyklu nastavíme x pozici ka¾dého nepøítele na pìt a¾ deset a y pozici na nula a¾ deset. Nechceme, aby se pohybovali ze staré pozice na novou, tak¾e se ujistíme, ¾e se fx a fy budou rovnat x krát délka linky (60) a y krát vý¹ka linky (40).</p>

<p class="src1"></p>
<p class="src1">for (loop1=0; loop1&lt;(stage*level); loop1++)<span class="kom">// Prochází nepøátele</span></p>
<p class="src1">{</p>
<p class="src2">enemy[loop1].x = 5 + rand() % 6;<span class="kom">// Nastaví randomovou x pozici</span></p>
<p class="src2">enemy[loop1].y = rand() % 11;<span class="kom">// Nastaví randomovou y pozici</span></p>
<p class="src2">enemy[loop1].fx = enemy[loop1].x * 60;<span class="kom">// Pohybová pozice</span></p>
<p class="src2">enemy[loop1].fy = enemy[loop1].y * 40;<span class="kom">// Pohybová pozice</span></p>
<p class="src1">}</p>
<p class="src0">}</p>

<p>Funkce glPrint() se moc nezmìnila. Narozdíl od minulých tutoriálù jsem pøidal mo¾nost výpisu hodnot promìnných. Zapneme mapování textur, resetujeme matici a pøesuneme se na urèenou pozici. Pokud je zvolena první (nultá) znaková sada, zmìníme mìøítko tak, aby byl font dvakrát vy¹¹í a jeden a pùl krát ¹ir¹í. Pomocí této finty budeme moci vypsat titul hry vìt¹ími písmeny. Na konci vypneme mapování textur.</p>

<p class="src0">GLvoid glPrint(GLint x, GLint y, int set, const char *fmt, ...)<span class="kom">// Výpis textù</span></p>
<p class="src0">{</p>
<p class="src1">char text[256];<span class="kom">// Bude ukládat výsledný øetìzec</span></p>
<p class="src1">va_list ap;<span class="kom">// Ukazatel do argumentù funkce</span></p>
<p></p>
<p class="src1">if (fmt == NULL)<span class="kom">// Nebyl pøedán øetìzec</span></p>
<p class="src2">return;<span class="kom">// Konec</span></p>
<p></p>
<p class="src1">va_start(ap, fmt);<span class="kom">// Rozdìlí øetìzec pro promìnné</span></p>
<p class="src1">vsprintf(text, fmt, ap);<span class="kom">// Konvertuje symboly na èísla</span></p>
<p class="src1">va_end(ap);<span class="kom">// Výsledek je ulo¾en v text</span></p>
<p></p>
<p class="src1">if (set&gt;1)<span class="kom">// Byla pøedána ¹patná znaková sada?</span></p>
<p class="src1">{</p>
<p class="src2">set=1;<span class="kom">// Pokud ano, zvolí se kurzíva</span></p>
<p class="src1">}</p>
<p></p>
<p class="src1">glEnable(GL_TEXTURE_2D);<span class="kom">// Zapne texturové mapování</span></p>
<p class="src1">glLoadIdentity();<span class="kom">// Reset matice</span></p>
<p class="src1">glTranslated(x,y,0);<span class="kom">// Pøesun na po¾adovanou pozici</span></p>
<p class="src1">glListBase(base-32+(128*set));<span class="kom">// Zvolí znakovou sadu</span></p>
<p></p>
<p class="src1">if (set==0)<span class="kom">// Pokud je urèena první znaková sada font bude vìt¹í</span></p>
<p class="src1">{</p>
<p class="src2">glScalef(1.5f,2.0f,1.0f);<span class="kom">// Zmìna mìøítka</span></p>
<p class="src1">}</p>
<p></p>
<p class="src1">glCallLists(strlen(text),GL_UNSIGNED_BYTE, text);<span class="kom">// Výpis textu na monitor</span></p>
<p class="src1">glDisable(GL_TEXTURE_2D);<span class="kom">// Vypne texturové mapování</span></p>
<p class="src0">}</p>

<p>Implementace zmìny velikosti okna je nová. Namísto perspektivní scény pou¾ijeme pravoúhlou projekci (ortho view). Její hlavní charakteristikou je, ¾e se pøi zmìnì vzdálenosti pozorovatele (translace do hloubky) objekty nezmen¹ují - vypnutá perspektiva. Osa z je ménì u¾iteèná, nìkdy dokonce ztrácí význam. V tomto tutoriálu s ní nebudeme pracovat vùbec.</p>

<p>Zaèneme nastavením viewportu, úplnì stejnì, jako pøi perspektivní scénì. Poté zvolíme projekèní matici (analogie filmovému projektoru; obsahuje informace, jak se zobrazí obrázek) a resetujeme ji.</p>

<p>Inicializujeme pravoúhlou projekci. První parametr 0.0f urèuje pozici levé hrany scény. Druhá pøedávaná hodnota oznaèuje polohu pravé hrany. Pokud by mìlo okno velikost 640 x 480, tak ve width bude ulo¾ena hodnota 640. Scéna by zaèínala na ose x nulou a konèila 640 - pøesnì jako okno. Tøetím parametrem oznaèujeme spodní okraj scény. Bývá záporný, ale proto¾e chceme pracovat s pixely urèíme spodek okna rovnu jeho vý¹ce. Nula, ètvrtý parametr, definuje horní okraj. Poslední dvì hodnoty nále¾í k ose z. V této lekci se o ni nestaráme, tak¾e nastavíme rozmezí od -1.0f do 1.0f. V¹echno budeme vykreslovat v hloubce nula, tak¾e uvidíme v¹e.</p>

<p>Po nastavení pravoúhlé scény, zvolíme matici modelview (informace o objektech, lokacích, atd.) a resetujeme ji.</p>

<p class="src0">GLvoid ReSizeGLScene(GLsizei width, GLsizei height)<span class="kom">// Inicializace a zmìna velikosti okna</span></p>
<p class="src0">{</p>
<p class="src1">if (height==0)<span class="kom">// Proti dìlení nulou</span></p>
<p class="src1">{</p>
<p class="src2">height=1;<span class="kom">// Vý¹ka se rovná jedné</span></p>
<p class="src1">}</p>
<p></p>
<p class="src1">glViewport(0,0,width,height);<span class="kom">// Reset Viewportu</span></p>
<p></p>
<p class="src1">glMatrixMode(GL_PROJECTION);<span class="kom">// Zvolí projekèní matici</span></p>
<p class="src1">glLoadIdentity();<span class="kom">// Reset projekèní matice</span></p>
<p></p>
<p class="src1">glOrtho(0.0f,width,height,0.0f,-1.0f,1.0f);<span class="kom">// Vytvoøí pravoúhlou scénu</span></p>
<p></p>
<p class="src1">glMatrixMode(GL_MODELVIEW);<span class="kom">// Zvolí matici modelview</span></p>
<p class="src1">glLoadIdentity();<span class="kom">// Reset matice modelview</span></p>
<p class="src0">}</p>

<p>Pøi inicializaci se vyskytne nìkolik nových pøíkazù. Zaèneme klasicky loadingem textur a kontrolou úspì¹nosti této akce, poté vygenerujeme znakovou sadu fontu. Zapneme jemné stínování, nastavíme èerné pozadí a vyèistíme hloubku jednièkou.</p>

<p>glHint() oznamuje OpenGL, jak má vykreslovat. V tomto pøípadì po¾adujeme, aby v¹echny linky byly nejhezèí, jaké OpenGL doká¾e vytvoøit. Tímto pøíkazem zapínáme antialiasing. Také zapneme blending a zvolíme jeho mód tak, abychom umo¾nili, ji¾ zmínìný, antialiasing linek. Blending je potøeba, pokud chceme pìknì skombinovat (smíchat, zprùhlednit - blend with) s obrázkem na pozadí. Pokud chcete vidìt, jak ¹patnì budou linky vypadat, vypnìte blending. Je dùle¾ité poukázat na fakt, ¾e antialiasing se nemusí zobrazovat správnì(? pøekl.). Objekty ve høe jsou docela malé, tak¾e si nemusíte v¹imnout, ¾e nìco není v poøádku. Podívejte se poøádnì. V¹imnìte si, jak se linky na nepøátelích zjemní pokud je antialiasing zapnutý. Hráè a hodiny by mìli vypadat mnohem lépe.</p>

<p class="src0">int InitGL(GLvoid)<span class="kom">// Nastavení OpenGL</span></p>
<p class="src0">{</p>
<p class="src1">if (!LoadGLTextures())<span class="kom">// Loading textur</span></p>
<p class="src1">{</p>
<p class="src2">return FALSE;</p>
<p class="src1">}</p>
<p></p>
<p class="src1">BuildFont();<span class="kom">// Vytvoøení fontu</span></p>
<p></p>
<p class="src1">glShadeModel(GL_SMOOTH);<span class="kom">// Zapne jemné stínování</span></p>
<p class="src1">glClearColor(0.0f, 0.0f, 0.0f, 0.5f);<span class="kom">// Èerné pozadí</span></p>
<p class="src1">glClearDepth(1.0f);<span class="kom">// Nastavení hloubkového bufferu</span></p>
<p class="src1">glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);<span class="kom">// Nastavení antialiasingu linek</span></p>
<p class="src1">glEnable(GL_BLEND);<span class="kom">// Zapne blending</span></p>
<p class="src1">glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);<span class="kom">// Typ blendingu</span></p>
<p class="src1">return TRUE;</p>
<p class="src0">}</p>

<p>Na øadu pøichází vykreslování. Sma¾eme obrazovku a hloubkový buffer a zvolíme texturu fontu - texture[0]. Abychom slova "GRID CRAZY" vypsali purpurovou barvou nastavíme R a G naplno, G s polovièní intenzitou. Nápis vypí¹eme na souøadnice [207;24]. Pou¾ijeme první (nultou) znakovou sadu, tak¾e bude text velkými písmeny. Poté zamìníme purpurovou barvu za ¾lutou a vypí¹eme "Level" s obsahem promìnné level2. Dvojka v %2i urèuje maximální poèet èíslic. Pomocí i oznamujeme, ¾e se jedná o celoèíselnou promìnnou (integer). O trochu ní¾e, tou samou barvou, zobrazíme "Stage" s konkrétní etapou hry.</p>

<p class="src0">int DrawGLScene(GLvoid)<span class="kom">// V¹echno kreslení</span></p>
<p class="src0">{</p>
<p class="src1">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<span class="kom">// Sma¾e obrazovku a hloubkový buffer</span></p>
<p class="src1">glBindTexture(GL_TEXTURE_2D, texture[0]);<span class="kom">// Zvolí texturu fontu</span></p>
<p></p>
<p class="src1">glColor3f(1.0f,0.5f,1.0f);<span class="kom">// Purpurová barva</span></p>
<p class="src1">glPrint(207,24,0,&quot;GRID CRAZY&quot;);<span class="kom">// Vypí¹e logo hry</span></p>
<p></p>
<p class="src1">glColor3f(1.0f,1.0f,0.0f);<span class="kom">// ®lutá barva</span></p>
<p class="src1">glPrint(20,20,1,&quot;Level:%2i&quot;,level2);<span class="kom">// Vypí¹e level</span></p>
<p class="src1">glPrint(20,40,1,&quot;Stage:%2i&quot;,stage);<span class="kom">// Vypí¹e etapu</span></p>

<p>Zkontrolujeme konec hry. Pokud je gameover rovno TRUE zvolíme náhodnou barvu. Pou¾íváme glcolor3ub(), proto¾e je mnohem jednodu¹¹í vygenerovat èíslo od 0 do 255 ne¾ od 0.0f do 1.0f. Doprava od titulku hry vypí¹eme "GAME OVER" a o øádek ní¾e "PRESS SPACE". Upozoròujeme hráèe, ¾e zemøel a ¾e pomocí mezerníku mù¾e hru resetovat.</p>

<p class="src1">if (gameover)<span class="kom">// Konec hry?</span></p>
<p class="src1">{</p>
<p class="src2">glColor3ub(rand()%255,rand()%255,rand()%255);<span class="kom">// Náhodná barva</span></p>
<p class="src2">glPrint(472,20,1,&quot;GAME OVER&quot;);<span class="kom">// Vypí¹e GAME OVER</span></p>
<p class="src2">glPrint(456,40,1,&quot;PRESS SPACE&quot;);<span class="kom">// Vypí¹e PRESS SPACE</span></p>
<p class="src1">}</p>

<p>Pokud mu v¹ak nìjaké ¾ivoty zbyly, zobrazíme doprava od titulku hry animované obrázky hráèe. Vytvoøíme cyklus, který jde od nuly do aktuálního poètu ¾ivotù mínus jedna. Jednièku odeèítáme, proto¾e jeden obrázek se zobrazuje do hracího pole.</p>

<p class="src1">for (loop1=0; loop1&lt;lives-1; loop1++)<span class="kom">// Cyklus vykreslující ¾ivoty</span></p>
<p class="src1">{</p>

<p>Uvnitø cyklu resetujeme matici a provedeme translaci doprava na pozici, kterou získáme výpoètem: 490 plus øídící promìnná krát 40. Tímto zpùsobem budeme moci vykreslit ka¾dý animovaný ¾ivot hráèe o 40 pixelù doprava od minulého. Poté orotujeme pohled proti smìru hodinových ruèièek v závislosti na hodnotì ulo¾ené v player.spin. Záporným znaménkem zpùsobíme, ¾e se budou ¾ivoty otáèet opaèným smìrem ne¾ hráè.</p>

<p class="src2">glLoadIdentity();<span class="kom">// Reset matice</span></p>
<p></p>
<p class="src2">glTranslatef(490+(loop1*40.0f),40.0f,0.0f);<span class="kom">// Pøesun doprava od titulku</span></p>
<p class="src2">glRotatef(-player.spin,0.0f,0.0f,1.0f);<span class="kom">// Rotace proti smìru hodinových ruèièek</span></p>

<p>Zvolíme zelenou barvu a zaèneme zobrazovat. Kreslení linek je úplnì stejné, jako kreslení polygonù. Zaèneme s glBegin(GL_LINES). Tím oznámíme OpenGL, ¾e chceme kreslit pøímky. Pro jednu staèí pouze dva body. My zadáváme body pomocí glVertex2d(), proto¾e nepotøebujeme hloubku, ale samozøejmì lze pou¾ít i glVertex3f() pro plnohodnotný bod ve 3D prostoru.</p>

<p class="src2">glColor3f(0.0f,1.0f,0.0f);<span class="kom">// Zelená barva</span></p>
<p></p>
<p class="src2">glBegin(GL_LINES);<span class="kom">// Zaèátek kreslení ¾ivotù</span></p>
<p></p>
<p class="src3">glVertex2d(-5,-5);<span class="kom">// Levý horní bod</span></p>
<p class="src3">glVertex2d( 5, 5);<span class="kom">// Pravý dolní bod</span></p>
<p class="src3">glVertex2d( 5,-5);<span class="kom">// Pravý horní bod</span></p>
<p class="src3">glVertex2d(-5, 5);<span class="kom">// Levý dolní bod</span></p>
<p></p>
<p class="src2">glEnd();<span class="kom">// Konec kreslení</span></p>

<p>Po vykreslení X (X - tvar hráèe), znovu natoèíme scénu, ale tentokrát pouze o polovinu úhlu. Zadáme tmav¹í zelenou barvu a vykreslíme +, ale trochu vìt¹í ne¾ X. Proto¾e je + pomalej¹í a tmav¹í, X vypadá, jako by se otáèelo na jeho vrcholu.</p>

<p class="src2">glRotatef(-player.spin*0.5f,0.0f,0.0f,1.0f);<span class="kom">// Rotace proti smìru hodinových ruèièek</span></p>
<p class="src2">glColor3f(0.0f,0.75f,0.0f);<span class="kom">// Tmav¹í zelená barva</span></p>
<p></p>
<p class="src2">glBegin(GL_LINES);<span class="kom">// Pokraèování kreslení ¾ivotù</span></p>
<p></p>
<p class="src3">glVertex2d(-7, 0);<span class="kom">// Levý støedový bod</span></p>
<p class="src3">glVertex2d( 7, 0);<span class="kom">// Pravý støedový bod</span></p>
<p class="src3">glVertex2d( 0,-7);<span class="kom">// Horní støedový bod</span></p>
<p class="src3">glVertex2d( 0, 7);<span class="kom">// Dolní støedový bod</span></p>
<p></p>
<p class="src2">glEnd();<span class="kom">// Konec kreslení</span></p>
<p class="src1">}</p>

<p>Nakreslíme herní møí¾ku. Nastavením promìnné filled na TRUE oznámíme programu, ¾e u¾ byla møí¾ka kompletnì vyplnìná (více dále). Urèíme ¹íøku èáry na 2.0f - linky ztloustnou a møí¾ka bude opticky více definovaná. Pøesto¾e se zhor¹í kvalita grafického výstupu, vypneme antialiasing. Velmi zatì¾uje procesor a pokud nemáte hodnì dobrou grafickou kartu, zaznamenáte obrovské zpomalení. Vyzkou¹ejte si a konejte, jak uznáte za vhodné.</p>

<p class="src1">filled=TRUE;<span class="kom">// Pøed testem je v¹echno vyplnìné</span></p>
<p class="src1">glLineWidth(2.0f);<span class="kom">// ©ir¹í èáry</span></p>
<p class="src1">glDisable(GL_LINE_SMOOTH);<span class="kom">// Vypne antialiasing</span></p>
<p class="src1">glLoadIdentity();<span class="kom">// Reset matice</span></p>

<p>Po resetu matice deklarujeme dva vnoøené cykly. Prvním procházíme møí¾ku zleva doprava a druhým ze shora dolù. Nastavíme barvu na modrou a pokud je právì kreslená linka ji¾ pøejetá hráèem, pøebijeme modrou barvu bílou. Dále zkontrolujeme, zda se nechystáme kreslit pøíli¹ vpravo. Pokud ano pøeskoèíme kreslení.</p>

<p class="src1">for (loop1=0; loop1&lt;11; loop1++)<span class="kom">// Cyklus zleva doprava</span></p>
<p class="src1">{</p>
<p class="src2">for (loop2=0; loop2&lt;11; loop2++)<span class="kom">// Cyklus ze shora dolù</span></p>
<p class="src2">{</p>
<p class="src3">glColor3f(0.0f,0.5f,1.0f);<span class="kom">// Modrá barva</span></p>
<p></p>
<p class="src3">if (hline[loop1][loop2])<span class="kom">// Byla u¾ linka pøejetá?</span></p>
<p class="src3">{</p>
<p class="src4">glColor3f(1.0f,1.0f,1.0f);<span class="kom">// Bílá barva</span></p>
<p class="src3">}</p>
<p></p>
<p class="src3">if (loop1&lt;10)<span class="kom">// Nekreslit úplnì vpravo</span></p>
<p class="src3">{</p>

<p>Otestujeme, jestli u¾ byla horizontální linka pøejetá. Pokud ne, pøiøadíme do filled FALSE a tím oznámíme, ¾e je¹tì nejménì jedna linka nebyla vyplnìná, a tudí¾ je¹tì nemù¾eme tento level opustit.</p>

<p class="src4">if (!hline[loop1][loop2])<span class="kom">// Nebyla linka je¹tì pøejetá?</span></p>
<p class="src4">{</p>
<p class="src5">filled=FALSE;<span class="kom">// V¹echno je¹tì není vyplnìno</span></p>
<p class="src4">}</p>

<p>Poté koneènì vykreslíme horizontální linku. Proto¾e je vodorovná, pøiøadíme y-ové hodnotì obou bodù stejnou velikost. Pøièítáme sedmdesátku, aby nad hracím polem zùstalo volné místo pro informace o poètu ¾ivotù, levelu ap. Hodnoty na ose x se li¹í tím, ¾e druhý bod je posunut o ¹edesát pixelù doprava (80-20=60). Opìt pøièítáme konstantu, v tomto pøípadì dvacítku, aby hrací pole nebylo namaèkáno na levý okraj a vpravo nebyla zbyteèná mezera. V¹imnìte si, ¾e linky jsou kresleny zleva doprava. Toto je dùvod, proè nechceme kreslit jedenáctou - neve¹la by se na obrazovku.</p>

<p class="src4">glBegin(GL_LINES);<span class="kom">// Zaèátek kreslení horizontálních linek</span></p>
<p class="src5">glVertex2d(20+(loop1*60),70+(loop2*40));<span class="kom">// Levý bod</span></p>
<p class="src5">glVertex2d(80+(loop1*60),70+(loop2*40));<span class="kom">// Pravý bod</span></p>
<p class="src4">glEnd();<span class="kom">// Konec kreslení</span></p>
<p class="src3">}</p>

<p>Na øadu pøicházejí vertikální linky. Kód je témìø stejný, tak¾e text popisu nebudu zbyteènì opisovat. Linky se kreslí ze shora dolù namísto zleva doprava - jediná odli¹nost.</p>

<p class="src3">glColor3f(0.0f,0.5f,1.0f);<span class="kom">// Modrá barva</span></p>
<p></p>
<p class="src3">if (vline[loop1][loop2])<span class="kom">// Byla u¾ linka pøejetá?</span></p>
<p class="src3">{</p>
<p class="src4">glColor3f(1.0f,1.0f,1.0f);<span class="kom">// Bílá barva</span></p>
<p class="src3">}</p>
<p></p>
<p class="src3">if (loop2&lt;10)<span class="kom">// Nekreslit úplnì dolù</span></p>
<p class="src3">{</p>
<p class="src4">if (!vline[loop1][loop2])<span class="kom">// Nebyla linka je¹tì pøejetá?</span></p>
<p class="src4">{</p>
<p class="src5">filled=FALSE;<span class="kom">// V¹echno je¹tì nebylo vyplnìno</span></p>
<p class="src4">}</p>
<p></p>
<p class="src4">glBegin(GL_LINES);<span class="kom">// Zaèátek kreslení vertikálních linek</span></p>
<p class="src5">glVertex2d(20+(loop1*60),70 +(loop2*40));<span class="kom">// Horní bod</span></p>
<p class="src5">glVertex2d(20+(loop1*60),110+(loop2*40));<span class="kom">// Dolní bod</span></p>
<p class="src4">glEnd();<span class="kom">// Konec kreslení</span></p>
<p class="src3">}</p>

<p>Scéna je dohromady seskládaná z obdélníkù o velikosti jedné desetiny obrázku scény. Na ka¾dý z nich je namapovaná urèitá èást velké textury, proto musíme zapnout mapování textur. Proto¾e nechceme, aby mìl kreslený obdélník barevný nádech, nastavíme barvu na bílou. Také nesmíme zapomenout zvolit texturu.</p>

<div class="okolo_img"><img src="images/nehe_tut/tut_21_image.jpg" width="128" height="128" alt="Textura hrací plochy" /></div>

<p class="src3">glEnable(GL_TEXTURE_2D);<span class="kom">// Zapne mapování textur</span></p>
<p class="src3">glColor3f(1.0f,1.0f,1.0f);<span class="kom">// Bílá barva</span></p>
<p class="src3">glBindTexture(GL_TEXTURE_2D, texture[1]);<span class="kom">// Zvolí texturu</span></p>

<p>Dále provìøíme, jestli aktuální obdélník ve scénì je¹tì existuje (není za hranou hrací plochy). Nacházíme se v cyklech, které postupnì vykreslují 11 linek vodorovnì a 11 svisle. Nicménì nevykreslujeme 11 obdélníkù, ale pouze 10! Ovìøíme, jestli se nechystáme kreslit na jedenáctou pozici - loop1 i loop2 musí být men¹í ne¾ deset (0-9).</p>

<p class="src3">if ((loop1&lt;10) &amp;&amp; (loop2&lt;10))<span class="kom">// Pouze pokud je obdélník v hrací plo¹e</span></p>
<p class="src3">{</p>

<p>Zjistíme pøejetí v¹ech okolních linek obdélníku. Kraje testujeme v poøadí: horní, dolní, levý a pravý. Po ka¾dém prùchodu vnitøním cyklem se inkrementuje loop1 a tím se z pravého okraje stává levý okraj následujícího obdélníku. V pøípadì prùchodu vnìj¹í smyèkou se ze spodních hran obdélníkù v øádku stávají horní okraje nových obdélníkù v øádku o jedno ní¾e. V¹e by mìlo být zøejmé z diagramu.</p>

<div class="okolo_img"><img src="images/nehe_tut/tut_21_diagram.jpg" width="256" height="128" alt="Diagram" /></div>

<p>Pokud jsou v¹echny okraje projeté (rovnají se TRUE), mù¾eme namapovat texturu a vykreslit obdélník. Dìláme to stejným stylem, jako jsme rozøezávali texturu znakové sady na jednotlivá písmena. Ani teï se neobejdeme bez matematiky. Dìlíme loop1 i loop2 deseti, proto¾e chceme rozdìlit texturu mezi sto obdélníkù (10x10). Koordináty jsou v rozmezí od nuly do jedné s krokem jedné desetiny (1/10=0,1).</p>

<p>Tak¾e abychom dostali pravý horní roh, vydìlíme hodnotu promìnných loop deseti a pøièteme 0,1 k x-ovému koordinátu. Levý horní roh získáme dìlením bez ¾ádných dal¹ích komplikací. Levý dolní bod spoèívá opìt v dìlení deseti a pøiètení 0,1 k ypsilonové slo¾ce. Dostáváme se k pravému dolnímu rohu, u kterého se po vydìlení pøièítá 0,1 k obìma souøadnicovým slo¾kám. Doufám, ¾e to dává smysl (Já taky - pøekl.).</p>

<p>Pokud budou oba loopy rovny devíti, ve výsledku dostaneme kombinaci 0,9 a 1,0, které dosadíme do parametrù funkce glTexCoord2f(x,y). souøadnice vrcholù obdélníkù pro glVertex2d(x,y) získáme analogicky jako okraje linek møí¾ky. Pøièítáme k nim, ale je¹tì konstanty (1, 59, 1, 39), které zaji¹»ují zmen¹ení obdélníkù - aby se ve¹ly do políèek møí¾ky a pøitom nic nepøekryly.</p>

<p class="src4"><span class="kom">// Jsou pøejety v¹echny ètyøi okraje obdélníku?</span></p>
<p class="src4">if (hline[loop1][loop2] &amp;&amp; hline[loop1][loop2+1] &amp;&amp; vline[loop1]loop2] &amp;&amp; vline[loop1+1][loop2])</p>
<p class="src4">{</p>
<p class="src5">glBegin(GL_QUADS);<span class="kom">// Vykreslí otexturovaný obdélník</span></p>
<p></p>
<p class="src6">glTexCoord2f(float(loop1/10.0f)+0.1f,1.0f-(float(loop2/10.0f)));</p>
<p class="src6">glVertex2d(20+(loop1*60)+59,(70+loop2*40+1));<span class="kom">// Pravý horní</span></p>
<p></p>
<p class="src6">glTexCoord2f(float(loop1/10.0f),1.0f-(float(loop2/10.0f)));</p>
<p class="src6">glVertex2d(20+(loop1*60)+1,(70+loop2*40+1));<span class="kom">// Levý horní</span></p>
<p></p>
<p class="src6">glTexCoord2f(float(loop1/10.0f),1.0f-(float(loop2/10.0f)+0.1f));</p>
<p class="src6">glVertex2d(20+(loop1*60)+1,(70+loop2*40)+39);<span class="kom">// Levý dolní</span></p>
<p></p>
<p class="src6">glTexCoord2f(float(loop1/10.0f)+0.1f,1.0f-(float(loop2/10.0f)+0.1f));</p>
<p class="src6">glVertex2d(20+(loop1*60)+59,(70+loop2*40)+39);<span class="kom">// Pravý dolní</span></p>
<p></p>
<p class="src5">glEnd();<span class="kom">// Konec kreslení</span></p>
<p class="src4">}</p>
<p class="src3">}</p>

<p>V závìru vypneme mapování textur a po opu¹tìní obou cyklù vrátíme ¹íøku èáry na pùvodní hodnotu.</p>

<p class="src3">glDisable(GL_TEXTURE_2D);<span class="kom">// Vypne mapování textur</span></p>
<p class="src2">}</p>
<p class="src1">}</p>
<p></p>
<p class="src1">glLineWidth(1.0f);<span class="kom">// ©íøka èáry 1.0f</span></p>

<p>V pøípadì, ¾e je anti rovno TRUE, zapneme zjemòování linek (antialiasing).</p>

<p class="src1">if (anti)<span class="kom">// Má být zapnutý antialiasing?</span></p>
<p class="src1">{</p>
<p class="src2">glEnable(GL_LINE_SMOOTH);<span class="kom">// Zapne antialiasing</span></p>
<p class="src1">}</p>

<p>Abychom usnadnili hru, pøidáme speciální objekt - pøesýpací hodiny, jejich¾ sebráním se nepøátelé na chvíli zastaví. Pro jejich umístìní v hracím poli pou¾íváme promìnné x a y, nicménì proto¾e se nebudou pohybovat, mù¾eme vyu¾ít nepotøebné fx jako pøepínaè (0 jsou viditelné, 1 nejsou, 2 hráè je sebral). Fy implementujeme pro èítaè, jak dlouho by mìly být viditelné.</p>

<p>Zaèneme testem viditelnosti. Pokud se nemají zobrazit, pøeskoèíme vykreslení. Pokud ano, resetujeme matici a translací je umístíme. Proto¾e møí¾ka zaèíná na dvacítce, pøièteme tuto hodnotu k x*60. Ze stejného dùvodu na ose y pøièítáme 70. Dále orotujeme matici okolo osy z o úhel ulo¾ený v hourglass.spin. Pøed vykreslením je¹tì zvolíme náhodnou barvu.</p>

<p class="src1">if (hourglass.fx==1)<span class="kom">// Hodiny se mají vykreslit</span></p>
<p class="src1">{</p>
<p class="src2">glLoadIdentity();<span class="kom">// Reset Matice</span></p>
<p></p>
<p class="src2">glTranslatef(20.0f+(hourglass.x*60),70.0f+(hourglass.y*40),0.0f);<span class="kom">// Umístìní</span></p>
<p class="src2">glRotatef(hourglass.spin,0.0f,0.0f,1.0f);<span class="kom">// Rotace ve smìru hodinových ruèièek</span></p>
<p></p>
<p class="src2">glColor3ub(rand()%255,rand()%255,rand()%255);<span class="kom">// Náhodná barva</span></p>

<p>Pomocí GL_LINES oznámíme kreslení linek. Horní levý bod získáme odeètením pìti pixelù v obou smìrech. Konec pøímky le¾í pìt pixelù smìrem vpravo dolù od aktuální pozice. Druhou linku zaèneme vpravo nahoøe a skonèíme vlevo dole. Tvar písmene X doplníme o horní a dolní uzavírací linku.</p>

<p class="src2">glBegin(GL_LINES);<span class="kom">// Vykreslení pøesýpacích hodin</span></p>
<p></p>
<p class="src3">glVertex2d(-5,-5);<span class="kom">// Levý horní bod</span></p>
<p class="src3">glVertex2d( 5, 5);<span class="kom">// Pravý dolní bod</span></p>
<p class="src3">glVertex2d( 5,-5);<span class="kom">// Pravý horní bod</span></p>
<p class="src3">glVertex2d(-5, 5);<span class="kom">// Levý dolní bod</span></p>
<p></p>
<p class="src3">glVertex2d(-5, 5);<span class="kom">// Levý dolní bod</span></p>
<p class="src3">glVertex2d( 5, 5);<span class="kom">// Pravý dolní bod</span></p>
<p class="src3">glVertex2d(-5,-5);<span class="kom">// Levý horní bod</span></p>
<p class="src3">glVertex2d( 5,-5);<span class="kom">// Pravý horní bod</span></p>
<p></p>
<p class="src2">glEnd();<span class="kom">// Konec kreslení</span></p>
<p class="src1">}</p>

<p>Dále vykreslíme hráèe. Opìt resetujeme matici a urèíme pozici ve scénì. V¹imnìte si, ¾e pro jemný neskokový pohyb pou¾íváme fx a fy. Natoèíme matici o ulo¾ený úhel, zvolíme svìtle zelenou barvu a pomocí linek vykreslíme tvar písmene X.</p>

<p class="src1">glLoadIdentity();<span class="kom">// Reset Matice</span></p>
<p></p>
<p class="src1">glTranslatef(player.fx+20.0f,player.fy+70.0f,0.0f);<span class="kom">// Pøesun na pozici</span></p>
<p class="src1">glRotatef(player.spin,0.0f,0.0f,1.0f);<span class="kom">// Rotace po smìru hodinových ruèièek</span></p>
<p></p>
<p class="src1">glColor3f(0.0f,1.0f,0.0f);<span class="kom">// Zelená barva</span></p>
<p></p>
<p class="src1">glBegin(GL_LINES);<span class="kom">// Vykreslení hráèe</span></p>
<p></p>
<p class="src2">glVertex2d(-5,-5);<span class="kom">// Levý horní bod</span></p>
<p class="src2">glVertex2d( 5, 5);<span class="kom">// Pravý dolní bod</span></p>
<p class="src2">glVertex2d( 5,-5);<span class="kom">// Pravý horní bod</span></p>
<p class="src2">glVertex2d(-5, 5);<span class="kom">// Levý dolní bod</span></p>
<p></p>
<p class="src1">glEnd();<span class="kom">// Konec kreslení</span></p>

<p>Aby nevypadal a¾ tak nudnì, pøidáme je¹tì tvar znamínka +, které se otáèí trochu rychleji, má tmav¹í barvu a je o dva pixely vìt¹í.</p>

<p class="src1">glRotatef(player.spin*0.5f,0.0f,0.0f,1.0f);<span class="kom">// Rotace po smìru hodinových ruèièek</span></p>
<p></p>
<p class="src1">glColor3f(0.0f,0.75f,0.0f);<span class="kom">// Tmav¹í zelená barva</span></p>
<p></p>
<p class="src1">glBegin(GL_LINES);<span class="kom">// Pokraèování kreslení hráèe</span></p>
<p></p>
<p class="src2">glVertex2d(-7, 0);<span class="kom">// Levý støedový bod</span></p>
<p class="src2">glVertex2d( 7, 0);<span class="kom">// Pravý støedový bod</span></p>
<p class="src2">glVertex2d( 0,-7);<span class="kom">// Horní støedový bod</span></p>
<p class="src2">glVertex2d( 0, 7);<span class="kom">// Dolní støedový bod</span></p>
<p></p>
<p class="src1">glEnd();<span class="kom">// Konec kreslení</span></p>

<p>Je¹tì zbývá vykreslit nepøátele, tak¾e se do nich pustíme. Deklarujeme cyklus procházející v¹echny nepøátele, kteøí jsou viditelní v konkrétním levelu. Tento poèet získáme vynásobením levelu s obtí¾ností. Jejich maximální poèet je devìt. Uvnitø smyèky resetujeme matici a umístíme právì vykreslovaného nepøítele pomocí fx a fy (mù¾e se pohybovat). Zvolíme rù¾ovou barvu a pomocí linek vykreslíme ètverec postavený na ¹pièku, který nerotuje.</p>

<p class="src1">for (loop1=0; loop1&lt;(stage*level); loop1++)<span class="kom">// Vykreslí nepøátele</span></p>
<p class="src1">{</p>
<p class="src2">glLoadIdentity();<span class="kom">// Reset matice</span></p>
<p></p>
<p class="src2">glTranslatef(enemy[loop1].fx+20.0f,enemy[loop1].fy+70.0f,0.0f);<span class="kom">// Pøesun na pozici</span></p>
<p class="src2">glColor3f(1.0f,0.5f,0.5f);<span class="kom">// Rù¾ová barva</span></p>
<p></p>
<p class="src2">glBegin(GL_LINES);<span class="kom">// Vykreslení nepøátel</span></p>
<p></p>
<p class="src3">glVertex2d( 0,-7);<span class="kom">// Horní bod</span></p>
<p class="src3">glVertex2d(-7, 0);<span class="kom">// Levý bod</span></p>
<p class="src3">glVertex2d(-7, 0);<span class="kom">// Levý bod</span></p>
<p class="src3">glVertex2d( 0, 7);<span class="kom">// Dolní bod</span></p>
<p class="src3">glVertex2d( 0, 7);<span class="kom">// Dolní bod</span></p>
<p class="src3">glVertex2d( 7, 0);<span class="kom">// Pravý bod</span></p>
<p class="src3">glVertex2d( 7, 0);<span class="kom">// Pravý bod</span></p>
<p class="src3">glVertex2d( 0,-7);<span class="kom">// Horní bod</span></p>
<p></p>
<p class="src2">glEnd();<span class="kom">// Konec kreslení</span></p>

<p>Pøidáme krvavì èervené X, které se otáèí okolo osy z a poté ukonèíme obrovskou vykreslovací funkci.</p>

<p class="src2">glRotatef(enemy[loop1].spin,0.0f,0.0f,1.0f);<span class="kom">// Rotace vnitøku nepøítele</span></p>
<p></p>
<p class="src2">glColor3f(1.0f,0.0f,0.0f);<span class="kom">// Krvavá barva</span></p>
<p></p>
<p class="src2">glBegin(GL_LINES);<span class="kom">// Pokraèování kreslení nepøátel</span></p>
<p></p>
<p class="src3">glVertex2d(-7,-7);<span class="kom">// Levý horní bod</span></p>
<p class="src3">glVertex2d( 7, 7);<span class="kom">// Pravý dolní bod</span></p>
<p class="src3">glVertex2d(-7, 7);<span class="kom">// Levý dolní bod</span></p>
<p class="src3">glVertex2d( 7,-7);<span class="kom">// Pravý horní bod</span></p>
<p></p>
<p class="src2">glEnd();<span class="kom">// Konec kreslení</span></p>
<p class="src1">}</p>
<p></p>
<p class="src1">return TRUE;<span class="kom">// Konec funkce</span></p>
<p class="src0">}</p>

<p>Zmìn ve funkci WinMain() bude také trochu víc. Proto¾e se jedná o hru, musíme o¹etøit ovládání klávesnicí, èasování a v¹e ostatní, co jsme dosud neudìlali.</p>

<p class="src0">int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)</p>
<p class="src0">{</p>
<p class="src1">MSG msg;</p>
<p class="src1">BOOL done=FALSE;</p>
<p></p>
<p class="src1">if (MessageBox(NULL,&quot;Would You Like To Run In Fullscreen Mode?&quot;, &quot;Start FullScreen?&quot;, MB_YESNO|MB_ICONQUESTION) == IDNO)</p>
<p class="src1">{</p>
<p class="src2">fullscreen=FALSE;</p>
<p class="src1">}</p>

<p>Zmìníme titulek okna na "NeHe's Line Tutorial" a pøidáme volání funkce ResetObjects(), která inicializuje pozici hráèe na levý horní roh a nepøátelùm pøedìlí náhodné umístìní, nejménì v¹ak pìt políèek od hráèe. Poté zavoláme funkci pro inicializaci timeru.</p>

<p class="src1">if (!CreateGLWindow(&quot;NeHe's Particle Tutorial&quot;,640,480,16,fullscreen))</p>
<p class="src1">{</p>
<p class="src2">return 0;</p>
<p class="src1">}</p>
<p></p>
<p class="src1">ResetObjects();<span class="kom">// Inicializuje pozici hráèe a nepøátel</span></p>
<p class="src1">TimerInit();<span class="kom">// Zprovoznìní timeru</span></p>
<p></p>
<p class="src1">while(!done)</p>
<p class="src1">{</p>
<p class="src2">if (PeekMessage(&amp;msg,NULL,0,0,PM_REMOVE))</p>
<p class="src2">{</p>
<p class="src3">if (msg.message==WM_QUIT)</p>
<p class="src3">{</p>
<p class="src4">done=TRUE;</p>
<p class="src3">}</p>
<p class="src3">else</p>
<p class="src3">{</p>
<p class="src4">TranslateMessage(&amp;msg);</p>
<p class="src4">DispatchMessage(&amp;msg);</p>
<p class="src3">}</p>
<p class="src2">}</p>
<p class="src2">else</p>
<p class="src2">{</p>

<p>Teï zajistíme, aby pracoval kód pro èasování. Pøedtím ne¾ vykreslíme scénu, nagrabujeme aktuální èas a ulo¾íme jej do desetinné promìnné nazvané start. Potom vykreslíme scénu a prohodíme buffery.</p>

<p class="src3">float start=TimerGetTime();<span class="kom">// Nagrabujeme aktuální èas</span></p>
<p></p>
<p class="src3">if ((active &amp;&amp; !DrawGLScene()) || keys[VK_ESCAPE])</p>
<p class="src3">{</p>
<p class="src4">done=TRUE;</p>
<p class="src3">}</p>
<p class="src3">else</p>
<p class="src3">{</p>
<p class="src4">SwapBuffers(hDC);</p>
<p class="src3">}</p>

<p>Vytvoøíme èasové zpo¾dìní a to tak, ¾e vkládáme prázdné pøíkazy tak dlouho, dokud je aktuální hodnota èasovaèe (TimerGetTime()) men¹í ne¾ poèáteèní hodnota seètená s rychlostí kroky hry krát dva. tímto velmi jednodu¹e zpomalíme OPRAVDU rychlé systémy.</p>

<p>Proto¾e pou¾íváme krokování rychlosti (urèené promìnnou adjust) program v¾dy pobì¾í stejnou rychlostí. Napøíklad, pokud je hodnota kroku rovna jedné, mìli bychom èekat dokud timer nebude vìt¹í nebo roven dvìma (2*1). Ale pokud zvìt¹íme rychlost kroku na dva (zpùsobí, ¾e se hráè bude pohybovat o dvakrát tolik pixelù najednou), zpo¾dìní se zvìt¹í na ètyøi (2*2). Aèkoli se pohybujeme dvakrát tak rychle, zpo¾dìní trvá dvakrát déle a tudí¾ hra bì¾í stejnì rychle (ale více trhanì).</p>

<p>Spousta lidí jde ale jinou cestou ne¾ my. Je tøeba brát v úvahu èas který ubìhl mezi jednotlivými cykly ve kterých se renderuje. Na zaèátku ka¾dého cyklu se ulo¾í aktuální èas, od kterého se odeète èas v minulém cyklu a tímto rozdílem se vydìlí rychlost, kterou se má objekt pohybovat. Napøíklad: máme auto, které má jet rychlostí 10 jednotek za sekundu. Víme, ¾e mezi tímto a pøedchozím cyklem ubìhlo 20 ms. Objekt musíme tedy posunout o 10/(20*1000) = 0,0005 jednotek. Bohu¾el v tomto programu to takto provést nemù¾eme, proto¾e pou¾íváme møí¾ku a ne napø. otevøenou krajinu. Hodnoty fx a fy musí být pøesnì urèené. Pokud hráèova fx bude øeknìme 59 a poèítaè rozhodne posunout hráèe o dva pixely doprava, tak po stisku ¹ipky nahoru hráè nepùjde po &quot;¹edesátých pixelech&quot;, ale o kousek vedle.</p>

<p>Pøekl.: Nicménì i na¹e metoda má jeden velký error - okno nemù¾e v èekacích cyklech zpracovávat ¾ádné zprávy. Øeknìme, ¾e bude (ponìkud pøe¾enu) èasové zpo¾dìní 5 sekund. Okno není aktivní a u¾ivateli pøipadá, ¾e v programu nastala fatální chyba. Pokusí se ho ukonèit, ale i to se mu podaøí a¾ za tìchto pìt sekund. A pokud se bude zpomalovací kód volat èastìji (napø. po ka¾dém pøekreslení)... chápete? I u nás je tento problém trochu znatelný. Pokud se pokou¹íte zatoèit do urèité linky, nìkdy se strefíte a¾ na nìkolikátý pokus - program nezareaguje vèas. Proè vlastnì vzniklo vícevláknové programování? Aby odstranilo zdánlivì &quot;spadnuté programy&quot; pøi nároèných a dlouho trvajících výpoètech. Já osobnì, bych se takovémuto èasování za ka¾dou cenu vyhnul.</p>

<p class="src3"><span class="kom">// Plýtvá cykly procesoru na rychlých systémech</span></p>
<p class="src3">while(TimerGetTime() &lt; start + float(steps[adjust] * 2.0f))</p>
<p class="src3">{</p>
<p class="src3">}</p>
<p></p>
<p class="src3">if (keys[VK_F1])</p>
<p class="src3">{</p>
<p class="src4">keys[VK_F1]=FALSE;</p>
<p class="src4">KillGLWindow();</p>
<p class="src4">fullscreen =! fullscreen;</p>
<p></p>
<p class="src4">if (!CreateGLWindow(&quot;NeHe's Line Tutorial&quot;,640,480,16,fullscreen))</p>
<p class="src4">{</p>
<p class="src5">return 0;</p>
<p class="src4">}</p>
<p class="src3">}</p>

<p>Pøejdeme k ovládání klávesnicí. Po stisku 'A' znegujeme promìnnou anti a tím oznámíme kódu pro kreslení, ¾e má nebo nemá pou¾ívat antialiasing.</p>

<p class="src3">if (keys['A'] &amp;&amp; !ap)<span class="kom">// Stisk A</span></p>
<p class="src3">{</p>
<p class="src4">ap = TRUE;<span class="kom">// Nastaví pøíznak</span></p>
<p class="src4">anti=!anti;<span class="kom">// Zapne/vypne antialiasing</span></p>
<p class="src3">}</p>
<p></p>
<p class="src3">if (!keys['A'])<span class="kom">// Uvolnìní A</span></p>
<p class="src3">{</p>
<p class="src4">ap=FALSE;<span class="kom">// Vypne pøíznak</span></p>
<p class="src3">}</p>

<p>Teï pohyb a logika nepøátel. Chtìl jsem udr¾et kód opravdu jednoduchý, tak¾e neèekejte ¾ádné zázraky. Pracuje tak, ¾e nepøátelé zjistí, kde je hráè a poté se vydají jeho smìrem (na pozici x, y). Mohou napøíklad vidìt, ¾e je v hracím poli nahoøe, ale v èase, kdy testovali pozici x, hráè u¾ mù¾e být díky fx úplnì nìkde jinde. Èastokrát se dostanou tam, kde byl o krok pøedtím. Nìkdy vypadají opravdu zmatenì.</p>

<p>Zaèneme uji¹tìním se, jestli u¾ není konec hry a jestli je okno aktivní. Pokud se napøíklad minimalizovalo, nepøátelé se nebudou na pozadí pohybovat.</p>

<p>Vytvoøíme cyklus, který i tentokrát prochází v¹echny nepøátele.</p>

<p class="src3">if (!gameover &amp;&amp; active)<span class="kom">// Není-li konec hry a okno je aktivní</span></p>
<p class="src3">{</p>
<p class="src4">for (loop1=0; loop1&lt;(stage*level); loop1++)<span class="kom">// Prochází v¹echny nepøátele</span></p>
<p class="src4">{</p>

<p>V pøípadì, ¾e bude x pozice nepøítele men¹í ne¾ x pozice hráèe a zároveò se také musí rovnat y*40 pozici y (jsme v prùseèíku vertikální a horizontální linky) posuneme nepøítele doprava. Analogickým zpùsobem implementujeme i pohyb doleva, nahoru a dolù.</p>

<p>Poznámka: po zmìnì pozic x a y nelze vidìt ¾ádný pohyb, proto¾e pøi vykreslování objekty umís»ujeme pomocí promìnných fx a fy. Zmìnou x a y jenom urèujeme po¾adovaný smìr pohybu.</p>

<p class="src5">if ((enemy[loop1].x &lt; player.x) &amp;&amp; (enemy[loop1].fy==enemy[loop1].y*40))</p>
<p class="src5">{</p>
<p class="src6">enemy[loop1].x++;<span class="kom">// Pøesun o políèko doprava</span></p>
<p class="src5">}</p>
<p></p>
<p class="src5">if ((enemy[loop1].x &gt; player.x) &amp;&amp; (enemy[loop1].fy==enemy[loop1].y*40))</p>
<p class="src5">{</p>
<p class="src6">enemy[loop1].x--;<span class="kom">// Pøesun o políèko doleva</span></p>
<p class="src5">}</p>
<p></p>
<p class="src5">if ((enemy[loop1].y &lt; player.y) &amp;&amp; (enemy[loop1].fx==enemy[loop1].x*60))</p>
<p class="src5">{</p>
<p class="src6">enemy[loop1].y++;<span class="kom">// Pøesun o políèko dolù</span></p>
<p class="src5">}</p>
<p></p>
<p class="src5">if ((enemy[loop1].y &gt; player.y) &amp;&amp; (enemy[loop1].fx==enemy[loop1].x*60))</p>
<p class="src5">{</p>
<p class="src6">enemy[loop1].y--;<span class="kom">// Pøesun o políèko nahoru</span></p>
<p class="src5">}</p>

<p>Následující kód provádí opravdový pohyb. Zjistíme, zda je promìnná delay vìt¹í ne¾ tøi mínus level. Pokud jsme v levelu jedna, program pojde cyklem dvakrát (3-1=2), pøedtím ne¾ se nepøítel opravdu pohne. V levelu tøi (nejvy¹¹í mo¾ný) se nepøátelé budou pohybovat stejnou rychlostí jako hráè - tedy bez zpo¾dìní. Také ovìøujeme, jestli se hourglas.fx nerovná dvìma. Tato promìnná oznaèuje hráèovo sebrání pøesýpacích hodin. V takém pøípadì nepøítelem nepohybujeme.</p>

<p>Pokud je zpo¾dìní vy¹¹í ne¾ tøi mínus level a hráè nesebral hodiny, pohneme nepøítelem úpravou promìnných fx a fy. Nejprve vynulujeme zpo¾dìní, tak¾e ho budeme moci znovu poèítat a potom opìt deklarujeme cyklus, který prochází v¹echy viditelné nepøátele.</p>

<p class="src5">if (delay &gt; (3-level) &amp;&amp; (hourglass.fx!=2))<span class="kom">// Hráè nesebral pøesýpací hodiny</span></p>
<p class="src5">{</p>
<p class="src6">delay=0;<span class="kom">// Reset delay na nulu</span></p>
<p></p>
<p class="src6">for (loop2=0; loop2&lt;(stage*level); loop2++)<span class="kom">// Prochází v¹echny nepøátele</span></p>
<p class="src6">{</p>

<p>Nepøítel se v¾dy pohybuje pomocí fx/fy smìrem k x/y. V prvním if zjistíme jestli je fx men¹í ne¾ x*60. V takovém pøípadì ho posuneme doprava o vzdálenost steps[adjust]. Také zmìníme jeho úhel natoèení, aby vznikl dojem rolování doprava.</p>

<p>Úplnì stejnì provedeme pohyby doleva, dolù a nahoru.</p>

<p class="src7">if (enemy[loop2].fx &lt; enemy[loop2].x*60)<span class="kom">// Fx je men¹í ne¾ x</span></p>
<p class="src7">{</p>
<p class="src8">enemy[loop2].fx+=steps[adjust];<span class="kom">// Zvý¹it fx</span></p>
<p class="src8">enemy[loop2].spin+=steps[adjust];<span class="kom">// Rotace ve smìru hodinových ruèièek</span></p>
<p class="src7">}</p>
<p></p>
<p class="src7">if (enemy[loop2].fx &gt; enemy[loop2].x*60)<span class="kom">// Fx je vìt¹í ne¾ x</span></p>
<p class="src7">{</p>
<p class="src8">enemy[loop2].fx-=steps[adjust];<span class="kom">// Sní¾it fx</span></p>
<p class="src8">enemy[loop2].spin-=steps[adjust];<span class="kom">// Rotace proti smìru hodinových ruèièek</span></p>
<p class="src7">}</p>
<p></p>
<p class="src7">if (enemy[loop2].fy &lt; enemy[loop2].y*40)<span class="kom">// Fy je men¹í ne¾ y</span></p>
<p class="src7">{</p>
<p class="src8">enemy[loop2].fy+=steps[adjust];<span class="kom">// Zvý¹it fy</span></p>
<p class="src8">enemy[loop2].spin+=steps[adjust];<span class="kom">// Rotace ve smìru hodinových ruèièek</span></p>
<p class="src7">}</p>
<p></p>
<p class="src7">if (enemy[loop2].fy &gt; enemy[loop2].y*40)<span class="kom">// Fy je vìt¹í ne¾ y</span></p>
<p class="src7">{</p>
<p class="src8">enemy[loop2].fy-=steps[adjust];<span class="kom">// Sní¾it fy</span></p>
<p class="src8">enemy[loop2].spin-=steps[adjust];<span class="kom">// Rotace proti smìru hodinových ruèièek</span></p>
<p class="src7">}</p>
<p class="src6">}</p>
<p class="src5">}</p>

<p>Pohyb tedy máme. nyní potøebujeme vyøe¹it náraz nepøátel do hráèe. V pøípadì, ¾e se obì fx i obì fy rovnají... hráè zemøe. Dekrementujeme ¾ivoty a v pøípadì jejich nulové hodnoty prohlásíme hru za skonèenou. Resetujeme v¹echny objekty a necháme zahrát úmrtní skladbu.</p>

<p>Zvuky jsou v na¹ich tutoriálech novinkou. rozhodl jsem se pou¾ít tu nejzákladnìj¹í dostupnou rutinu... PlaySound(). Pøedáváme jí tøi parametry. První urèuje cestu k souboru se zvukem. Druhý parametr pomocí nulového ukazatele ignorujeme. Tøetí parametr je flag stylu. Dva nejèastìji pou¾ívané jsou: SND_SYNC, který zastaví provádìní programu, dokud pøehrávání zvuku neskonèí. Druhá mo¾nost, SND_ASYNC, pøehrává zvuk nezávisle na bìhu programu. Dáme pøednost malièkému zpo¾dìní, tak¾e funkci pøedáme SND_SYNC.</p>

<p>Na zaèátku tutoriálu jsem zapomnìl na jednu vìc: Abychom mohli pou¾ívat funkci PlaySound(), potøebujeme inkludovat knihovnu WINMM.LIB (Windows Multimedia Library). Ve Visual C++ to lze provést v nabídce Project/Setting/Link.</p>

<p class="src5"><span class="kom">// Setkání nepøítele s hráèem</span></p>
<p class="src5">if ((enemy[loop1].fx==player.fx) &amp;&amp; (enemy[loop1].fy==player.fy))</p>
<p class="src5">{</p>
<p class="src6">lives--;<span class="kom">// Hráè ztrácí ¾ivot</span></p>
<p></p>
<p class="src6">if (lives==0)<span class="kom">// Nulový poèet ¾ivotù</span></p>
<p class="src6">{</p>
<p class="src7">gameover=TRUE;<span class="kom">// Konec hry</span></p>
<p class="src6">}</p>
<p></p>
<p class="src6">ResetObjects();<span class="kom">// Reset pozice hráèe a nepøátel</span></p>
<p></p>
<p class="src6">PlaySound(&quot;Data/Die.wav&quot;, NULL, SND_SYNC);<span class="kom">// Zahraje umíráèek</span></p>
<p class="src5">}</p>
<p class="src4">}</p>

<p>O¹etøíme stisk kurzorových kláves. Vyøe¹íme ¹ipku doprava, ostatní smìry jsou zcela analogické. Abychom nevypadli pryè z hracího pole musí být player.x men¹í ne¾ deset (¹íøka møí¾ky). Nechceme, aby mohl zmìnit smìr uprostøed pøesunu a tak kontrolujeme, zda se fx==player.x*60 a fy==player.y*40. Nastanou-li obì rovnosti, mù¾eme s urèitostí øíci, ¾e se nachází v prùseèíku rovnobì¾né se svislou linkou a tedy dokonèil svùj pohyb. Platí-li v¹echny podmínky, oznaèíme linku pod hráèem jako pøejetou a posuneme jej na následující pozici.</p>

<p class="src4">if (keys[VK_RIGHT] &amp;&amp; (player.x&lt;10) &amp;&amp; (player.fx==player.x*60) &amp;&amp; (player.fy==player.y*40))</p>
<p class="src4">{</p>
<p class="src5">hline[player.x][player.y]=TRUE;<span class="kom">// Oznaèení linky</span></p>
<p class="src5">player.x++;<span class="kom">// Doprava</span></p>
<p class="src4">}</p>
<p></p>
<p class="src4">if (keys[VK_LEFT] &amp;&amp; (player.x&gt;0) &amp;&amp; (player.fx==player.x*60) &amp;&amp; (player.fy==player.y*40))</p>
<p class="src4">{</p>
<p class="src5">hline[player.x][player.y]=TRUE;<span class="kom">// Oznaèení linky</span></p>
<p class="src5">player.x--;<span class="kom">// Doleva</span></p>
<p class="src4">}</p>
<p></p>
<p class="src4">if (keys[VK_DOWN] &amp;&amp; (player.y&lt;10) &amp;&amp; (player.fx==player.x*60) &amp;&amp; (player.fy==player.y*40))</p>
<p class="src4">{</p>
<p class="src5">vline[player.x][player.y]=TRUE;<span class="kom">// Oznaèení linky</span></p>
<p class="src5">player.y++;<span class="kom">// Dolù</span></p>
<p class="src4">}</p>
<p></p>
<p class="src4">if (keys[VK_UP] &amp;&amp; (player.y&gt;0) &amp;&amp; (player.fx==player.x*60) &amp;&amp; (player.fy==player.y*40))</p>
<p class="src4">{</p>
<p class="src5">vline[player.x][player.y]=TRUE;<span class="kom">// Oznaèení linky</span></p>
<p class="src5">player.y--;<span class="kom">// Nahoru</span></p>
<p class="src4">}</p>

<p>Hráèe máme, dá se øíci, pøesunutého - ale pouze v programu! Je viditelný stále na stejném místì, proto¾e ho vykreslujeme pomocí fx a fy. Provnáme, polohu fx vzhledem k x a pokud se nerovnají, sní¾íme vzdálenost mezinimi o pøesnì daný úsek. Po nìkolika pøekresleních se zaènou obì hodnoty rovnat, co¾ znaèí, ¾e dokonèil pohyb a nyní se nachází v prùseèíku linek. Pøi následném stisku klávesy mù¾eme zaèít hráèe znovu posunovat (viz. kód vý¹e).</p>

<p class="src4">if (player.fx&lt;player.x*60)<span class="kom">// Fx je men¹í ne¾ x</span></p>
<p class="src4">{</p>
<p class="src5">player.fx+=steps[adjust];<span class="kom">// Zvìt¹í fx</span></p>
<p class="src4">}</p>
<p></p>
<p class="src4">if (player.fx&gt;player.x*60)<span class="kom">// Fx je vìt¹í ne¾ x</span></p>
<p class="src4">{</p>
<p class="src5">player.fx-=steps[adjust];<span class="kom">// Zmen¹í fx</span></p>
<p class="src4">}</p>
<p></p>
<p class="src4">if (player.fy&lt;player.y*40)<span class="kom">// Fy je men¹í ne¾ y</span></p>
<p class="src4">{</p>
<p class="src5">player.fy+=steps[adjust];<span class="kom">// Zvìt¹í fy</span></p>
<p class="src4">}</p>
<p></p>
<p class="src4">if (player.fy&gt;player.y*40)<span class="kom">// Fy je vìt¹í ne¾ y</span></p>
<p class="src4">{</p>
<p class="src5">player.fy-=steps[adjust];<span class="kom">// Zmen¹í fy</span></p>
<p class="src4">}</p>
<p class="src3">}</p>

<p>Nastane-li konec hry, projde program vìtví else. V ní je pouze test stisku mezerníku, který znovu spustí hru. Nastavíme filled na TRUE a díky tomu si program bude myslet, ¾e je møí¾ka kompletnì vyplnìná - resetuje se pozice hráèe i nepøátel. Abychom byli pøesní, program si vlastnì myslí, ¾e jsme dokonèili level, a proto inkrementuje do stage pøiøazenou nulu na jedna. Pøesnì tohle chceme. ®ivot vrátíme na poèáteèní hodnotu.</p>

<p class="src3">else<span class="kom">// Jinak (if (!gameover && active))</span></p>
<p class="src3">{</p>
<p class="src4">if (keys[' '])<span class="kom">// Stisknutý mezerník</span></p>
<p class="src4">{</p>
<p class="src5">gameover = FALSE;<span class="kom">// Konec hry</span></p>
<p class="src5">filled = TRUE;<span class="kom">// Møí¾ka vyplnìná</span></p>
<p></p>
<p class="src5">level = 1;<span class="kom">// Level</span></p>
<p class="src5">level2 = 1;<span class="kom">// Zobrazovaný level</span></p>
<p class="src5">stage = 0;<span class="kom">// Obtí¾nost hry</span></p>
<p></p>
<p class="src5">lives = 5;<span class="kom">// Poèet ¾ivotù</span></p>
<p class="src4">}</p>
<p class="src3">}</p>

<p>Následující èást testuje, zda je møí¾ka kompletnì vyplnìná. Filled mù¾e být nastaveno na TRUE celkem dvìma zpùsoby. Buï je møí¾ka úplnì vyplnìná, nebo skonèila hra (zabitím hráèe; nula ¾ivotù) a u¾ivatel stiksl mezerník, aby ji restartoval.</p>

<p class="src3">if (filled)<span class="kom">// Vyplnìná møí¾ka?</span></p>
<p class="src3">{</p>

<p>A» u¾ to zpùsobil kterýkoli pøípad je nám to celkem jedno. V¾dy zahrajeme zvuk znaèící ukonèení levelu. U¾ jsme jednou vysvìtloval, jak PlaySound() pracuje. Pøedáním SND_SYNC vytvoøíme èasové zpo¾dìní, kdy program èeká a¾ zvuk dohraje.</p>

<p class="src4">PlaySound(&quot;Data/Complete.wav&quot;, NULL, SND_SYNC);<span class="kom">// Zvuk ukonèení levelu</span></p>

<p>Potom inkrementujeme stage a zjistíme, jestli není vìt¹í ne¾ tøi. Pokud ano, vrátíme ho na jedno, zvìt¹íme vnitøní i zobrazovaný level o jednièku.</p>

<p class="src4">stage++;<span class="kom">// Inkrementace obtí¾nosti</span></p>
<p></p>
<p class="src4">if (stage &gt; 3)<span class="kom">// Je vìt¹í ne¾ tøi?</span></p>
<p class="src4">{</p>
<p class="src5">stage=1;<span class="kom">// Reset na jednièku</span></p>
<p class="src5">level++;<span class="kom">// Zvìt¹í level</span></p>
<p class="src5">level2++;<span class="kom">// Zvìt¹í zobrazovaný level</span></p>

<p>Pokud bude vnitøní level vìt¹í ne¾ tøi, vrátíme ho zpìt na trojku a pøidáme hráèi jeden ¾ivot, ale pouze do maximálních pìti. Více ¾ivý nikdy nebude.</p>

<p class="src5">if (level&gt;3)<span class="kom">// Je level vìt¹í ne¾ tøi?</span></p>
<p class="src5">{</p>
<p class="src6">level=3;<span class="kom">// Vrátí ho zpátky na tøi</span></p>
<p class="src6">lives++;<span class="kom">// ®ivot navíc</span></p>
<p></p>
<p class="src6">if (lives &gt; 5)<span class="kom">// Má víc ¾ivotù ne¾ pìt?</span></p>
<p class="src6">{</p>
<p class="src7">lives = 5;<span class="kom">// Maximální poèet ¾ivotù pìt</span></p>
<p class="src6">}</p>
<p class="src5">} </p>
<p class="src4">}</p>

<p>Resetujeme v¹echny objekty ve høe (høáè, nepøátelé) a vynulujeme flag projetí v¹ech linek na FALSE. Pokud bychom to neudìlali, dal¹í level by byl pøedèasnì ukonèen - program by opìt skoèil do tohoto kódu. Mimochodem, je úplnì stejný jako kód pro vykrelsování møí¾ky.</p>

<p class="src4">ResetObjects();<span class="kom">// Reset pozice hráèe a nepøátel</span></p>
<p></p>
<p class="src4">for (loop1=0; loop1&lt;11; loop1++)<span class="kom">// Cyklus skrz x koordináty møí¾ky</span></p>
<p class="src4">{</p>
<p class="src5">for (loop2=0; loop2&lt;11; loop2++)<span class="kom">// Cyklus skrz y koordináty møí¾ky</span></p>
<p class="src5">{</p>
<p class="src6">if (loop1 &lt; 10)<span class="kom">// X musí být men¹í ne¾ deset</span></p>
<p class="src6">{</p>
<p class="src7">hline[loop1][loop2] = FALSE;<span class="kom">// Nulování</span></p>
<p class="src6">}</p>
<p></p>
<p class="src6">if (loop2 &lt; 10)<span class="kom">// Y musí být men¹í ne¾ deset</span></p>
<p class="src6">{</p>
<p class="src7">vline[loop1][loop2] = FALSE;<span class="kom">// Nulování</span></p>
<p class="src6">}</p>
<p class="src5">}</p>
<p class="src4">}</p>
<p class="src3">}</p>

<p>Pokusíme se umplementovat hráèovo sebrání pøesýpacích hodin. ®e si musí polohy odpovídat je, myslím si, jasné. Nicménì pøidáváme je¹tì podmínku hourgalss.fx==1. Nejedná se o ¾ádnou polohu. Fx pou¾íváme jako indikátor toh, ¾e jsou zobrazené na monitoru.</p>

<p class="src3"><span class="kom">// Hráè sebral pøesýpací hodiny</span></p>
<p class="src3">if ((player.fx==hourglass.x*60) &amp;&amp; (player.fy==hourglass.y*40) &amp;&amp; (hourglass.fx==1))</p>
<p class="src3">{</p>

<p>Necháme zahrát zvuk zmrazení. Aby zvuk znìl na pozadí, pou¾íváme SND_ASYNC. Díky OR-ování se symbolickou konstantou SND_LOOP docílíme toho, ¾e se po dokonèení pøehrávání zvuku sám znovu spustí. Zastavit ho mù¾eme buï po¾adavkem na zastvení, nebo pøehráním jiného zvuku.</p>

<p>Aby hodiny nebyly dále zobrazené nastavíme fx na dva. Také pøiøadíme do fy nulu. Fy je nìco jako èítaè, který inkrementujeme do urèité hodnoty, po jejím¾ pøeteèení zmìníme hodnotu fx.</p>

<p class="src4">PlaySound(&quot;Data/freeze.wav&quot;, NULL, SND_ASYNC | SND_LOOP);<span class="kom">// Zvuk zmrazení</span></p>
<p></p>
<p class="src4">hourglass.fx=2;<span class="kom">// Skryje hodiny</span></p>
<p class="src4">hourglass.fy=0;<span class="kom">// Nuluje èítaè</span></p>
<p class="src3">}</p>

<p>Následující kód zaji¹»uje narùstání rotace hráèe o polovinu ni¾¹í rychlostí ne¾ má hra. V pøípadì, ¾e bude hodnota vy¹¹í ne¾ 360° odeèteme 360. Tím zajistíme, aby nebyla moc vysoká.</p>

<p class="src3">player.spin += 0.5f * steps[adjust];<span class="kom">// Rotace hráèe</span></p>
<p></p>
<p class="src3">if (player.spin&gt;360.0f)<span class="kom">// Úhel je vìt¹í ne¾ 360°</span></p>
<p class="src3">{</p>
<p class="src4">player.spin -= 360;<span class="kom">// Odeète 360</span></p>
<p class="src3">}</p>

<p>Aby se hodiny toèily opaèným smìrem ne¾ hráè, namísto zvy¹ování, úhel sni¾ujeme. Rychlost je ètvrtinová oproti rychlosti hry. Opìt o¹etøíme podteèení promìnné.</p>

<p class="src3">hourglass.spin-=0.25f*steps[adjust];<span class="kom">// Rotace pøesýpacích hodin</span></p>
<p></p>
<p class="src3">if (hourglass.spin &lt; 0.0f)<span class="kom">// Úhel je men¹í ne¾ 0°</span></p>
<p class="src3">{</p>
<p class="src4">hourglass.spin += 360.0f;<span class="kom">// Pøiète 360</span></p>
<p class="src3">}</p>

<p>Zvìt¹íme hodnotu èítaèe pøesýpacích hodin, o které jsme mluvili pøed chvílí. Opìt podle rychlosti hry. Dále zjistíme, jestli se hourglass.fx rovná nule (nejsou zobrazené) a zároveò jelsti je èítaè vìt¹í ne¾ 6000 dìleno level. V takovém pøípadì pøehrajeme zvuk zobrazení, vygenerujeme novou pozici a pøes fx=1 hodiny zobrazíme. Vynulujeme èítaè, aby mohl poèítat znovu.</p>

<p class="src3">hourglass.fy+=steps[adjust];<span class="kom">// Zvìt¹ení hodnoty èítaèe pøesýpacích hodin</span></p>
<p></p>
<p class="src3">if ((hourglass.fx==0) &amp;&amp; (hourglass.fy &gt; 6000/level))<span class="kom">// Hodiny jsou skryté a pøetekl èítaè</span></p>
<p class="src3">{</p>
<p class="src4">PlaySound(&quot;Data/hourglass.wav&quot;, NULL, SND_ASYNC);<span class="kom">// Zvuk zobrazení hodin</span></p>
<p></p>
<p class="src4">hourglass.x = rand()%10+1;<span class="kom">// Náhodná pozice</span></p>
<p class="src4">hourglass.y = rand()%11;<span class="kom">// Náhodná pozice</span></p>
<p></p>
<p class="src4">hourglass.fx = 1;<span class="kom">// Zobrazení hodin</span></p>
<p class="src4">hourglass.fy = 0;<span class="kom">// Nulování èítaèe</span></p>
<p class="src3">}</p>

<p>Pøekl-li èítaè v dobì, kdy jsou hodiny viditelné (fx==1), schováme je a opìt vynulujeme èítaè.</p>

<p class="src3">if ((hourglass.fx==1) &amp;&amp; (hourglass.fy&gt;6000/level))<span class="kom">// Hodiny jsou zobrazené a pøetekl èítaè</span></p>
<p class="src3">{</p>
<p class="src4">hourglass.fx = 0;<span class="kom">// Skrýt hodiny</span></p>
<p class="src4">hourglass.fy = 0;<span class="kom">// Nulování èítaèe</span></p>
<p class="src3">}</p>

<p>Pøi hráèovì sebrání hodin jsme zmrazili v¹echny nepøátele. Nyní je rozmrazíme. Fx==2 indikuje, ¾e byly hodiny sebrány. Fy porovnáváme s vypoètenou hodnotou. Jsou-li obì podmínyk pravdivé, vypneme zvuk, který zní ve smyèce na pozadí a to tak, ¾e pøehrajeme nulový zvuk. Zneviditelníme hodiny a vynulujeme jejich èítaè.</p>

<p class="src3">if ((hourglass.fx==2) &amp;&amp; (hourglass.fy&gt;500+(500*level)))<span class="kom">// Nepøátelé zmrazení a pøetekl èítaè</span></p>
<p class="src3">{</p>
<p class="src4">PlaySound(NULL, NULL, 0);<span class="kom">// Vypne zvuk zmrazení</span></p>
<p></p>
<p class="src4">hourglass.fx = 0;<span class="kom">// Skrýt hodiny</span></p>
<p class="src4">hourglass.fy = 0;<span class="kom">// Nulování èítaèe</span></p>
<p class="src3">}</p>

<p>Na samém konci hlavní smyèky programu inkrementujeme promìnnou delay. To je, myslím si, v¹e.</p>

<p class="src3">delay++;<span class="kom">// Inkrementuje èítaè zpo¾dìní nepøátel</span></p>
<p class="src2">}</p>
<p class="src1">}</p>
<p></p>
<p class="src1">KillGLWindow();<span class="kom">// Zru¹í okno</span></p>
<p class="src1">return (msg.wParam);<span class="kom">// Ukonèí program</span></p>
<p class="src0">}</p>

<p>Psaním tohoto tutoriálu jsem strávil spoustu èasu. Zaèínal jako zcela jednoduchý tutoriál o linkách, který se úplnì neèekanì rozvinul v men¹í hru. Doufejme, ¾e budete moci ve svých programech vyu¾ít v¹e, co jste se zde nauèili. Vím, ¾e se spousta z vás ptala po høe s kostièkami a políèky. Nemohli jste dostat více kostièkovatìj¹í a více políèkovatìj¹í hru ne¾ je tato. Aèkoli lekce nevysvìtluje mnoho nových vìcí o OpenGL, myslím si, ¾e èasování a zvuky jsou také dùle¾ité - zvlá¹» ve hrách. Co je¹tì napsat? Asi nic...</p>

<p class="autor">napsal: Jeff Molofee - NeHe <span class="transform_email">&lt;nehe (zavináè) connect.ab.ca&gt;</span><br />
pøelo¾il: Michal Turek - Woq <span class="transform_email">&lt;WOQ (zavináè) seznam.cz&gt;</span></p>

<h3 class="zdroj_kody_nadpis">Zdrojové kódy</h3>

<ul class="zdroj_kody">
<li><a href="http://nehe.gamedev.net/data/lessons/vc/lesson21.zip">Visual C++</a> kód této lekce.</li>
<li><a href="http://nehe.gamedev.net/data/lessons/bcb6/lesson21_bcb6.zip">Borland C++ Builder 6</a> kód této lekce. ( <a href="mailto:christian@tugzip.com">Christian Kindahl</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/cwarrior/lesson21.zip">Code Warrior 5.3</a> kód této lekce. ( <a href="mailto:DelusionalBeing@hotmail.com">Scott Lupton</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/delphi/lesson21.zip">Delphi</a> kód této lekce. ( <a href="mailto:marca@stack.nl">Marc Aarts</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/devc/lesson21.zip">Dev C++</a> kód této lekce. ( <a href="mailto:danprogram@hotmail.com">Dan</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/euphoria/lesson21.zip">Euphoria</a> kód této lekce. ( <a href="mailto:1evan@sbcglobal.net">Evan Marshall</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/irix/lesson21.zip">Irix</a> kód této lekce. ( <a href="mailto:christop@fhw.gr">Dimi</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/java/lesson21.zip">Java</a> kód této lekce. ( <a href="mailto:jeff@consunet.com.au">Jeff Kirby</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/lccwin32/lccwin32_lesson21.zip">LCC Win32</a> kód této lekce. ( <a href="mailto:rwishlaw@shaw.ca">Robert Wishlaw</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/linux/lesson21.tar.gz">Linux</a> kód této lekce. ( <a href="mailto:marius@hot.ee">Marius Andra</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/linuxglx/lesson21.tar.gz">Linux/GLX</a> kód této lekce. ( <a href="mailto:miqster@gmx.net">Mihael Vrbanec</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/linuxsdl/lesson21.tar.gz">Linux/SDL</a> kód této lekce. ( <a href="mailto:leggett@eecs.tulane.edu">Ti Leggett</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/mac/lesson21.sit">Mac OS</a> kód této lekce. ( <a href="mailto:asp@usc.edu">Anthony Parker</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/macosxcocoa/lesson21.zip">Mac OS X/Cocoa</a> kód této lekce. ( <a href="mailto:blb@pobox.com">Bryan Blackburn</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/masm/lesson21.zip">MASM</a> kód této lekce. ( <a href="mailto:chris.j84@free.fr">Christophe</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/openil/lesson21.zip">Visual C++ / OpenIL</a> kód této lekce. ( <a href="mailto:doomwiz@ticnet.com">Denton Woods</a> )</li>
<li><a href="http://nehe.gamedev.net/data/lessons/vs_net/lesson21.zip">Visual Studio .NET</a> kód této lekce. ( <a href="mailto:ultimatezeus@hotmail.com">Grant James</a> )</li>
</ul>

<div class="okolo_img"><img src="images/nehe_tut/tut_21_big.jpg" class="nehe_velky" alt="Lekce 21" /></div>
<p class="okolni_lekce"><a href="tut_20.php">&lt;&lt;&lt; Lekce 20</a> | <a href="tut_22.php">Lekce 22 &gt;&gt;&gt;</a></p>


<div class="netisk">
<h3 class="d_nadpis">Diskuze ke èlánku</h3>

<form action="d_view.php" method="post" class="d_o_obsah">

<div class="d_o_zprava">
<div class="d_o_jmeno">myn</div>
<div class="d_o_datumcas">05.12.2004 - 10:31:18</div>
<div>
<input type="checkbox" name="id_0" id="id_0" value="1" />
<span class="d_o_nadpis" style="margin-left: 0px;"><a href="d_view.php?f=tut_21.php&j=0">chybí knihovny?</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">Woq</div>
<div class="d_o_datumcas">08.12.2004 - 14:55:35</div>
<div>
<input type="checkbox" name="id_1" id="id_1" value="1" />
<span class="d_o_nadpis" style="margin-left: 20px;"><a href="d_view.php?f=tut_21.php&j=1">Re: chybí knihovny?</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">myn</div>
<div class="d_o_datumcas">09.12.2004 - 08:45:47</div>
<div>
<input type="checkbox" name="id_2" id="id_2" value="1" />
<span class="d_o_nadpis" style="margin-left: 40px;"><a href="d_view.php?f=tut_21.php&j=2">Re: chybí knihovny?</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">Speedy</div>
<div class="d_o_datumcas">23.12.2004 - 15:37:54</div>
<div>
<input type="checkbox" name="id_3" id="id_3" value="1" />
<span class="d_o_nadpis" style="margin-left: 60px;"><a href="d_view.php?f=tut_21.php&j=3">Re: chybí knihovny?</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">ssil</div>
<div class="d_o_datumcas">10.08.2005 - 20:12:03</div>
<div>
<input type="checkbox" name="id_4" id="id_4" value="1" />
<span class="d_o_nadpis" style="margin-left: 0px;"><a href="d_view.php?f=tut_21.php&j=4">Chyba pøi kompilaci</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">Woq</div>
<div class="d_o_datumcas">11.08.2005 - 19:16:09</div>
<div>
<input type="checkbox" name="id_5" id="id_5" value="1" />
<span class="d_o_nadpis" style="margin-left: 20px;"><a href="d_view.php?f=tut_21.php&j=5">Re: Chyba pøi kompilaci</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">F</div>
<div class="d_o_datumcas">17.11.2006 - 21:19:33</div>
<div>
<input type="checkbox" name="id_6" id="id_6" value="1" />
<span class="d_o_nadpis" style="margin-left: 0px;"><a href="d_view.php?f=tut_21.php&j=6">Hudba</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">eraser17</div>
<div class="d_o_datumcas">26.02.2007 - 21:18:23</div>
<div>
<input type="checkbox" name="id_7" id="id_7" value="1" />
<span class="d_o_nadpis" style="margin-left: 20px;"><a href="d_view.php?f=tut_21.php&j=7">Re: Hudba</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">Michal Turek</div>
<div class="d_o_datumcas">26.02.2007 - 22:13:35</div>
<div>
<input type="checkbox" name="id_8" id="id_8" value="1" />
<span class="d_o_nadpis" style="margin-left: 40px;"><a href="d_view.php?f=tut_21.php&j=8">Re: Hudba</a></span>
</div>
</div>

<div class="d_o_zprava">
<div class="d_o_jmeno">eraser17</div>
<div class="d_o_datumcas">27.02.2007 - 20:58:00</div>
<div>
<input type="checkbox" name="id_9" id="id_9" value="1" />
<span class="d_o_nadpis" style="margin-left: 60px;"><a href="d_view.php?f=tut_21.php&j=9">Re: Hudba</a></span>
</div>
</div>

<div class="okolo_img" style="margin-top: 20px;">
<input type="submit" name="zobrazit_vybrane" id="zobrazit_vybrane" value="Zobrazit vybrané" class="tlacitko" />
<input type="submit" name="zobrazit_vse" id="zobrazit_vse" value="Zobrazit v¹e" class="tlacitko" />
<input type="submit" name="vlozit_novy" id="vlozit_novy" value="Vlo¾it nový" class="tlacitko" />
<input type="hidden" name="f" id="f" value="tut_21.php" />
</div>
</form>
</div>
<!-- Informace o webu -->
<center><div id="informace">
<img src="images/my/woq.gif" width="60" height="60" align="left" alt="Woq logo" />
<div style="margin-left: 70px">
<div><strong>CZ NeHe OpenGL, v¹e o programování 3D grafiky</strong></div>
<div>Copyright &copy; 2002-2007 Michal Turek <span class="transform_email">&lt;WOQ (zavináè) seznam.cz&gt;</span></div>
<div style="margin-top: 5px">Komerèní publikování v ti¹tìné, elektronické nebo jiné podobì je bez výslovného souhlasu zakázáno. Redistribuce pro výukové úèely nebo osobní pou¾ití je v¹ak povolena.</div>
</div>
</div></center>
<!-- Informace o webu (konec) -->

</div>
<!-- Vlastní obsah stránky (konec) -->

<script src="http://c1.navrcholu.cz/code?site=56575;t=b14"
type="text/javascript"></script><noscript><div><a
href="http://navrcholu.cz/"><img
src="http://c1.navrcholu.cz/hit?site=56575;t=b14;ref=;jss=0"
width="14" height="14" alt="NAVRCHOLU.cz"
style="border:none" /></a></div></noscript>

</body>
</html>
