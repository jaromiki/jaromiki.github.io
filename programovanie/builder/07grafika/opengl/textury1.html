<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1250">
    <meta name="Content-language" content="sk"> 
    <LINK href="../../css/style.css" type="text/css" rel=stylesheet>
</head>

<body>
<dl>
<dt>Pojem textura
<dd>Textúrovanie (resp. presnejšie nanášanie textúr ) sa oznaèuje princíp zafarbenie povrchu zobrazovacích telies rôznymi obrazcami. 
Dôleité pritom je, e sa nijako nemení geometrické vlastnosti telies, len sa inak zobrazuje ich povrch. Obrazce, ktoré sa na povrch telies nanášajú, 
sa nazıvajú textúry (textures). Tieto textúry sú väèšinou predstavované plošnımi obrázky (dvojdimenzionálne textúry), niektoré grafické systémy však 
podporujú aj vykres¾ovanie jednorozmernıch a dokonca trojrozmernıch (objemu) textúr.
<br>Obrazce pre textúry sa môu vytvára nieko¾kımi spôsobmi. Buï je moné poui klasické rastrové obrázky (vzniknuté napríklad nama¾uje, 
vyfotením alebo naskenovaním), alebo sa textúra môe vytvára pomocou rôznych algoritmov zaloenıch väèšinou na fraktálne technikách - tımto spôsobom vznikajú 
takzvané procedurálne textúry . Procedurálne textúry mono poui buï pre vıpoèet rastrovıch obrázkov pred vlastnım vykres¾ovaním 
(po vıpoète obrázku sa táto textúra chová ako kadı inı rastrovı obrázok so všetkımi vıhodami i nevıhodami), alebo sa môe vıpoèet textúr vykonáva 
v reálnom èase a pri vykres¾ovaní, prièom sa parametre vıpoètu textúry nastaví pod¾a aktuálnej ve¾kosti a orientácie plôšky, na ktorú sa textúra nanáša. 
Túto druhú monos však OpenGL priamo nepodporuje, vıpoèet procedurálnych textúr je teda nutné vykonáva "ruène". 
<br>V ïalšom texte sa budeme najviac zaobera textúrami reprezentovanımi rastrovımi obrázky, nezávisle na tom, akım spôsobom vznikli. 
Aj keï reè bude prevane o dvojdimenzionálnych textúrach (teda bitmapách a pixmapách ), väèšina tu popisovanıch vlastností sa vzahuje aj na jednorozmerné 
a trojrozmerné textúry. Prípadné vınimky a odlišnosti si samozrejme postupne popíšeme. 
<img src="obr/tehly.gif" width="230" height="230" border="0" alt="" align="left" vspace="10" hspace="10">
Na obrázku je ukázaná dvojdimenzionálne, "ruène" nakreslená textúra v grafickom editore. Rastrové textúry budeme v demonštraènıch príkladoch vyrába 
buï programovo (rôzne šachovnice a pod), alebo ich budeme naèíta z externıch súborov (obrázkov typu bmp).
<br>Podobne, ako je bitmapa èi pixmap zloená zo základnıch rastrovıch elementov ( pixelov ), je textúra zloená z Texelov. 
Pixel a texel majú rovnaké vlastnosti a podobnı èi dokonca ekvivalentnı spôsob uloenia v pamäti. V ïalšom texte sa však budeme obidva pojmy navzájom odde¾ova, 
tj pixel je element zobrazená na obrazovke, kdeto texel je rastrovı element (väèšinou) dvojrozmerné textúry. 
Textúrovanie potom spoèíva v nanášaní Texel na opísaná povrch.
<br>Textúru mono poui vo všetkıch prípadoch, keï je nutné vykres¾ova telesá s opakujúcou sa štruktúrov. Typickım príkladom je tehlová stena, 
ktorá je v reálnom svete zloená z jednotlivıch tehál spojenıch maltou. Pri modelovaní tejto múru síce môeme kadú tehlu reprezentova napríklad kvádrom 
s vhodne zvolenou farbou, ale v prípade vykres¾ovanie ve¾kıch múrov by poèet vykreslovanıch telies rástol príliš rıchlo, take by sa zbytoène zaberala pamäí, 
a zbytoène by sa zvyšoval nárok na vıpoètovı èas. Ešte horšia situácia by nastala napríklad u koberca, kde by bolo nutné vytvára všetky farebné vlákna a pod.
V tıchto prípadoch je moné stenu alebo koberec reprezentova jednou plochou (zloenú napríklad z dvoch trojuholníkov alebo jedného štvoruholníka) 
a na túto plochu potom nanies predom vytvorenı rastrovı obrázok, ale vykreslenie bude na dnešnıch poèítaèoch dostatoène rıchle a v prípade dostatoènej 
ve¾kosti (rozlíšenie) textúry aj kvalitné.
<br>Textúry sa tie niekedy pouívajú trochu inım spôsobom pre vytváranie a následné vykreslenie rôznych zloitıch modelov, napríklad stromov. 
Buï je moné strom namodelova ako teleso obsahujúce a nieko¾ko tisíc polygónov, alebo je moné vytvori dvojrozmernı obrázok stromu z nieko¾kıch smerov 
a strom vykresli ako nieko¾ko vzájomne sa pretínajúcich plôch s aplikovanou kontúrou stromu - viï tretí obrázok. 
V tomto prípade však textúra musí by v niektorıch miestach prieh¾adná, èo však pri vykres¾ovaní nepredstavuje väèší problém. 
Táto technika sa nazıva billboarding , pretoe sa vychádza z podobnosti s klasickımi billboardami.
<h4>Vıhody pouitia rastrovıch textúr</h4>
Pouitie rastrovıch textúr so sebou prináša samozrejme svoje vıhody aj nevıhody. Ako sme si u povedali, pouíva sa technika textúrovanie ako urèitá náhrada 
pri zobrazovaní zloitıch povrchov telies (múr, omietka, drevo, kameò), kedy sa tento všeobecne nehomogénne povrch nahradí plôškou s nanesenou textúrou. 
Záleí na vhodnej vo¾be textúry, ve¾kosti objektu a nasvietenie celej scény, èi táto náhrada bude dostatoèné alebo èi uívate¾ uvidí vizuálne chyby v scéne.
<br>Ve¾kou vıhodou rastrovıch textúr je ich ¾ahká implementácia vo vykreslovacím reazci. Jednoduché grafické akcelerátory riešili textúrovanie tak, 
e sa do ich vykreslovacího reazca pridala vyrovnávacia pamä pre textúry a nieko¾ko interpolátor, pomocou ktorıch sa riešil prístup do textúrovacích pamäti. 
Dnešné grafické akcelerátory idú ove¾a ïalej: textúry je moné komprimova, sú podporované mipmap (textúry vo viacerıch rozlíšeniach), 
antialiasing, multitextury apod textúrovacích jednotka však stále patrí k tım èastiam vizuálneho systému, ktorá má ve¾mi dobrı pomer zloitos / vizuálny efekt.
<br>Ïalšou vıhodou textúrovanie je, e pokia¾ u textúr pouijeme prieh¾adnos (nazıvanú aj alfa kanál ), je moné vizuálne zmeni geometriu predmetov, 
pretoe sa predmet môe na niektorıch miestach javi ako deravı. Ukáka tejto techniky je zobrazená na prvom obrázku. Poznamenajme, e pri pouití 
transparentnosti potrebné programovo zotrieïi prieh¾adné alebo poloprieh¾adné plôšky, pretoe by v tomto prípade Z-buffer (pamä håbky) 
nepracoval korektne - aj prieh¾adné texely by sa "vykreslili" a poškodili tak informáciu o håbke fragmentu uloenú v Z-bufferu .

<h4>Nevıhody rastrovıch textúr</h4>

Prvou vánou nevıhodou tıchto textúr je ich vopred dané rozlíšenie, teda poèet pixelov, z ktorıch sa textúra skladá. Pri vo¾be rozlíšenie textúry sa vdy musí 
zvoli kompromis medzi dvoma extrémami. Prvım extrémom je vo¾ba textúry s malım rozlíšením, èo však pri zobrazovaní vedie k vidite¾nım chybám 
(spomeòme napríklad staršie hry typu Wolfenstein alebo Doom, ktoré pouívali pomerne hrubé textúry s rozlíšením 64x64 pixelov; u tıchto hier sa samozrejme 
ani OpenGL ani grafická akcelerácia nepouívala). Druhım extrémom je vo¾ba textúry s neúmerne ve¾kım rozlíšením, kedy sa naopak plytvá pamäou na 
grafickom akcelerátora.
<br>Druhá nevıhoda spoèíva vo fakte, e ak zobrazujeme textúru na obrazovke a pouije sa zväèšenie alebo zmenšenie poètu zobrazovanıch pixelov 
(èo sa stáva pri textúrovanie takmer vdy, pretoe sa na textúrovanı povrch pozeráme z rôznych smerov a vzdialeností), dochádza k aliasu 
(zjednodušene povedané tvorbe moaré), ktorı nie je moné principiálne odstráni, mono len zmierni jeho vizuálnu podobu. Preto sa pouívajú rôzne metódy 
odstránenia aliasu (tj metódy antialiasing ), ktoré však komplikujú zobrazovacie reazec a všeobecne vedú k spomaleniu vykres¾ovanie.
<br>Tretia nevıhodou je skutoènos, e textúry zaberajú pomerne ve¾ké mnostvo pamäte. Ak je v pamäti grafického akcelerátora dostatoèné miesto, 
je moné textúry nahra do tejto pamäte a vykres¾ovanie tak nieko¾konásobne urıchli. Ak je však v tejto pamäti miesta málo 
(oblas pamäti grafického akcelerátora je mimo iného obsadená všetkımi farbovım buffery, pamäou håbky, stencil bufferom apod), 
musí sa textúry pri vykres¾ovanie nahráva z hlavnej pamäte poèítaèa, èo zaauje zbernicu alebo port a spoma¾uje vykres¾ovanie. 
Túto nevıhodu èiastoène rieši rôzne metódy komprimácie textúr.

<br>Textúry môu by:
	<ul><li>jednorozmerné - sem patria farebné prechody (vytvárame zadávaním rôznych farieb do vrcholov plôch)
		<li>dvojrozmerné - sem patria zosnímané obrázky a tie vypoèítané textury (fraktály)
			<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(majú šírku a vıšku)
		<li>trojrozmerné
			<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(majú šírku, vıšku a håbku)
	</ul>
	Teraz si ukáeme ako vytvori farebnı povrch pomocou manuálneho priradenia farieb kadému pixelu - vytvoríme farebnú "štruktúru",
	ktorú budeme potom na plochu "naahova". Vzorku mono vytvori zadávaním hopdnoty kadého pixla, alebo zobratím nejakého obrázka.
	Obmedzenie na ktoré treba dáva pozor je e rozmery vzorky musia by 
	mocniny 2. (napr. 32, 64, 128, 256).
<br>Aby sme mohli pracova s textúrami je nutné:
<ul><li>Povoli prácu s textúrami - napr. príkaz glEnable(GL_TEXTURE_2D);
	<li>Vytvori štruktúru, kde bude povrch zadanı v texeloch - môme vytvori manuálne zadaním vlastnosti texelu alebo naèítaním obrázka.
	<li>Vytvori prepojenie OpenGl na našu vytvorenú textúru - príkaz glTexImage2D()
	<li>Nastavi parametre zobrazenia zobrazovania textúry - príkaz glTexParameteri() resp. glTexParameterf()
</ul>
<h3>Povoli textúru</h3>
glEnable(GL_TEXTURE_1D); 	//povolí jednorozmernú textúru
glEnable(GL_TEXTURE_2D); 	//povolí jednorozmernú textúru - toto budeme pouíva - je to u zadané v súbore Unit1.h
glEnable(GL_TEXTURE_3D);	//pre povolenie trojrozmernıch textúr - nebudeme sa im venova
<h3>Vytvori štruktúru</h3>
Ukáeme si v nasledovnıch èastiach ako vytvori štruktúru manuálne, ako vytvori štruktúru naèítaním z obrázka. Štruktúra ba mala by štvorcového
rozmeru n x n, kde n je z mnoiny {32,64,128,256}, ak pouívame viac textúr volíme 128 alebo 64 inak 256 	
<h3>Prepoji štruktúru na OpenGl</h3>
glTexImage2D(GL_TEXTURE_2D, 0, 3, 256, 256, 0, GL_RGB, GL_UNSIGNED_BYTE, &bmp);
<br> &nbsp; &nbsp; // 1. par. ........ vdy da GL_TEXTURE_2D
<br> &nbsp; &nbsp; // 2. par. ........ vdy da 0 (má vıznam ak urobíme viac textur pre rôzne detaily - mipmapy)
<br> &nbsp; &nbsp; // 3. par. ........ poèet farieb RGB=3, RGBA=4 (ak potrebujeme nastavova priesvitnos, volíme 4)
<br> &nbsp; &nbsp; // 4. par. ........ rozmer textúry v smere x  
<br> &nbsp; &nbsp; // 5. par. ........ rozmer textúry v smere y
<br> &nbsp; &nbsp; // 6. par. ........ vdy da GL_UNSIGNED_BYTE (typ premennej v texture), je moné voli aj úspornejšie modely 
<h3>Nastavenie parametrov zobrazovania textúry</h3>
    Súradnice v textúre sú oznaèované 
	<br>s ... vodorovná súradnica - celá textúra je v intervale &lt;0 ; 1&gt;
	<br>t ... zvislá súradnica - celá textúra je v intervale &lt;0 ; 1&gt;
	<br><br>Prvé urèíme èo sa má dia, ak pri zadávaní bodu z textúru pouijeme hodnotu mimo intervalu &lt;0 ; 1&gt;,
	je moné voli opakovanie - textúra je akoby nekoneèná, tvorená kachlièkami o rozmere 1
	<br>alebo volíme natiahnutie - textúra sa zdeformuje/natiahne do zadanej hodnoty 
    <br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);      // v smere osi x povolime opakovanie textury
    <br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);      // v smere osi y povolime opakovanie textury
    <br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);      // v smere osi x povolime naahovanie textury
    <br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);      // v smere osi y povolime naahovanie textury
    <br><br>Ako druhé urèíme ako sa textúra bude chova pri zmenšovaní/zveèšovaní. Textúra môe ma viac texelov viac ako povrch pixelov a musíme prepoèíta
	farbu jednotlivıch pixelov pod¾a nejakého vzorca. Sú moné dva základné postupy
	<br>Urèi farbu pixelu pod¾a najblišieho texelu
	<br>Urèi farbu pixelu pod¾a viacerıch najbliších texelov lineárnou aproximáciou - presnejšie ale pomalšie
	<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);  // spôsob vıpoètu bodov aproximáciou (textura vaèšia)
    <br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);  // spôsob vıpoètu bodov aproximáciou (textura menšia)
	<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST );  // spôsob vıpoètu bodov pomocou najblišieho (textura vaèšia)
    <br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );  // spôsob vıpoètu bodov pomocou najblišieho (textura menšia)

</body>
</html>


<br>V nasledovnom programe vytváram vzorku tvorenú šachovnicovo - kadé druhú políèko je èierne, biele políèka sú tieòované.
<br>
<img src="textura1.jpg" width="435" height="320" border="0" alt="">  
<br><br>
<h3>Deklarácia textúry</h3>
(volím systém RGB, kde kadá farba je zadaná hodnotou &lt;0;255&gt; ) 
<table bgcolor="#ccccff"><tr><td>
<code><pre>
    GL_UNSIGNED_BYTE bmp[256][256][3];
   // miesto pre texturu 256*256
</pre></code>
</table>
<h3>Vytvorenie textúry</h3>
Textúra bude tvorená šachovnicou 8x8 kde sa striedajú èierne políèka so svetlımi, prièom vo svetlıch políèkach pribúda 
èervenej farby smerom doprava a zelenej pribúda smerom nadol
<table bgcolor="#ccccff"><tr><td>
<code><pre>
   for (int y=0;y<256;y++)             // pro vsechny radky pixmapy
        for (int x=0;x<256;x++)        // pro vsechny pixely na radku
        if ((y/32+x/32)%2)
            bmp[y][x][0]= bmp[y][x][1]= bmp[y][x][2]= 0;// cierne policko
        else
		{   bmp[y][x][0]=x; bmp[y][x][1]=y; bmp[y][x][2]= 0; }
    glEnable(GL_TEXTURE_2D);       // povolime texturu  
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);      // v smere osi x povolime opakovanie textury
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);      // v smere osi y povolime opakovanie textury
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);  // spôsob vıpoètu bodov (textura vacsia)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);  // spôsob vıpoètu bodov (textura mensia)
    glTexImage2D(GL_TEXTURE_2D, 0, 3, 256, 256, 0, GL_RGB, GL_UNSIGNED_BYTE, &bmp);
		  // 1. par. ........ vdy da GL_TEXTURE_2D
		  // 2. par. ........ vdy da 0 (má vıznam ak urobíme viac textur pre rôzne detaily)
		  // 3. par. ........ poèet farieb RGB=3, RGBA=4
		  // 4. par. ........ rozmer v smere x  
		  // 5. par. ........ rozmer v smere y
		  // 6. par. ........ vdy da GL_UNSIGNED_BYTE (typ premennej v texture)
		  // 7. par. ........ adresa textury
</pre></code>
</table>
<h3>Natiahnutie textúry</h3>
textúra tım e sa "naahuje" na plochu sa rôzne deformuje, rozumné vısledky sú ak 
<ul><li>útvar textury a rovinného útvaru sú podobné
	<li>textúra je štvorec a rovinnı útvar je rovnobeník.
	<li>textúra je štvorec a rovinnı útvar je trojuholník 
</ul>
<table bgcolor="#ccccff"><tr><td><img src="obr/textura1.png" width="558" height="428" border="0" alt="">
<td><code><pre>
    glBegin(GL_QUADS);
//štvorec sa natiahne na štvorec
        glTexCoord2f(0.0, 0.0); glVertex3f(-6, +6, -2);
        glTexCoord2f(1.0, 0.0); glVertex3f(+6, +6, -2);
        glTexCoord2f(1.0, 1.0); glVertex3f(+6, -6, -2);
        glTexCoord2f(0.0, 1.0); glVertex3f(-6, -6, -2);
glEnd();</pre></code></tr>
<tr><td><img src="obr/textura2.png" width="558" height="428" border="0" alt="">	
<td><code><pre>
    glBegin(GL_QUADS);
//štvorec sa natiahne na obdånik
        glTexCoord2f(0.0, 0.0); glVertex3f(-6, +3, -1);
        glTexCoord2f(1.0, 0.0); glVertex3f(+6, +3, -1);
        glTexCoord2f(1.0, 1.0); glVertex3f(+6, -3, -1);
        glTexCoord2f(0.0, 1.0); glVertex3f(-6, -3, -1);
glEnd();</pre></code></tr>
<tr><td><img src="obr/textura3.png" width="558" height="428" border="0" alt="">	
<td><code><pre>
    glBegin(GL_QUADS);
//štvorec sa natiahne na rovnobeník
        glTexCoord2f(0.0, 0.0); glVertex3f(-6, +3, 0);
        glTexCoord2f(1.0, 0.0); glVertex3f(+3, +3, 0);
        glTexCoord2f(1.0, 1.0); glVertex3f(+6, -3, 0);
        glTexCoord2f(0.0, 1.0); glVertex3f(-3, -3, 0);
glEnd();</pre></code></tr>
<tr><td><img src="obr/textura4.png" width="558" height="428" border="0" alt="">	
<td><code><pre>
    glBegin(GL_QUADS);
//lichobeník sa vyree zo štvorca
         glTexCoord2f(0.0, 0.0); glVertex3f(-6, +4, 0);
        glTexCoord2f(1.0, 0.0); glVertex3f(+6, +4, 0);
        glTexCoord2f(1.0*10/12, 1.0); glVertex3f(+4, -4, 0);
        glTexCoord2f(1.0*2/12, 1.0); glVertex3f(-4, -4, 0);
glEnd();</pre></code></tr>
<tr><td><img src="obr/textura5.png" width="558" height="428" border="0" alt="">	
<td><code><pre>
 glBegin(GL_TRIANGLES);
 //pravouhlı trojuholník sa vyree zo štvorca
         glTexCoord2f(0.0, 0.0); glVertex3f(-6, +4, 0);
        glTexCoord2f(1.0, 0.0); glVertex3f(+6, +4, 0);
        glTexCoord2f(0.0, 1.0); glVertex3f(-6, -4, 0);
glEnd();</pre></code></tr>
<tr><td><img src="obr/textura6.png" width="558" height="428" border="0" alt="">	
<td><code><pre>
 glBegin(GL_TRIANGLES);
 //rovnoramennı trojuholník sa vyree zo štvorca
         glTexCoord2f(0.0, 0.0); glVertex3f(-6, +4, 0);
        glTexCoord2f(1.0, 0.0); glVertex3f(+6, +4, 0);
        glTexCoord2f(0.5, 1.0); glVertex3f(0, -4, 0);
    glEnd();

</pre></code></tr>
</table>
</body>
</html>
