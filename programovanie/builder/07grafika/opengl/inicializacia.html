<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1250">
    <meta name="Content-language" content="sk"> 
    <LINK href="../../css/style.css" type="text/css" rel=stylesheet>
</head>

<body>
<H3>Inicializovanie</H3>
<P>Ako sme sa doèítali kninica OpenGl nemá nástroje na prácu s oknom, poskytuje viaceré monosti ako zobrazi tú
	istú scénu a teda na zaèiatku bude našou povinnosou vykona korektnú inicializáciu prostredia OpenGl a tie nastavi
	niektoré parametre zobrazenia. Tıchto príkazov je viac a ich vysvetlovaním a popisom inıch moností by som
	pravdepodobne mnohıch u tu odradil od experimentov a tak spoèiatku tieto riadky berte ako nutné zaklínadlo,
	kde musíme vytvori nieko¾ko potrebnıch premennıch a tie musíme nakopírova nieko¾ko riadkov do FormCreate.
Pre inicializovanie pouijeme nasledujúcu šablónu:</P>
<a href="file://priklady/zaklad.zip"></a>
<br>
Tento súbor rozbalte a upravte Builder aby sme ho mohli voli ako novı projekt nasledovne:
<ul><li>Naèítajte stiahnutı projekt do programu Builder
	<li>Z Menu si zvolte: Project->Add to Repository...  
		<br>Objaví sa nasledovné okno
		<img src="obr/repository.png" width="386" height="287" border="0" alt="">
		<br>ktoré vypíšte pod¾a návodu a ulote.
		<br>Ikona je tie v stiahnutom projekte
	<li>Teraz u budete môc vybra cez File->Novı->Other->Projects->Opengl zvoli tento project
		<br>(program sa ešte bude pıta kam sa má zapísa - ak nemáte pripravenı prázdny prieèinok zadajte hlavnı prieèinok
		     disku d: resp e:)
</ul>
Tu je u urobená inicializácia vıstupného okna do okna Formulara a zadané aj nejaké príkazy na nakreslenie nejakıch èiar.
OpenGl obsadí/pokryje celı formulár, neskôr si ukáeme ako urobi aby zabral len èas alebo ako urobi aby beal v celoobrazovkovom reime
<br>Inicializácia okna OpenGl sa urobí hneï - nevolí ju uívate¾, zapínanie a vypínanie grafiky OpenGl budeme robi nesôr.
<br><br>Zmenil som súbory 
<ul><li>Unit1.cpp - do ktorého bene píšeme
	<li>Unit1.h - v ktorom je popísanı objekt Form1  
</ul>	
<div style="border-width:3;border-style:outset;width:690px;margin:10px;background-color:#dddddd;">
<div align="left" style="background-color:#3366ff; width:690px; padding:0;border-width:0;color:white">Unit1.h
</div>
<div style="background-color:#dddddd; width:690px;" >
<div style="margin:10px">
<pre>//---------------------------------------------------------------------------
#ifndef Unit1H
#define Unit1H
//---------------------------------------------------------------------------
#include &lt;Classes.hpp>
#include &lt;Controls.hpp>
#include &lt;StdCtrls.hpp>
#include &lt;Forms.hpp>
//---------------------------------------------------------------------------
class TForm1 : public TForm
{
__published:	// IDE-managed Components
        void __fastcall destroy(TObject *Sender);  //ošetrenie udalosti OnDestroy
        void __fastcall resize(TObject *Sender);   //ošetrenie udalosti OnResize
private:	// User declarations
public:		// User declarations
  __fastcall TForm1(TComponent* Owner);
    HDC     hdc;            // device context (nová premenná)
    HGLRC   hrc;            // rendering context (nová premenná)
    int  ogl_inicialized;   // táto premenná vie, èi bola grafika inicializovaná
    int  ogl_init();        // tento podprogram inicializuje grafiku
    void ogl_exit();        // tento podprogram korektne ukonèí OpenGl
    void ogl_draw();        // v tomto podprograme budeme kresli - pozri Unit1.cpp
    void ogl_resize();      // tento podprogram zabezpeèí natiahnutie OpenGl cez celı Form pri zmene ve¾kosti
    void FormDestroy();
};
// inicializáciu grafiky som dal sem (mohla by by aj v Unit1.cpp) ale je dos dlhá a komplikovala by iakovi preh¾ad
    int TForm1::ogl_init()
    {
    if (ogl_inicialized) return 1;
    hdc=0;
    hdc = GetDC(Handle);             // get device context
    PIXELFORMATDESCRIPTOR pfd;
    ZeroMemory( &pfd, sizeof( pfd ) );      // set the pixel format for the DC
    pfd.nSize = sizeof( pfd );
    pfd.nVersion = 1;
    pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
    pfd.iPixelType = PFD_TYPE_RGBA;
    pfd.cColorBits = 24;
    pfd.cDepthBits = 24;
    pfd.iLayerType = PFD_MAIN_PLANE;
    SetPixelFormat(hdc,ChoosePixelFormat(hdc, &pfd),&pfd);
    hrc=0;
    hrc = wglCreateContext(hdc);            // create current rendering context
    if(hrc == NULL)
            {
            ShowMessage("Could not initialize OpenGL Rendering context !!!");
            ogl_inicialized=0;
            return 0;
            }
    if(wglMakeCurrent(hdc, hrc) == false)
            {
            ShowMessage("Could not make current OpenGL Rendering context !!!");
            wglDeleteContext(hrc);          // destroy rendering context
            ogl_inicialized=0;
            return 0;
            }
    ogl_resize();
    glEnable(GL_DEPTH_TEST);                // Zbuf
    glDisable(GL_CULL_FACE);                // vynechavaj odvratene steny
    glDisable(GL_TEXTURE_2D);               // pouzivaj textury, farbu pouzivaj z textury
    glEnable(GL_BLEND);                    // priehladnost
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glShadeModel(GL_SMOOTH);                // gourard shading
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);   // background color
    ogl_inicialized=1;
    return 1;
    }
//---------------------------------------------------------------------------
void TForm1::ogl_exit()
    {
    if (!ogl_inicialized) return;
    wglMakeCurrent(NULL, NULL);     // release current rendering context
    wglDeleteContext(hrc);          // destroy rendering context
    ogl_inicialized=0;
    }
//---------------------------------------------------------------------------
void TForm1::ogl_resize()
    {
    if (Width&lt;=0) Width = 100;                  // Prevent a divide by zero
    if (Height&lt;=0) Height = 100;
    if (!ogl_inicialized) return;
    glViewport(0,0,Width,Height);              // Set Viewport to window dimensions
    glMatrixMode(GL_PROJECTION);        // operacie s projekcnou maticou
    glLoadIdentity();                   // jednotkova matica projekcie
  glOrtho(-10,+10,-10,+10,-10,+10);     kolmá projekcia (zobrazí všetko v kocke o rozmere 20, ostatné odree) 
 //   gluPerspective(40,float(xs)/float(ys),0.1,100.0); // matica=perspektiva,120 stupnov premieta z viewsize do 0.1
    glMatrixMode(GL_TEXTURE);           // operacie s texturovou maticou
    glLoadIdentity();                   // jednotkova matica textury
    glMatrixMode(GL_MODELVIEW);         // operacie s modelovou maticou
    glLoadIdentity();                   // jednotkova matica modelu (objektu)
    ogl_draw();
    }
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
extern PACKAGE TForm1 *Form1;
//---------------------------------------------------------------------------
#endif
</pre></div></div></div>

<div style="border-width:3;border-style:outset;width:690px;margin:10px;background-color:#dddddd;">
<div align="left" style="background-color:#3366ff; width:690px; padding:0;border-width:0;color:white">Unit1.h
</div>
<div style="background-color:#dddddd; width:690px;" >
<div style="margin:10px">
<pre>//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#include &lt;vcl.h>
#pragma hdrstop
#include &lt;gl\gl.h>// Hlavièkovı soubor pro OpenGL32 knihovnu
#include &lt;gl\glu.h>// Hlavièkovı soubor pro Glu32 knihovnu
#include &lt;gl\glaux.h>// Hlavièkovı soubor pro Glaux knihovnu

#include "Unit1.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TForm1 *Form1;
//---------------------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner)
        : TForm(Owner)
{    ogl_inicialized=0;
     ogl_init();
}
void TForm1::ogl_draw()
{ glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
//tu zadávame príkazy na kreslenie napríklad:
  <font color="Blue">
  glColor4f(1.0f, 1.0f, 1.0f,1.0f);
  glBegin(GL_LINES);
  glVertex3i(0,0,0);glVertex3i(7,0,0);
  glVertex3i(0,0,0);glVertex3i(0,7,0);
  glVertex3i(0,0,0);glVertex3i(0,0,7);
  glEnd();
</font>   
glFlush();
SwapBuffers(hdc);
}
//---------------------------------------------------------------------------
void __fastcall TForm1::destroy(TObject *Sender)
{
  ogl_exit();        
}
//---------------------------------------------------------------------------
void __fastcall TForm1::resize(TObject *Sender)
{
ogl_resize();
}
//---------------------------------------------------------------------------
</pre></div></div></div>

<P>Vidíme, e kninica OpenGL je neobjektová. Funkcie kninice OpenGL zaèínajú 
prefixom<FONT color=#0044ff><SPAN class=program> gl</SPAN></FONT>... a pomocné 
funkcie prefixom<FONT color=#0044ff><SPAN class=program> glu</SPAN></FONT>... Do 
takéhoto programu budeme postupne dopåòa kód.</P>
<dl><dt>Súradná sústava
	<dd>Na zobrazovanom okne sú súradnice
		<br>x - vodorovná os, narastá smerom doprava
		<br>y - zvislá os, narastá smerom <font color="Blue" size="+1">hore</font>
		<br>z - smeruje/narastá k nám
		<br>bod [0;0] je v strede formulára
	<dt>Priemet 3D-&gt;2D
	<dd>Aby sme openGl dokazali pouíva, musíme pochopi myšlienku ako program premieta 3D priestor do 2D priestoru.
		Obraz sa premieta do celého okna formuláru (zotrie sa nám celı formulár), my si ale môme nastavi orezanie zobrazovanıch objektov pomocou príkazu
		<br><font color="#cc0000" style="font-family:'Courier'; font-weight:700">glViewport (x1,y1,x2,y2);</font>
		<br>kde nastavíme súradnice ¾avého dolného a pravého horného rohu obdånika mimo ktorého je obraz odrezanı. Prechod z 3 súradníc
		na dve je jednoduchı - všetky zobrazované objekty premietneme do roviny xy (súradnicu <font color="#cc0000" style="font-weight:bold">z</font> smerujúcu k nám berieme do úvahy len pri otázke vidite¾nosti.
		<br>Fyzické <font color="#cc0000" style="font-weight:bold">x</font> sa premietne do <font color="#cc0000" style="font-weight:bold">x</font> na obrazovke a podobne os <font color="#cc0000" style="font-weight:bold">y</font>.
		<br>Celé tajomstvo projekcie (spôsobe zobrazenia objektov na danıch súradniciach) je skryté v transformaènıch maticiach (tabu¾kách), ktoré mono nastavova 
		èíslo po èísle alebo (èo bude pre nás jednoduchšie) volaním procedúr, ktoré to urobia za nás a my sa ani nebudeme stara ako tie matice vyzerajú.
	<dt>Nastavenie projekènej matice
	<dd>Tu zvolíme model zobrazenia. Máme k dispozícii 2 modely
		<ul><li>rovnobené premietanie - tí èo majú deskriptívu vedia o èom to je
			<br>napr. slneèné svetlo premieta telesá na papier, vzdialenos telesa od papiera nehrá iadnu úlohu)
			<li>perspektíva - komplikovanejšie ale reálnejšie	
			<br>napr. svetlo iarovky premieta telesá na papier, vzdialenos telesa od papiera má úlohu
		</ul>	
		e ideme pracova s projekènou maticou dáme najavo príkazmi"
		<br><code><font color="#cc0000" style="font-weight:bold">glMatrixMode(GL_PROJECTION);<br>glLoadIdentity;</font></code>
		<br>a za ním uvedieme príkaz na vo¾bu projekcie. Ako u vieme máme dve vo¾by:
		<dl><dt style="width:600"><font color="Red" style="font-family:'Courier'">gluPerspective(poc_otoc, x/y, rezná_rovina1, rezná_rovina2);</font>
			<dd>
			<br><img src="obr/gluperspective.png" width="440" height="200" border="0" alt="">
			<br><b>fovy </b>... zornı uhol pozorovate¾a (zadávame od 30 po 80, èím urèuje ostros perspektívy) 
			<br><b>w/h</b>... pomer šírka vıstupu ku vıške (nemeni), zadávame šírku okna deleno vıškou
			<br><b>near (rezná_rovina1) </b>... zadaná hodnota urèuje, ktoré hodnoty z (håbka) budú zobrazované (menšie nezobrazí) volíme 1
			<br><b>far (rezná_rovina1) </b>... body kde z je väèšie ako táto hodnota sa nezobrazia volíme napr. 1000
			<br>Pri vo¾be polohy ohranièujúcich rovín je doleité aby súradnice našich objektov boli medzi tımito rovinami inak nebudú zobrazené
			<br>Odporúèam v kreslenıch obrázkoch s perspektívou poèíta s interaktívnou monosou zmeny mierky, lebo je ako odhadnú akı ve¾kı bude zobrazenı objekt.
			<dt><font color="Red">glOrtho(x1,x2,y1,y2,z1,z2:real);</font>
			<dd>Tımto príkazom sme urèili ve¾kos priestoru, ktorı chceme zobrazova.
			<br>x1 .. x2 - interval zobrazovanıch x hodnôt
			<br>y1 .. y2 - interval zobrazovanıch y hodnôt
			<br>z1 .. z2 - interval zobrazovanıch z hodnôt
			<br>Kreslenie bez perspektívy je jednoduchšie, systém vie zabezpeèi aby sa objekty zobrazili presne do našeho vıstupného okna. Toto budeme spoèiatku aj pouíva.
		</dl>	
<dt>Vo¾ba zotieracej farby
<dd>Farbu na yotretie okna nastavíme príkazom:
	<br><font color="Red" style="font-family:'Courier'">glClearColor(r, g, b, p);</font>,
	<br>kde všetky parametre sú z intervalu &lt;0ô1&gt; a parametre r,g,b sú farebné zloky a p urèuje priesvitnos.
	 Štandartne volíme všetky farebné parametre rovné 0 a priesvitnos 1 (iadna).
	<br>Na zotretie okna je príkaz:
	<br><font color="Red" style="font-family:'Courier'">glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);</font>,
	<br>ktorı nastaví všetky pixle obrazovky na predvolenú zotieraciu farbu.asi sa vám parameter v zátvorke zdá "èudnı" ale presne ho odpíšte aby to fungovalo. 
 
</dl>		
</body>
</html>
