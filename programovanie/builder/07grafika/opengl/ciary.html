  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1250">
    <meta name="Content-language" content="sk"> 
    <LINK href="../../css/style.css" type="text/css" rel=stylesheet>
</head>

<body>
<h3>Kreslenie</h3>
<dl>
<dt>Double Buffering
<dd>Z programovania grafiky (najmä animácií) pod Delphi resp. Lazarus poznáme príkaz 
	<br><code>DoubleBuffered:=True;</code>,
	<br>ktorı zabezpeèil, aby nám animácie neblikali. Myšlienka je v tom, e kreslenie nebeí priamo na obrazovku
	ale len do buffra v pamäti a a po ukonèení celého kreslenia sa obraz ukáe (dáta sa nekopírujú, len karte sa povie, 
	e dáta na zobrazenie má v buffri). V OpenGl som v úvodnıch "zaklínadlách"	dvojité bafrovanie zapol a vısledok kreslenia 
	uvidíme, a keï dáme príkaz na prepnutie bafrov:
	<br><font color="Red" style="font-family:'Courier'">SwapBuffers(DC);</font>
	<br>Tento príkaz bude vdy ukonèova kadé kreslenie.
<dt>Kreslenie primitív
<dd>Ak chceme kresli niektorú z primitív (elementárny graf. objekt) pouijeme konštrukciu:
	<pre>
glBegin(zvolená_primitiva);
   ...
	zadávanie súradníc a farieb zvoleného objektu
	...
glEnd();	
	</pre>
	Budeme pouíva nasledovné primitiva:
	<ul><li>GL_POINTS - kreslí body
		<li>GL_LINES - kreslí èiary-úseèky
		<li>GL_TRIANGLES - kreslí trojuholníky
		<li>GL_LINE_STRIP - kreslí lomenú èiaru
		<li>GL_LINE_LOOP - uzavretá lomená èiara
		<li>GL_TRIANGLES - trojuholník (kadé tri vrcholy definujú jeden trojúholník)
		<li>GL_TRIANGLE_FAN - vejáø z trojuholníkov
		<li>GL_TRIANGLE_STRIP - pás trojuholníkov
		<li>GL_QUADS - štvoruholníky (quadrilateral)
		<li>GL_QUAD_STRIP - pás štvoruholníkov
		<li>GL_POLYGON - polygony (len konvexné polygony s nepretínajúcimi sa hranami) 
 	</ul>
	Na vykreslenie obdånika leiaceho v rovine xy mono poui príkaz glRect(x1,y1,x2,y2);
<dt>Súradnice
<dd>Kadé primitivum je jednoznaène urèené postupnosou bodov. Body zadávame jednotlivo príkazom
	<br><font color="#cc0000" style="font-family:'Courier'; font-weight:700">GlVertex(suradnice_bodu);</font>
	<br>Súradnice mono zada 2 - pre dvojrozmernı priestor, alebo 3 - pre trojrozmernı oriestor,
	<br>zadáva ich mono celımi alebo desatinnımi èíslami.
	<br>Pre tıch, ktorım je "¾úto" systému Opengl, e musí skúma akého typu sú parametre a tie ko¾ko ich je moné voli upresnenı príkaz
	<br><font color="#cc0000" style="font-family:'Courier';">GlVertex3(suradnice_bodu);</font> &nbsp; &nbsp;//pre 3 súradnice
	<br><font color="#cc0000" style="font-family:'Courier';">GlVertex2(suradnice_bodu);</font> &nbsp; &nbsp;//pre 2 súradnice
	<br><font color="#cc0000" style="font-family:'Courier';">GlVertexf(suradnice_bodu);</font> &nbsp; &nbsp;//pre desatinné súradnice
	<br><font color="#cc0000" style="font-family:'Courier';">GlVertexi(suradnice_bodu);</font> &nbsp; &nbsp;//pre celé súradnice
	<br><font color="#cc0000" style="font-family:'Courier';">GlVertex3i(suradnice_bodu);</font> &nbsp; &nbsp;//pre 3 celé súradnice a pod.
	<br><br>V prípade úseèiek vdy dvojica bodov (2 príkazy glvertex) tvorí úseèku
		<br>V prípade 3-uholníka trojica vrchol vytvorí trojuholník a tak ïalej
		<br>Prebıvajúce vrcholy sa ignorujú. 
<dt>Farba
<dd>Vkladaním príkazov na nastavenie farby urèíme farbu kresleného objektu. Príkaz je tie vo viacerıch variantách
	<br>font color="#cc0000" style="font-family:'Courier'; font-weight:700">glColor(r,g,b,p)</font>
	<br>r,g,b - urèujú mnotvo farby v RGB modeli a p urèuje priesvitnos (nemusí by zadaná)
	<br>parametre môu by všetky celé - vtedy volíme hodnoty od 0 po 255, alebo desatinné, tu zadávame hodnoty od 0 po 1
	<br>Tie je moné u v mene príkazu urèi aké a ko¾ko parametrov zadáme
	<br>glColor3f - zadávame 3 reálne èísla, glColor4i - zadávame 4 celé èísla 
	<br>Príklady  
	<br>glColor3f(1,0,0) - kriklavá èervená
	<br>glColor3i(1,0,0) - èierna s nádychom do èervena
	<br>Ak chceme pouíva priesvitné farby, musíme priesvitnos aktivova príkazom:
	<br><font color="#cc0000" style="font-family:'Courier'; font-weight:700">  glEnable(GL_BLEND);</font>
	<br>a potom zvoli, èo sa má s farbami pri zmiešavaní udia, napr. môme zada toto: 
	<br><font color="#cc0000" style="font-family:'Courier'; font-weight:700">glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</font>

<dt>Transformácia súradníc
<dd>Štandartnı poh¾ad na objekt je pri nulovıch natoèeniach, teda ak dáme vykresli súradné osi x,y,z budeme vidie neskreslené osi x a y ale os z nevidno
	lebo smeruje kolmo z obrazu smerom ku nám. Aby sme mohli voli inı poh¾ad na zobrazovanı priestor pouívame transformácie. Transformácie sa zapisujú do
	modelovej matice u vieme, e ak chceme meni niektorú transformaènú maticu musíme systému najprv poveda v ktorej matici chceme robi zmeny (v tomto prípade modelú maticu), to urobíme
	príkazom:
	<br><font color="#cc0000" style="font-family:'Courier'; font-weight:700">glMatrixMode(GL_MODELVIEW);</font>
	<br><font color="#cc0000" style="font-family:'Courier'; font-weight:700">glLoadIdentity();</font> &nbsp; &nbsp;//naèítanie základnej matice
	<br>po zadaní tıchto príkazov mono zadáva trasformaèné príkazy:
	<ul><li>rotaèné ... glRotate
		<li>posuvné ... glTranslate
		<li>mierkové ... glScale
		<li>priblíenie (má vıznam pri perspektíve) ... gluLookAt
	</ul>	  
	<dl><dt>glTranslate(dx,dy,dz); 
		<dd>Hodnota dx bude pripoèítaná ku x-ovej súradnici všetkıch vykreslovanıch objektov. Pri perspektíve si musíme uvedomi pravidlá perspektívy - pri priblíení
			sa objekt na obrazovke zväèšuje a naopak. 
			Pri Ortho zobrazení nám teleso alebo jeho èas môu vybehnú zo zobrazovaného priestoru a teleso teda nebudeme vidie prípadne bude orezané.
			<br>Posunutia sú reálne a je moné to aj urèi upresnením v názve podrogramu glTranslatef.
		<dt>glRotate(uhol, vektorx, vektory, vektorz)
		<dd>uhol ... reálne èíslo udáva uhol o ktorı chceme otáèa (uhol je zadanı v stupòoch)
			<br>vektor zadanı svojimi zlokami urèuje os okolo ktorej budeme otáèa, smer urèujeme pravidlom pravej ruky. Otáèa teda vieme okolo priamok prechádzajúcich poèiatkom
			<br>Príklady
			<br>glRotate(30, 0, 1, 0); &nbsp; &nbsp;//otoèenie okolo osi y o 30 stupòov
		<dt>glScale(mx,my,mz)
		<dd>parametre udávajú koeficient, ktorım budú "akoby" všetkım objektom prepoèítané súradnice (x:= x*mx, ...). V prípade ak je parameter väèší ako 1 ide o zväèšovanie a naopak.
			V prípade perspektívy je potrebné si uvedomi rozdiel medzi priblíením a mierkovaním/zväèšením
	</dl>
	<dt>Kreslíme prvı obrázok
	<dd>U na tomto jednoduchom obrázku vyuijeme niektoré vıhody systému
		<ul><li>nemusíme robi prevod medzi reálnymi a obrazovkovımi súradniciami
			<li>pri otáèaní nemusíme robi vıpoèty kam sa ten ktorı bod presunie
		</ul>
	No na tentoraz u dos teórie a ideme kresli. Zvolíme ortogonálne zobrazenie lebo je jednoduchšie. Celá kresba bude spoèíva v kreslení súradnıch osí a navyše nakreslíme 
	<ol><li>trojuholník majúci vrcholy na osiach vo vzdialenosti 6 od poèiatku farby modrej
		<li>štvouholník-obdånik majúci farbu ltú poloviènej priesvitnosti a vrcholy [3,0,0],[0,0,3],[3,7,0],[0,7,3] 
	</ol>		
	Ešte sa vrátim ku spôsobu zobrazenia, kde máme urèi zobrazovanı priestor, zvolím pre kadú súradnicu interval &lt;-8; +8&gt;, èo evidentne bude staèi aby mi iadny bod pri ¾ubovoòom otáèaní
	z neho nevybehol. Aby sme mali ten správny priestorovı dojem nechám objekty rotova okolo osi y (zvislá os).
	<br>Inicializácia OpenGl prebehne vo FormCreate a kreslenie bude prebieha v Timeri. Deklaráciu potrebnıch premennıch
	a tie inicializáciu spomínanú v èasti "inicializácia" tu u neuvádzam.
	<div style="border-width:3;border-style:outset;width:690px;margin:10px;background-color:#dddddd;">
<div align="left" style="background-color:#3366ff; width:690px; padding:0;border-width:0;color:white">Unit1.pas
</div>
<div style="background-color:#dddddd; width:690px;" >
<div style="margin:10px">
<pre>
procedure TForm1.Timer1Timer(Sender: TObject);
begin
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glRotate(uholx,1,0,0);
  glRotate(uholy,0,1,0);

  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glBegin(gl_lines);
  glVertex3i(0,0,0);glVertex3i(7,0,0);
  glVertex3i(0,0,0);glVertex3i(0,7,0);
  glVertex3i(0,0,0);glVertex3i(0,0,7);
   glend();

  glBegin(GL_TRIANGLES);
  glColor3f(0.5,0.5,1.0);
  glVertex3i(6,0,0);glVertex3i(0,6,0);glVertex3i(0,0,6);
   glend();
  glColor4f(1.0,1.0,0.2,0.7);
   glBegin(GL_POLYGON);
  glVertex3i(3,0,0);glVertex3i(0,0,3);glVertex3i(0,7,3);glVertex3i(3,7,0);
   glend();
  uholx:=(uholx+2) mod 360;
   uholy:=(uholy+1) mod 360;
  SwapBuffers(DC);
end;
</div></div></div>
Inı spôsob ako zvırazni, e ide o 3D priestor spoèíva v tom, e necháme uívate¾a aby si myšou natáèal priestor pod¾a svojich potrieb. Èasovaè je tu ponechanı aby sa okno prekrytím, alebo zbalením dole samo "opravilo".
	<br>Rotácia sa bude vykonáva ošetrovaním udalostí 
	<br>OnMousedown - tu si zapíšeme, kde sa to stalo a premennú mdole nastavíme na 1
	<br>OnMouseUp - tu zapíšeme do premennej mdole 0 a vypoèítame nové základné otoèenie uholx0 a uholy0 
	<br>OnMouseMove - tu pod¾a pohybu myši urèíme o ko¾ko treba treba otoèi okolo osi y a ko¾ko okolo x
	<div style="border-width:3;border-style:outset;width:690px;margin:10px;background-color:#dddddd;">
<div align="left" style="background-color:#3366ff; width:690px; padding:0;border-width:0;color:white">Unit1.pas
</div>
<div style="background-color:#dddddd; width:690px;" >
<div style="margin:10px">
<pre>
procedure TForm1.Timer1Timer(Sender: TObject);
begin
//   timer1.Enabled:=False;
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glBegin(gl_lines);
  glVertex3i(0,0,0);glVertex3i(7,0,0);
  glVertex3i(0,0,0);glVertex3i(0,7,0);
  glVertex3i(0,0,0);glVertex3i(0,0,7);
   glend();

  glBegin(GL_TRIANGLES);
  glColor4f(0.5,0.5,1.0,0.7);
  glVertex3i(6,0,0);glVertex3i(0,6,0);glVertex3i(0,0,6);
   glend();
  glColor4f(1.0,1.0,0.2,0.8);
   glBegin(GL_POLYGON);
  glColor4f(1.0,1.0,0.2,0.8);
  glVertex3i(3,0,0);glVertex3i(0,0,3);glVertex3i(0,7,3);glVertex3i(3,7,0);
   glend();
  SwapBuffers(DC);
end;

procedure TForm1.dole(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
mx:=X; my:=Y;
mdole:=1;
end;

procedure TForm1.hore(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
    mdole:=0;
    uholx0:=uholx;
    uholy0:=uholy;
end;

procedure TForm1.pohyb(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
if mdole =1 then
Begin
  uholx:=uholx0-(my-Y) div 2; uholy:=uholy0-(mx-X) div 2;
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glRotate(uholx,1,0,0);
  glRotate(uholy,0,1,0);
  Timer1Timer(Form1);
End;

</div></div></div>
a vısledok by mohol vyzera nasledovne
<br><img src="obr/u1.png" width="692" height="460" border="0" alt="">
<br>obrázok mono chytením myšou otáèa okolo osi x (vodorovnej osi) a okolo osi y (zvislá os)		


</body>
</html>
