<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1250">
    <meta name="Content-language" content="sk"> 
    <LINK href="../../css/style.css" type="text/css" rel=stylesheet>
</head>

<body>
<dl>
<dt>Transformácia súradníc
<dd>Transformáciou súradníc môeme pomocou zmeny "modelovej" matice: 
	<ul><li>otáèa všetky vykreslované objekty (prípadne len niektoré) okolo priamky prechádzajúcej poèiatkom
		<li>posúva vykreslované objekty o zadanı vektor
		<li>zväèšova vykreslované objekty
	</ol>
	Teraz si ukáeme ako transformácie aplikova na celú vykreslovanú scénu.	
    <br>Štandartnı poh¾ad na objekt je pri nulovıch natoèeniach, teda ak dáme vykresli súradné osi x,y,z budeme vidie naskreslené osi x a y ale os z nevidno
	lebo smeruje kolmo z obrazu smerom ku nám. Aby sme mohli voli inı poh¾ad na zobrazovanı priestor pouívame transformácie. Transformácie sa zapisujú do
	modelovej matice u vieme, e ak chceme meni niektorú transformaènú maticu musíme systému najprv poveda v ktorej matici chceme robi zmeny 
	(v tomto prípade modelovú maticu), to urobíme príkazom:
	<br><font color="#cc0000" style="font-family:'Courier'; font-weight:700">glMatrixMode(GL_MODELVIEW);</font>
	<br><font color="#cc0000" style="font-family:'Courier'; font-weight:700">glLoadIdentity();</font> &nbsp; &nbsp;//naèítanie základnej matice
	<br>po zadaní tıchto príkazov mono zadáva trasformaèné príkazy:
	<ul><li>rotaèné ... glRotate
		<li>posuvné ... glTranslate
		<li>mierkové ... glScale
		<li>priblíenie (má vıznam pri perspektíve) ... gluLookAt
	</ul>	  
	<dl><dt>glTranslate(dx,dy,dz); 
		<dd>Hodnota dx bude pripoèítaná ku x-ovej súradnici všetkıch vykreslovanıch objektov. Pri perspektíve si musíme uvedomi pravidlá perspektívy - pri priblíení
			sa objekt na obrazovke zväèšuje a naopak. 
			Pri Ortho zobrazení nám teleso alebo jeho èas môu vybehnú zo zobrazovaného priestoru a teleso teda nebudeme vidie prípadne bude orezané.
			<br>Posunutia sú reálne a je moné to aj urèi upresnením v názve podrogramu glTranslatef(), glTranslated().
		<dt>glRotatef(uhol, vektorx, vektory, vektorz)
		<dd>uhol ... reálne èíslo udáva uhol o ktorı chceme otáèa (uhol je zadanı v stupòoch)
			<br>vektor zadanı svojimi zlokami urèuje os okolo ktorej budeme otáèa, smer urèujeme pravidlom pravej ruky. 
			Otáèa teda vieme okolo priamok prechádzajúcich poèiatkom.
			<br>Príklady
			<br>glRotatef(30, 0, 1, 0); &nbsp; &nbsp;//otoèenie okolo osi y o 30 stupòov
		<dt>glScalef(mx,my,mz)
		<dd>parametre udávajú koeficient, ktorım budú "akoby" všetkım objektom prepoèítané súradnice (x:= x*mx, ...). V prípade ak je parameter väèší ako 1 ide o zväèšovanie a naopak.
			V prípade perspektívy je potrebné si uvedomi rozdiel medzi priblíením a mierkovaním/zväèšením
	</dl>
	Este treba poveda, e ak chceme poui viacero transformaènıch príkazov tak ich vykonávanie bude vykonávané v opaènom poradí
	<dt>Kreslíme prvı obrázok
	<dd>U na tomto jednoduchom obrázku vyuijeme niektoré vıhody systému
		<ul><li>nemusíme robi prevod medzi reálnymi a obrazovkovımi súradniciami
			<li>pri otáèaní nemusíme robi vıpoèty, kam sa ten ktorı bod presunie
		</ul>
	No na tentoraz u dos teórie a ideme kresli. Zvolíme ortogonálne zobrazenie lebo je jednoduchšie. Celá kresba bude spoèíva v kreslení súradnıch osí a navyše nakreslíme 
	<ol><li>trojuholník majúci vrcholy na osiach vo vzdialenosti 6 od poèiatku farby modrej
		<li>štvouholník-obdånik majúci farbu ltú poloviènej priesvitnosti a vrcholy [3,0,0],[0,0,3],[3,7,0],[0,7,3] 
	</ol>		
	Ešte sa vrátim ku spôsobu zobrazenia, kde máme urèi zobrazovanı priestor, zvolím pre kadú súradnicu interval &lt;-10; +10&gt;, èo evidentne bude staèi aby mi iadny bod pri ¾ubovoòom otáèaní
	z neho nevybehol. Aby sme mali ten správny priestorovı dojem nechám objekty rotova okolo osi y (zvislá os). (Pouijem Timer)
	<br>Aby sme transformácie dobre pochopili urobíme postupnú tvorbu programu
	<br>1. Obrázok sa nebude hıba len bude otoèenı
	<br> &nbsp; &nbsp; pridáme dve globálne premenné int uholx=30; uholy=30;
	<br> &nbsp; &nbsp; na zaèiatok kreslenia (podprogram ogl_draw()) pridáme príkazy 
	<br> &nbsp; &nbsp; glMatrixMode(GL_MODELVIEW);
  	<br> &nbsp; &nbsp; glLoadIdentity();
  	<br> &nbsp; &nbsp; glRotate(uholx,1,0,0);
  	<br> &nbsp; &nbsp; glRotate(uholy,0,1,0);
	<br>(tımto bude kreslenie prebieha u v otoèenıch súradniciach)
	<br>(aby zvislá os bola stále zvislá je dôleité poradie otáèania - najprv zadáme otoèenie okolo x a potom y)
	<br>(vyskúšaj ako to zobrazí keï ich prehodíme)
	
<div style="border-width:3;border-style:outset;width:690px;margin:10px;background-color:#dddddd;">
<div align="left" style="background-color:#3366ff; width:690px; padding:0;border-width:0;color:white">Unit1.cpp
</div>
<div style="background-color:#dddddd; width:690px;" >
<div style="margin:10px">
<pre>
void TForm1::ogl_draw()
{ glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
//tu zadávame príkazy na kreslenie
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glRotatef(uholx,1,0,0);
  glRotatef(uholy,0,1,0);

  glColor4f(1.0f, 1.0f, 1.0f,1.0f);
  glBegin(GL_LINES);
  glVertex3i(0,0,0);glVertex3i(7,0,0);
  glVertex3i(0,0,0);glVertex3i(0,7,0);
  glVertex3i(0,0,0);glVertex3i(0,0,7);
   glEnd();
   glBegin(GL_TRIANGLES);
  glColor3f(0.5,0.5,1.0);
  glVertex3i(6,0,0);glVertex3i(0,6,0);glVertex3i(0,0,6);
   glEnd();
  glColor4f(1.0,1.0,0.2,0.7);
   glBegin(GL_POLYGON);
  glVertex3i(3,0,0);glVertex3i(0,0,3);glVertex3i(0,7,3);glVertex3i(3,7,0);
   glEnd();
  glFlush();
  SwapBuffers(hdc);
}
</pre></div></div></div>
Keï pred spustením meníme inicializaèné hodnoty uholx, uholy, tak môme vidie ako sa mení poloha vykreslovanıch objektov.
<br>Skúste sami zmeni program, aby bral hodnoty z Editov a tlaèídkom to vykreslíte
<br><br>Teraz to ukáem ako spustíme otáèanie okolo zvislej osi
(všetko necháme tak ako v predošlom prípade, len pridáme èasovaè, ktorı bude meni uholy, prípadne aj uholx)
<div style="border-width:3;border-style:outset;width:690px;margin:10px;background-color:#dddddd;">
<div align="left" style="background-color:#3366ff; width:690px; padding:0;border-width:0;color:white">Unit1.cpp
</div>
<div style="background-color:#dddddd; width:690px;" >
<div style="margin:10px">
<pre>
void __fastcall TForm1::Timer1Timer(TObject *Sender)
{
//  uholx:=(uholx+2) mod 360;
   uholy=(uholy+1) % 360;
   ogl_draw();
}
</pre></div></div></div>
A predsa sa toèí :-)
<br><br>
Inı spôsob ako zvırazni, e ide o 3D priestor spoèíva v tom, e necháme uívate¾a aby si myšou natáèal priestor pod¾a svojich potrieb. Èasovaè je tu ponechanı aby sa okno prekrytím, alebo zbalením dole samo "opravilo".
	<br>Rotácia sa bude vykonáva ošetrovaním udalostí 
	<br>OnMousedown - tu si zapíšeme, kde sa to stalo a premennú mdole nastavíme na 1
	<br>OnMouseUp - tu zapíšeme do premennej mdole 0 a vypoèítame nové základné otoèenie uholx0 a uholy0 
	<br>OnMouseMove - tu pod¾a pohybu myši urèíme o ko¾ko treba treba otoèi okolo osi y a ko¾ko okolo x
	<div style="border-width:3;border-style:outset;width:800px;margin:10px;background-color:#dddddd;">
<div align="left" style="background-color:#3366ff; width:800px; padding:0;border-width:0;color:white">Unit1.cpp
</div>
<div style="background-color:#dddddd; width:690px;" >
<div style="margin:10px">
<pre>
int uholx=30, uholy=30, mx,my,uholx0=30, uholy0=30;

void __fastcall TForm1::Timer1Timer(TObject *Sender)
{
   ogl_draw(); //len na vykreslovanie, èi sme myšou pohli alebo nie
}

void __fastcall TForm1::dole(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
  mx=X; my=Y;
}
//---------------------------------------------------------------------------

void __fastcall TForm1::pohzb(TObject *Sender, TShiftState Shift, int X, int Y)
{
  if (Shift.Contains(ssLeft))
  {
  uholx=uholx0-(my-Y) / 2; uholy=uholy0-(mx-X) / 2;
  }
}
//---------------------------------------------------------------------------

void __fastcall TForm1::hore(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
{
  uholx0=uholx;     uholy0=uholy;
}
</pre></div></div></div>
a vısledok by mohol vyzera nasledovne
<br><img src="obr/u1.png" width="692" height="460" border="0" alt="">
<br>obrázok mono chytením myšou otáèa okolo osi x (vodorovnej osi) a okolo osi y (zvislá os)		
<br><br>A teraz ešte pridáme zväèšovanie. Zväèšova budeme ošetrovaním udalosti 
<br>OnMouseWheelDown (potoèil kolieèkom nadol)
<br>OnMouseWheelUp (potoèil kolieèkom nahol)
<div style="border-width:3;border-style:outset;width:690px;margin:10px;background-color:#dddddd;">
<div align="left" style="background-color:#3366ff; width:690px; padding:0;border-width:0;color:white">Unit1.pas
</div>
<div style="background-color:#dddddd; width:690px;" >
<div style="margin:10px">
<pre>
double koef=1;
void TForm1::ogl_draw()
{ glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
//tu zadávame príkazy na kreslenie
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glScaled(koef,koef,koef);
  glRotatef(uholx,1,0,0);
  glRotatef(uholy,0,1,0);

  glColor4f(1.0f, 1.0f, 1.0f,1.0f);
  glBegin(GL_LINES);
  glVertex3i(0,0,0);glVertex3i(7,0,0);
  glVertex3i(0,0,0);glVertex3i(0,7,0);
  glVertex3i(0,0,0);glVertex3i(0,0,7);
   glEnd();
   glBegin(GL_TRIANGLES);
  glColor3f(0.5,0.5,1.0);
  glVertex3i(6,0,0);glVertex3i(0,6,0);glVertex3i(0,0,6);
   glEnd();
  glColor4f(1.0,1.0,0.2,0.7);
   glBegin(GL_POLYGON);
  glVertex3i(3,0,0);glVertex3i(0,0,3);glVertex3i(0,7,3);glVertex3i(3,7,0);
   glEnd();

  glFlush();
  SwapBuffers(hdc);
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Timer1Timer(TObject *Sender)
{
   ogl_draw();  //pouívame len na vykreslovanie
}
//---------------------------------------------------------------------------
void __fastcall TForm1::kolieskodole(TObject *Sender, TShiftState Shift,
      TPoint &MousePos, bool &Handled)
{
   koef/=1.05;
}
//---------------------------------------------------------------------------
void __fastcall TForm1::kolieskohore(TObject *Sender, TShiftState Shift,
      TPoint &MousePos, bool &Handled)
{
     koef*=1.05;
}
</pre></div></div></div>
<br>
<dt>Kreslíme druhı obrázok
<dd>Našou úlohou bude vykresli pravidelnı šesbokı ihlan, ktorı má podstavu v rovine xy a poèiatok súradnej sústavy je v jeho strede.
    Vrcholy ihlana na podstave budú ma postupne farbu (r,rg,g,gb,b,rb) a vrchol ihlana bude farby 0 (èierna).
	<ol><li>Vytvoríme si štruktúry na zadanie súradníc a farby vrcholov, niektoré hodnoty vieme zada priamo no súradnice vrcholov
			podstavy radšej vypoèítam vo FormCreate. 
			<div style="border-width:3;border-style:outset;width:690px;margin:10px;background-color:#dddddd;">
			<div align="left" style="background-color:#3366ff; width:690px; padding:0;border-width:0;color:white">Unit1.pas
			</div>
			<div style="background-color:#dddddd; width:690px;" >
			<div style="margin:10px">
<pre>
  single vrcholy[7][6]=((0,0,0,1,0,0),(0,0,0,1,1,0),(0,0,0,0,1,0),
  							  (0,0,0,0,1,1),(0,0,0,0,0,1),(0,0,0,1,0,1),(0,0,0,0,0,0); 	
//x,y,z,r,g,b							  
void __fastcall TForm1::FormCreate(TObject *Sender)
{
  for (int i=0;i<6;i++)
  {  vrcholy[i][0]=cos(i*60/180*3.1415);
     vrcholy[i][2]=sin(i*60/180*3.1415);
  }
}  
</pre>
</div></div></div>
		<li>Teraz si pripravím štruktúru pre zadávanie stien, kadá stena je urèená poradím vrcholov, ktoré ju tvoria.
			<br>Naplnenie som riešil priamo v deklarácii.
				<div style="border-width:3;border-style:outset;width:690px;margin:10px;background-color:#dddddd;">
<div align="left" style="background-color:#3366ff; width:690px; padding:0;border-width:0;color:white">Unit1.pas
</div>
<div style="background-color:#dddddd; width:690px;" >
<div style="margin:10px">
<pre>
  int steny[6][3]=((1, 2, 7),(2, 3, 7),(3, 4, 7),(4, 5, 7),(5, 6, 7),(6, 1, 7)));
</pre>
</div></div></div>
		<li>vykreslovanie bude robi Timer (interval som volil 20ms)
			<div style="border-width:3;border-style:outset;width:690px;margin:10px;background-color:#dddddd;">
			<div align="left" style="background-color:#3366ff; width:690px; padding:0;border-width:0;color:white">Unit1.pas
			</div>
			<div style="margin:10px">
<pre>
void TForm1::ogl_draw()
{ glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
//tu zadávame príkazy na kreslenie
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glScaled(koef,koef,koef);
  glRotatef(uholx,1,0,0);
  glRotatef(uholy,0,1,0);
  for (s=0;i&lt;6;s++)
  {
    glBegin(GL_Triangles);
    for( v=0;v&lt;3;v++)
	{ i=steny[s][v];
      glColor(vrcholy[i][3], vrcholy[i][4], vrcholy[i][5]);
      glVertex(vrcholy[i][0], vrcholy[i][1], vrcholy[i][2]);
    }
    glEnd;
  }
  SwapBuffers(DC);
  }
//---------------------------------------------------------------------------
void __fastcall TForm1::Timer1Timer(TObject *Sender)
{
  Uhol:=Uhol+1;ogl_draw();
}
</pre>
</div></div></div>
<br>A po spustení by to vyzeralo asi takto
<br><img src="obr/u2.png" width="512" height="524" border="0" alt="">
	</ol>
</body>
</html>
