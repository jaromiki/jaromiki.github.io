<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	 <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1250">
 	 <meta name="Content-language" content="sk">	
	  <LINK href="../css/style.css" type="text/css" rel=stylesheet>
	  <style>
	  code {color:green; font-weight:700;}
	  </style>
</head>

<body>
<h3 class="main"><b>priority_queue</b></h3>
Priority_queue je objekt na doèasné odloenie nejakej hodnoty a jej opätovné získanie, prièom najväèší prvok je vdy navrchu. 
Na zisovanie poradia prvkov je pouitá porovnávacia funkcia, v prípade potreby mono vytvori svoju porovnávaciu funkciu
<br>bool moja_f(typ a, typ b)
<br>ktorá vráti pravdu ak <b>a</b> je pred <b>b</b>. (takto mono napr. urobi opaèné poradie v halde)
<br>Napr.
<br>¼udia vchádzajú do èakárne a majú èasenku na nejakı èas a nahlásia ten èas, systém vdy vie kto prvı pôjde ku lekárovi.
<br>K dispozícii máme hlavne operátory: back, push, pop. Implementácia je haldou umiestnenou vo poli/vektore.
<dl><dt>pripnutie kninice
		<dd>Aby sme mohli pouíva haldu musíme pripnú príslušnú kninicu
			<br><b>#include &lt;queue></b>
			<br>Po pripnutí môme zaèa pouíva objekty popísané v tejto kninici a teraz si základ popíšeme.
	<dt>deklarácia
	<dd>Je úplne podobné ako pri deklarácii po¾a.
		<ul><li>priority_queue &lt;typ> v1; //vytvorí prázdnu haldu
			<li>priority_queue &lt;typ> v2(iterátor1, iterátor2); //prvky z nejakého objektu (pole, vektor, list) vloí do haldy
			<li>priority_queue &lt;typ, vector&lt;typ>, porov_funkcia> v3;
				<br> &nbsp; //druh7 parameter urèuje, v èom bude halda implementovaná (necha vector)
				<br> &nbsp; //tretí parameter urèuje, porovnávaciu fukciu
				<br> &nbsp; &nbsp; &nbsp;// napr. preddefinovaná f. greater&lt;int&gt; urobí v halde celıch èísel opaèné poradie
				<br> &nbsp; &nbsp; &nbsp;//ale môme da aj svoju (u skôr zadefinovanú)
		</ul>
	<dt>èlenské funkcie
	<dd><ul><li><b>size()</b>; // vráti poèet prvkov vo fronte v konšt. èase
			<li><b>empty();</b> // funkcia vráti TRUE ak je halda prázdna
			<li><b>push(hodnota)</b>; //vloí hodnotu do haldy O(ln n)
			<li><b>pop()</b>; // odstráni hodnotu z vrchola haldy (najväèšiu) O(ln n)
			<li><b>top()</b>; // vráti hodnotu z vrchola haldy
			<li><b>swap()</b>; // vymení obsah dvoch háld v konšt. èase
		</ul>	
	<dt>Jednoduchá ukáka
	<dd>	
	<table border="3">
	<tr><th width="550">Zadanie<th>Riešenie</tr>
	<tr><td><pre>
    Máme vrece èísel, ktoré je na zaèiatku prázdne. Postupne s vrecom robíme nasledovné: buï do neho nejaké
èíslo vloíme, alebo z neho vyberieme najväèšie èíslo. Po kadej operácii chceme vedie, aké najväèšie èíslo sa
vo vreci nachádza (ak nie je vrece prázdne).

<b>Vstup</b>
Prvı riadok obsahuje poèet operácii n. Platí 1 &lt;= n &lt;= 2*10^5.
Nasleduje n riadkov, i-ty z nich popisuje i-tu operáciu a má tvar t x. Ak t je 0, tak z vreca vyberáme
najväèšie èíslo a x ignorujeme. Ak t je 1, tak do vreca vkladáme èíslo x. Platí |x| &lt;= 10^9.
Je zaruèené, e z vreca vyberáme iba ak nie je prázdne.

<b>Vıstup</b>
Na i-ty riadok vypíšte jedno celé èíslo: najväèšie èíslo nachádzajúce sa vo vreci po i-tej operácii. Ak je po
i-tej operácii vrece prádzne, vypíšte namiesto toho ‘empty‘. 
</pre><td><pre>
#include &lt;iostream>
//#include &lt;vector>
#include &lt;queue>
using namespace std;
priority_queue &lt;long> h;
long n,m,t,i,x;
int main(int argc, char* argv[])
{  cin  >>n;
   for(i=0;i&lt;n;i++)
   {  cin >>t>>x;
      if (t) h.push(x);
      else  if (!(h.empty()))  h.pop();
      if (h.empty()) cout &lt;&lt; "empty"&lt;&lt;endl; else cout &lt;&lt; h.top()&lt;&lt;endl;
   }
//   system("pause");   
        return 0;
}</pre>
    </tr>
    </table>
	<dt>porovnávacia funkcia
	<dd>Halda je implicitne objekt pre prvky ktoré je moné porovnáva/utriedi a vdy má max. prvok navrchu. Niekedy však potrebujeme
	zvoli iné porovnávacie kritérium (napríklad chceme ma navrchu èíslo najmenšie alebo napr. èíslo s najväèšou poslednou cifrou)
	a je dobré vedie ako realizova. Navyše niekedy môeme chcie do haldy vklada prvky, ktoré ani porovnáva nevieme (štruktúry a pod.)
	<br>Tu si ukáeme, ako zavies porovnávaciu funkciu
	<br>Nech do cakarne chodia pacienti a o kadom evidujeme 
	<br>- stav - tu je zapisany stupen choroby (cim väèšie èíslo tım je viac chorı)
	<br>- pc - poradové èíslo príchodu - kadı pacient dostane po príchode jedineèné èíslo 1,2,3, ...
	<br>- meno - meno pacienta
	<br>Na vstupe je postupnos riadkov riadky môu by tvorené 0, -1,meno stav
	<br> 0 ... koniec programu
	<br>-1 ... pacient s najväèšou chorobou ide k lekárovi (v prípade rovnosti ide pacient s menším èíslom pc)
	<br>meno, stav ... do èakárne pridáme ïalšieho pacienta
	<br>-----------------------------------------------------
	<br>Pacienta budem zapisova do štruktúry typu Tpacient
	<code>
	<br>typedef struct { string meno; long stav; long pc;} Tpacient;   
	</code>
	<br>Èakáreò bude reprezentovaná haldou s prvkami typu Tpacient
	<br><code>
	priority_queue &lt;Tpacient, vector&lt;Tpacient>, bool (*)(Tpacient,Tpacient)> h(compare);
	</code>
	<br>Poznámky:
	<br>Ak chcem do haldy zada svoju porovnávaciu funkciu musím uvies, e halda bude zapísaná v objekte vector (vector&lt;Tpacient>)
	<br>3. parameter musí by popísaná porovnávacia funkcia (typ musí by bool, parametre musia by typu akı je pouitı v halde 
	<br>za názvom objektu typu halda v okrúhlych zátvorkách musí by názov funkcie popísanej vyššie
	<br>-----------------------------------------------------
	<br>Porovnávacia funkcia múe vyzera nejak takto:
	<br><code>bool compare(Tpacient a, Tpacient b)
	<br>{return (a.stav == b.stav? a.pc>b.pc : a.stav &lt; b.stav);} </code>
	<br><br>Ak porovnávacia funkcia vracia TRUE ak prvı parameter funcie je menší ako druhı bude navrchu haldy maximum
	<br>Ak porovnávacia funkcia vracia TRUE ak prvı parameter funcie je väèší ako druhı bude navrchu haldy minimum
	<br>Ak je stav rovnakı rozhodne pc (navrchu bude min) inak rozhodne stav (navrchu bude max)
	<br>Ukáka
	<table border="3">
	<tr><th width="600">Zadanie<th>Riešenie</tr>
	<tr><td>
	V Nalomenej Trieske majú zdravotné stredisko. V tomto zimnom období doòho prichádza ve¾a pacientov.
Dennodenne si niekto vytkne èlenok alebo zlomí nohu. V škole vyhlásili chrípkové prázdniny. Hrozí chrípková
epidémia. Aj choroba šialenıch tiav vyèíòa ako besná...
V zdravotnom stredisku na pohotovosti nepretrite ordinuje jeden doktor. Èakáreò plná a noví pacienti
prichádzajú a prichádzajú... A kadému treba pomôc – ale komu skôr? Na tejto pohotovosti to riešia tak, e
vdy, keï doktor ošetrí jedného pacienta, sestrièka zavolá z èakárne dnu toho, kto vyzerá by najviac chorı. (Ak
je takıch pacientov viac, tak toho z nich, ktorı èaká najdlhšie.)
Tvojou úlohou je spravi simuláciu zdravotného strediska. Na zaèiatku je èakáreò prázdna. Tvoj program má
postupne spracováva tieto príkazy: 
<dl><dt class="nic">pacient cislo stav 
<dd>– do èakárne prišiel novı pacient, jeho evidenèné èíslo je <b>cislo</b> a èíslo <b>stav</b> udáva, ako chorı tento pacient vyzerá (èím je väèšie, tım viac je pacient chorı). 
Obe èísla sú nezáporné celé a neprevyšujú 1 000 000 000. 
<dt class="nic">dalsi 
<dd>– do ordinácie má ís ïalší pacient. 
<dt class="nic">koniec 
<dd>– na dnes konèíme, odteraz má slubu pohotovos na opaènom konci mesta, presuòte sa tam.
</dl>
<br><b>Vstup</b><br>
Vstup obsahuje nieko¾ko riadkov, v kadom z nich je jeden z vyššie popísanıch príkazov. Môeš predpoklada,
e iadni dvaja pacienti nemajú rovnaké evidenèné èíslo. Príkazov bude vo vstupnom súbore najviac 250 000.
<br><b>Vıstup</b><br>
Vdy, keï preèítaš zo vstupu príkaz dalsi, vypíš jeden riadok a v òom evidenèné èíslo pacienta, ktorı sa
práve dostal do ordinácie. V prípade, e je èakáreò práve prázdna, namiesto èísla pacienta vypíš -1.
	<td><pre>
#include &lt;iostream>
#include &lt;queue>
#include &lt;string>
using namespace std;
typedef struct { long pc;    long stav; int i;
               } Tpacient;
bool compare(Tpacient a, Tpacient b)
{return (a.stav == b.stav? a.i>b.i : a.stav &lt; b.stav);}

priority_queue &lt;Tpacient, vector&lt;Tpacient>, bool (*)(Tpacient,Tpacient)> h(compare);
string s;
long pc,stav,i;
Tpacient p;
int main(int argc, char* argv[])
{   do
    {  cin >>s;
       if (s == "dalsi")
       {  if (h.empty()) cout &lt;&lt;-1&lt;&lt;endl;
          else
          { p=h.top();
            cout &lt;&lt; p.pc &lt;&lt; endl;
            h.pop();
          }
       }
       else if (s == "pacient")
            { cin >>p.pc>>p.stav;
              p.i=i++;
              h.push(p);
            }
    }
    while (s != "koniec");
        return 0;
}	
</pre></tr>
<tr><th>vstup<th>vıstup</tr>
<tr>
<td>
<pre>
dalsi
pacient 1 10
pacient 2 2
pacient 3 5
dalsi
pacient 17 0
pacient 999 100
dalsi
pacient 13 5
dalsi
koniec</pre>
<td>
-1<br>
1<br>
999<br>
3
</tr>
	</table>

</dl>			



</body>
</html>
