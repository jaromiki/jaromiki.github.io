<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	 <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1250">
 	 <meta name="Content-language" content="sk">	
	  <LINK href="../css/style.css" type="text/css" rel=stylesheet>
	 <title>Úvod</title>
</head>

<body>
<h3 class="main">Usporiadané mnoiny - <b>set</b></h3>
Mnoina je takı objekt o ktorom pre ¾ub. prvok vieme rozhodnú èi patrí alebo nepatrí do mnoiny. Prvky mnoiny sú jedineèné a po vloení do štruktúry nemenné (mono ale ruši prvky a vsúva).
<br>Oproti matematike, kde je tie objekt mnoina, tu máme niektoré rozdiely:
<br>prvky mnoiny/set sú rovnakého typu (presnejšie ak sú prvkami triedy, musia ma spoloèného predka)
<br>prvky sú vdy usporiadané
Vlastnosti objektu set:
<ul><li>Prvky objektu set sú vdy usporiadané
	<li>Vieme pridáva/ruši prvky v log. èase
	<li>Vieme h¾ada prvok v set s èasovou zloitosou log n
		<br>Ak budeme potrebova zisti, èi se nejakı prvok nacháza v mnoine pouijeme metodu count(), která vráti 0, ak sa prvok v mnoinì nenachádza, inak vráti 1. 
		<br>Táto metóda vlastne vracia poèet prvkov v mnoine, èo je 0, alebo 1.
	<li>Vieme urobi prechod cez všetky prvky mnoiny
	<li>nemáme priamy prístup ku prvkom (iterátor mono meni operátormi ++, --)
	<li>Prvky v sete sa nedajú meni
	<li>Implementácia je binárne usporiadanım stromom (samovyvaovacie stromy)
</ul>	
<dl><dt>pripnutie kninice
		<dd>Aby sme mohli pouíva obojstranné zoznamy musíme pripnú príslušnú kninicu
			<br><b>#include &lt;set></b>
			<br>Po pripnutí môme zaèa pouíva objekty popísané v tejto kninici a teraz si základ popíšeme.
	<dt>deklarácia
	<dd>Je úplne podobné ako pri deklarácii po¾a.
		<ul><li>set &lt;int> v1; //vytvorí prázdny set
			<li>set &lt;int> v1(iterator1, iterator2); //iterátory môu by ukazovatele na prvky po¾a, vektora, listu
				<br> &nbsp; &nbsp; &nbsp;(prvky okopíruje z nejakého iného objektu)
			<li>set &lt;int> v1(set); //kópia iného set (pravdepodobne mono da aj inı typ)
			<li>set &lt;typ, adresa_porovnávacej_funkcie>; // ak pre prvky nie je definovaná operácia porovnania &lt;, môme ju tu zada
		</ul>	
	<dt>èlenské funkcie
	<dd><ul><li><b>size()</b>; // vráti poèet prvkov v mnoine
			<li><b>begin();</b> //funkcia vráti iterátor na prvı prvok
			<li><b>end();</b> //funkcia vráti iterátor na poslednı prvok
			<li><b>rbegin();</b> //funkcia vráti reverznı iterátor na prvı prvok (èie poslednı prvok - pozri iterátory)
			<li><b>rend();</b> //funkcia vráti iterátor na poslednı prvok (èie prvı prvok - pozri iterátory)

			<li><b>clear();</b> //podprogram, ktorı vymae všetky prvky mnoiny 
			<li><b>count(x);</b> //funkcia vráti poèet vıskytov prvku x (0 alebo 1) v log èase
			<li><b>empty();</b> // funkcia vráti TRUE ak jew set prázdny
			<li><b>find(x);</b> //funkcia vráti iterátor na nájdenı prvok, ak prvok nenájde vráti iterator end (log n èas)
			<li><b>erase(iterator);</b> //odstráni tento prvok (konšt. èas)
			<br><b>erase(iterator1, iterator2);</b> //odstráni prvky z intervalu
			<br><b>erase(hodnota);</b> //odstráni hodnotu zo setu
			<li><b>insert(hodnota);</b> //pridá hodnotu do set (ak sa u nachádza neurobí niè), robí v log n èase
				<br>návratová hodnota je pair, kde prvá hodnota je iterátor na novopridanı prvok a druhá je TRUE ak sa pridanieè uskutoènilo (pozri pair)
			<br><b>insert(iterator, hodnota);</b> //urèíme miesto kam sa má vloi, ak je miesto korektné vloí v konštantnom èase, inak vkladá logaritmicky
			<br><b>insert(iterator1,iterator2);</b> // vkladá z inıch objektov (pole, list, vector)
			
			<li>operátor = ... priraïovanie objektov set je moné, prekopíruje obsah, upraví size
			<li><b>swap(set)</b>; //vymení obsah dvoch setov
	<dt>Operácie s mnoinou v kninici algorithm
	<dd>
	<ul><li>set_intersection(mnoina1_zaèiatok,mnoina1_koniec,mnoina2_zaèiatok,mnoina2_koniec,mnoina3_zaèiatok)
			<br>urobí prienik mnoín 1 a 2 do mnoiny 3 a zapíše do mnoiny od urèeného iterátora.
			<br>návratová hodnota je ukazovate¾ na koniec štruktúry (pri mnoine nepotrebujem)
			<br>je vhodné vıstupnú mnoinu pred volaním najprv vyprázdni erase();
			<br>mnoina3_zaèiatok .. tu je dos ve¾kı problém, ak vytvoríme obyèajnı iterátor, tak po spustení padne
				<br>musíme vytvori insert_iterator&lt;set&lt;int> > iter(v,v.begin());
				<br>ktorı nie je konštantnı a môe by vıstupnım parametrom
			<pre>
#include &lt;iostream>
#include &lt;set>
#include &lt;algorith>

using namespace std;
int main ()
{
  int myints[] = {75,23,65,42,13};
  int myints2[] = {75,20,65,40,13};
  std::set&lt;int> myset (myints,myints+5) ;
  std::set&lt;int> myset2 (myints2,myints2+5) ;
  std::set&lt;int> v;

  std::set&lt;int>::iterator it=v.begin();
  insert_iterator&lt;set&lt;int> > iter(v,v.begin());
set_intersection(myset.begin(),myset.end(),myset2.begin(),myset2.end(),iter); //nemono poui it ako 5-ty parameter 
cout &lt;&lt; v.size();  system("pause");

  std::cout &lt;&lt; "myset contains:";
  for (it=v.begin(); it!=v.end(); ++it)
    std::cout &lt;&lt; ' ' &lt;&lt; *it;

  std::cout &lt;&lt; '\n';
  system("pause");
  return 0;
}</pre>			
		<li>set_union(mnoina1_zaèiatok,mnoina1_koniec,mnoina2_zaèiatok,mnoina2_koniec,mnoina3_zaèiatok)
			<br>urobí zjednotenie mnoín 1 a 2 do mnoiny 3 a zapíše do mnoiny od urèeného iterátora.
			<br>je vhodné vıstupnú mnoinu pred volaním najprv vyprázdni erase();
			<br>návratová hodnota je ukazovate¾ na koniec štruktúry
			<pre>
#include &lt;iostream>
#include &lt;set>
#include &lt;algorith>

using namespace std;
int main ()
{
  int myints[] = {75,23,65,42,13};
  int myints2[] = {75,20,65,40,13};
  std::set&lt;int> myset (myints,myints+5) ;
  std::set&lt;int> myset2 (myints2,myints2+5) ;
  std::set&lt;int> v;

  std::set&lt;int>::iterator it=v.begin();
  insert_iterator&lt;set&lt;int> > iter(v,v.begin());
set_union(myset.begin(),myset.end(),myset2.begin(),myset2.end(),iter); //nemono poui it ako 5-ty parameter 
cout &lt;&lt; v.size();  system("pause");

  std::cout &lt;&lt; "myset contains:";
  for (it=v.begin(); it!=v.end(); ++it)
    std::cout &lt;&lt; ' ' &lt;&lt; *it;

  std::cout &lt;&lt; '\n';
  system("pause");
  return 0;
}</pre>			
		<li>set_difference(mnoina1_zaèiatok,mnoina1_koniec,mnoina2_zaèiatok,mnoina2_koniec,mnoina3_zaèiatok)	
			<br>urobí rozdiel mnoín 1 a 2 do mnoiny 3 a zapíše do mnoiny od urèeného iterátora.
			<br>návratová hodnota je ukazovate¾ na koniec štruktúry
	<dt>Príklady
	<dd><ul>
		<li>Na vstupe máme nieko¾ko celıch èísel z &lt;-10 000, +10 000> zisti ko¾ko rôznych èísel tam je
		<li>Janka a Danka sú sestry, Janka má v Memo1 zapísané svoje kamarátky, Danka má svoje kamarátky v Memo2
			<br>Obidve si na oslavu zavolajú všetky svoje kamarátky
			<br>U1: ko¾ko kamarátok príde na oslavu
			<br>U2: ko¾ko majú spoloènıch kamarátok
			<br>U3: ko¾kım kamarátkam môe Janka prezradi nieèo, èo sa nemá dozvedie iadna kamarátka Danky)
			<br>(ak majú kamarátky rovnaké meno berieme, e ide o tú istú osobu
		</ul>

	
</dl>
</body>
</html>
