<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	 <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1250">
 	 <meta name="Content-language" content="sk">	
	  <LINK href="../css/style.css" type="text/css" rel=stylesheet>
	 <title>Vector</title>

</head>

<body>
<dl>
<dt class="main">vector - dynamické polia
<dd>Táto štruktúra je realizovaná dynamickım po¾om, a teda pouitie vektora je obdobné ako pri poli. Tımto vytvoríme štruktúru do ktorej mono sekvenène zapísa
	viacero hodnôt a máme k polokám priamy prístup cez index (ale získame aj ïalšie monosti, ktoré ïalej popíšem). Zvyèajne je size po¾a definovaná pri preklade, 
	je to tak najefektívnejšie (najrıchlejšie) ale môme aj meni pod¾a potrieb programu. Na sledovanie rozmeru po¾a/vektora v pamäti sú  dve hodnoty:
	<ul><li><b>capacity()</b> - tu je zapísané pre ko¾ko prvkov sme pre vektor alokovali (skutoènı alokovanı priestor - väèšinou nás nezaujíma)
		<li><b>size()</b> - tu je zapísané ko¾ko prvkov má skutoène náš vektor 
	</ul>
	<b>size</b> je vdy menšie alebo rovné ako capacity, ak sa size zväèší/zmenší capacity sa nemusí ale aj môe zmeni. Size môme v programe meni=nastavova, capacity nie.
	<br>Popíšem hlavné vıhody vektora oproti po¾u:
	<ul><li>vdy vieme aktuálnu ve¾kos po¾a
		<li>môme vektory priraïova, porovnáva , èo s po¾om nejde
		<li>u pri vytvorení èíselného vektora môe by nastavené na nejakú hodnotu (èo pri ve¾kıch poliach je nemoné)
		<li>môme meni ve¾kos vektora v pamäti pod¾a potrieb
	</ul>	
	<br>V STL je vektor, ako aj iné objekty, popísanı ako šablóna (spôsob zápisu/tvorby šablón je zloitejší), ale my sa tejto téme vyhneme a ukáeme si len
	ako takúto štruktúru zadefinova:
<dt>pripnutie kninice
<dd>Aby sme mohli pouíva vektory musíme pripnú príslušnú kninicu:
	<br><b>#include &lt;vector></b>
	<br>Po pripnutí môme zaèa pouíva objekty popísané v tejto kninici a teraz si základ popíšeme.
<dt>deklarácia
<dd><ul><li>vector &lt;int&gt; nazov1; &nbsp; &nbsp; &nbsp;//vytvorí celoèíselnı vektor <b>nazov1</b> nulovej dåky (prázdny)
		<li>vector &lt;float&gt; nazov2(10); &nbsp; &nbsp; &nbsp;//vytvorí reálny vektor <b>nazov2</b> dåky 10 poloiek 
		<li>vector &lt;char&gt; nazov3(100, '*'); &nbsp; &nbsp; &nbsp;//vytvorí char vektor <b>nazov3</b> dåky 100 poloiek inicializovanıch na hodnotu '*' 
		<li>vector &lt;nazov1&gt; nazov4(10); &nbsp; &nbsp; &nbsp;//vytvorí vektor <b>nazov4</b> dåky 10 poloiek, kadá poloka je vektor
	</ul>	
	Typ prvkov vectora môe by aj štruktúrovanı (napr. opä vector), je popísané nišie.
	<br>Na prístup ku prvkom sa pri štruktúrach èasto pouívajú iterátory. Iterátor môe by konštantnı (vektor.begin() ), ktorı nemono meni.
	Ak chceme pouíva iterátory, ktoré mono meni, musíme si vytvori odpovedajúcu premennú. Jej deklarácia pri štruktúre vector je nasledovná:
	<br>vector &lt;int&gt; ::iterator it1; &nbsp; &nbsp; &nbsp;//vytvorí ukazovate¾ na vektor intov (it1), zatia¾ neukazuje nikam
	<br>vector &lt;int&gt; ::iterator it2 = nazov2.begin(); &nbsp; &nbsp; &nbsp;//vytvorí ukazovate¾ na vektor intov (it2), ukazuje na zaèiatok 
	<br>(v it2 je nieèo ako adresa, kde sú údaje)
	<br>(*it2 - ak dáme pred iterátor hviezdièku získame prístup ku poloke po¾a, napr. *it2=10; //zapise do uvodného prvku po¾a 10
<dt>èlenské funkcie
<dd><ul><li>konštruktor - je volanı pri deklarácii vektora, tu si ukáeme aké monosti pri deklarácii máme
			<ul><li>vector&lt;int> v1; &nbsp; &nbsp; &nbsp;//vytvorí celoèíselnı vektor <b>v1</b> nulovej dåky (prázdny)
				<li>vector&lt;int> v2(5);  &nbsp; &nbsp; &nbsp;//vytvorí celoèíselnı vektor <b>v2</b> o poète poloiek 5
				<li>vector&lt;int> v3(5,100);  &nbsp; &nbsp; &nbsp;//vytvorí celoèíselnı vektor <b>v3</b> o poète poloiek 5 s hodnotou 100
				<li>vector&lt;int> v4(v2.begin(),v2.end());  &nbsp; &nbsp; &nbsp;//vytvorí celoèíselnı vektor <b>v4</b> okopíruje vektor v2 s udaním hraníc
				<li>vector&lt;int> v5(v3);  &nbsp; &nbsp; &nbsp;//vytvorí celoèíselnı vektor <b>v5</b> okopíruje vektor v3 
				<li>int a[]={1,11,21};
					<br>vector&lt;int> v6 (a, a + sizeof(a)/sizeof(int) );&nbsp; &nbsp; &nbsp;//okopíruje prvky z po¾a
					<br>myšlienka je podobná ako pri v4
			</ul>
		<li>deštruktor - je volanı ak chceme vektor z pamäte úplne odstráni
		<li><b>operátor =</b> kopírovanie jedného vektora do iného, súèasne sa prispôsobí ve¾kos. Teda vektory mono priraïova podobne ako v pascale polia. 
		<li><b>operátor ==</b> porovnávanie dvoch polí, dve polia sú rovné, ak majú rovnaké size a všetky poloky majú rovnakú hodnotu (capacity nemusí by rovnaké)
			<br> &nbsp; &nbsp; &nbsp; != porovnávanie dvoch polí
			<br> &nbsp; &nbsp; &nbsp; &lt; lexikografické porovnávanie dvoch polí
			<br> &nbsp; &nbsp; &nbsp; &gt; lexikografické porovnávanie dvoch polí
		<li><b>operátor []</b> ... na prístup ku polokám po¾a (index by mal by od 0 po (size-1) ), nekontroluje, èi index nevybehol z po¾a
		<li><b>at(index)</b> ... metóda, ktorá sprístupní poloku po¾a cez index, napr. v5.at(2) = 10; //kontroluje, èi sme vo vektore 
		<li><b>size()</b> ... poèet prvkov,
			<br> &nbsp; &nbsp; &nbsp; cout &lt;&lt; (int)v1.size; //vráti 0
			<br> &nbsp; &nbsp; &nbsp; cout &lt;&lt; (int)v1.size; //vráti 0
		<li><b>resize(pocet)</b> ... podprogram, ktorı zmení size vektora (zadáme novı poèet prvkov). Capacity sa nemusí meni, ale môe.
			<br> &nbsp; &nbsp; &nbsp; v.resize(100); //zmení size na 100 prvkov
			<br> &nbsp; &nbsp; &nbsp; v.resize(10); //zmení size na 10 prvkov
		<li><b>capacity()</b> ... funkcia vráti pamä, ktorú vektor zaberá (capacity &gt;= size )
		<li><b>maxsize()</b> ... funkcia vráti pokade môe vektor rás (zadané v poète poloiek)
		<li><b>reserve(size)</b> ... asi jediná cesta ako urobi vector, ktorı má predpísanú capacity
			<br> &nbsp; &nbsp; vector&lt;int> vec; //vytvorenie prázdneho vektora
			<br> &nbsp; &nbsp; vec.reserve(100); //nastaví capacity na 100, size sa nemení
		<li><b>assign()</b> ... tie sa pouíva na okopírovanie jedného po¾a (alebo èasti) dp iného po¾a alebo môe zmeni size a naplni hodnotou
			<br> &nbsp; &nbsp; &nbsp; <b>v1.assign(iterátor1, iterátor2);</b> //od iterátora1 po iterátor2 zapíše do vektora v1, upraví size ak treba aj capacity po¾a v1
			<br> &nbsp; &nbsp; &nbsp; <b>v1.assign(n, hodnota);</b> //size nastaví na <b>n</b> a všetky nastaví na <b>hodnota</b>
		<li><b>clear()</b> ... zruší všetky prvky po¾a, size sa nastaví na 0 ale capacity sa nemusí zmeni (vektor môe naïalej dra pamä)
			<br> &nbsp; &nbsp; &nbsp; ak chceme aby sa pamä naisto uvo¾nila pouijeme nasledovnú "fintu" 
			<br> &nbsp; &nbsp; &nbsp; v2.swap(vector&lt;int>(foo)); //pozri swap
		
		<li><b>insert(iterator, hodnota)</b>; vloí pred prvok urèenı iterátorom hodnotu (prvky sa posunú, size sa zväèší)	
			<br><b>insert(iterator, poèet, hodnota)</b>; vloí pred prvok urèenı iterátorom  danı poèet prvkov o predpísanej hodnote
			<br><b>insert(iterator, vector2.iterator1, vector2.iterator2)</b>; vloí na miesto urèené iterátorom danı poèet prvkov z vektora/listu/po¾a
					
		<li><b>erase(vector.iterator)</b> //odstráni uvedenı prvok z po¾a, zmenší size o 1
			<br><b>erase(vector.iterator1, vector.iterator2)</b> //odstráni prvky z intervalu, upraví size	
		<li><b>empty()</b> ... logická funkcia - vráti TRUE ak je vektor prázdny (size ==0)

		<li><b>push_back(hodnota)</b> //zväèší pole o jeden prvok a zapíše doòho na koniec danú hodnotu	
						<br> &nbsp; &nbsp; &nbsp; napr.: v.push_back(10);
						<br>robí v konšt. èase, na pridávanie na iné miesta pouívame insert ale to u nerobí v konštantnom èase, ak chceme aj tu
						konštantnı èas pouijeme namiesto vector radšej deque alebo list
					
		<li><b>pop_back(hodnota);</b> //zruší poslednı prvok vektora
		<li><b>back(hodnota);</b> //funkcia vráti hodnotu posledného prvku
		<li><b>begin();</b> //funkcia vráti iterátor na prvı prvok
		<li><b>end();</b> //funkcia vráti iterátor na poslednı prvok
		<li><b>front();</b> //funkcia vráti hodnotu prvého prvku (v prípade prázdneho vekt. nie je definované správania)
		<li><b>back();</b> //funkcia vráti hodnotu posledného prvku (v prípade prázdneho vekt. nie je definované správania)
		<li><b>rbegin();</b> //funkcia vráti reverznı iterátor na prvı prvok (èie poslednı prvok - pozri iterátory)
		<li><b>rend();</b> //funkcia vráti iterátor na poslednı prvok (èie prvı prvok - pozri iterátory)
					
		<li><b>swap()</b> ... metóda na vımenu obsahu dvoch polí, ak sú rôzne size tak sa vymenia aj size 
			<br> &nbsp; &nbsp; &nbsp; èasová nároènos - konštantná 
		<li><b>data()</b> ... funkcia, ktorá vráti ukazovate¾ na pole dát patriace vektoru
			<br> &nbsp; &nbsp; &nbsp; int *pole;
			<br> &nbsp; &nbsp; &nbsp; vector&lt;int> a(10,5);
			<br> &nbsp; &nbsp; &nbsp; pole = a.data();
			<br> &nbsp; &nbsp; &nbsp; pole[5] = 50; // zmení 5-tu poloku vektora a
						
	</ul>
<dt>operácie pomocou algoritmov
<dd>Všetky tieto podprogramy mono poui jak na klasické pole, tak aj vektory po pripojení kninice <b>algorithm</b>.
	<ul><li><b>sort()</b>
			<br>vektor nemusíme triedi vlastnım programom, je vıhodnejšie poui hotovı algoritmus v unite algorithmus
			<br>ak pre prvky vektora existuje operátor menší (&lt;)	môme poui základnı tvar <b>sort(vector.iterator1, vector.iterator2)</b> a zvolená èas po¾a sa utriedi
			<br>ak chceme môme vytvori vlastnú porovnávajúcu funkciu, ktorá vráti TRUE, ak prvı parameter je menší ako druhı, inak vráti FALSE
			<br><b>sort(vector.iterator1, vector.iterator2, adresa_funkcie)</b>
			<table width="90%" border="1"><tr><td bgcolor="#6666ff">Project1</tr>
			<tr><td bgcolor="White">	
<pre>
// sort algorithm example
#include &lt;iostream>     // std::cout
#include &lt;algorithm>    // std::sort
#include &lt;vector>       // std::vector

bool myfunction (int i,int j) { return (i&lt;j); }

int main () 
{ int myints[] = {32,71,12,45,26,80,53,33};
  std::vector&lt;int> myvector (myints, myints+8);               // 32 71 12 45 26 80 53 33

  // using default comparison (operator &lt;):
  std::sort (myvector.begin(), myvector.begin()+4);           //(12 32 45 71)26 80 53 33

  // using function as comp
  std::sort (myvector.begin()+4, myvector.end(), myfunction); // 12 32 45 71(26 33 53 80)
  // print out content:
  std::cout &lt;&lt; "myvector contains:";
  for (std::vector&lt;int>::iterator it=myvector.begin(); it!=myvector.end(); ++it)
    std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';                                          // 12 26 32 33 45 53 71 80

  return 0;
}
</pre>
		</tr></table>
		<li><b>reverse()</b>
			<br>pomocou príkazu reverse môme otoèi pole (alebo jeho èas)	<b>reverse(vector.iterator1, vector.iterator2)</b>
			<br>vo vektore sa prvky od iterator1 po iterator2 preklopia 
		<table width="90%" border="1"><tr><td bgcolor="#6666ff">Project1</tr>
		<tr><td bgcolor="White">	
<pre>
// reverse algorithm example
#include &lt;iostream>     // std::cout
#include &lt;algorithm>    // std::reverse
#include &lt;vector>       // std::vector
using namespace std;
int main () {
  std::vector&lt;int> myvector(10);

  // set some values:
  for (int i=0; i&lt;10; ++i) myvector[i]=i;   // 1 2 3 4 5 6 7 8 9

  reverse(myvector.begin(),myvector.end());    // 9 8 7 6 5 4 3 2 1

  // print out content:
  cout &lt;&lt; "myvector contains:";
  for (int i=0; i&lt;10; i++) cout &lt;&lt; ' ' &lt;&lt; myvector[i];
  cout &lt;&lt; '\n';

  return 0;
}
</pre>
		</tr></table>
		<li><b>int count(iter1, iter2, hodnota)</b>, int count_if(iter1, iter2, funkcia) 
			<br>táto funkcia vráti poèet vıskytov prvku X vo vektore
			<br>funkcia musí ma práve jeden parameter, pre ktorı vytvára podmienku
		<table width="90%" border="1"><tr><td bgcolor="#6666ff">Project1</tr>
		<tr><td bgcolor="White">	
<pre>
// count algorithm example
#include &lt;iostream>     // std::cout
#include &lt;algorithm>    // std::count
#include &lt;vector>       // std::vector
using namespace std;
int fun(int x)
{return x>20;}
int main () {
  // pocet zadanych prvkov v poli:
  int myints[] = {10,20,30,30,20,10,10,20};   // 8 prvkov
  int mycount = std::count (myints, myints+8, 10);
  std::cout &lt;&lt; "10 sa vyskytuje " &lt;&lt; mycount &lt;&lt; " krat.\n";

  // pocet prvkov v poli splnajucich podmienku:
  std::vector&lt;int> myvector (myints, myints+8);
  mycount = std::count_if (myvector.begin(), myvector.end(), fun);
  std::cout &lt;&lt; ">20 sa vyskytuje " &lt;&lt; mycount  &lt;&lt; " krat.\n";
  return 0;
  // Output
  //10 appears 3 times.
  //20 appears 3 times.
}							
</pre>
		</tr></table>
		<li><b>find(vector.iterator1, vector.iterator2, hodnota)</b>
			<br><b>find_if(vector.iterator1, vector.iterator2, fun)</b>
				<br>H¾adá v poli zadanú hodnotu a vráti iterátor na prvú nájdenú
				<br>ak nenájde vráti vector.iterator2
		<li><b>fill(vector.iterator1, vector.iterator2)</b>
			<br>èas pole (alebo celé pole) zaplní predpísanou hodnotou
			<br>
		<li>generate (iter1, iter2, funkcia)
			<br>èas vektora zaplní predpísanou hodnotou pod¾a funkcie
			<br>funkcia nesmie ma parameter, môe pouíva premenné programu, ktoré vidí
			<br>napr. funkcia: int nahoda() {return 10+random(90);}
			<br> generate (myvector.begin(), myvector.end(), nahoda);
	
		<li><b>max_element(vector.iterator1, vector.iterator2)</b>; //funkcia vráti iterátor na prvı maximálny prvok
			<br><b>max_element(vector.iterator1, vector.iterator2, adresa_funkcie)</b>; // to isté ale predpíšeme porovnávaciu fukciu
			<br><b>min_element(vector.iterator1, vector.iterator2)</b>; //funkcia vráti iterátor na prvı maximálny prvok
			<br><b>min_element(vector.iterator1, vector.iterator2, adresa_funkcie)</b>; // to isté ale predpíšeme porovnávaciu fukciu
			<table width="90%" border="1"><tr><td bgcolor="#6666ff">Project1</tr>
			<tr><td bgcolor="White">	
<pre>
// min_element/max_element example
#include &lt;iostream>     // std::cout
#include &lt;algorithm>    // std::min_element, std::max_element
using namespace std;
bool myfn(int i, int j) { return i&lt;j; }

int main () 
{ int myints[] = {3,7,2,5,6,4,9};             //3,7,2,5,6,4,9
  vector&lt;int> v (myints, myints+7);   //3,7,2,5,6,4,9
  // using default comparison:
  cout &lt;&lt; "The smallest element is " &lt;&lt; *min_element(v.begin(),v.end()) &lt;&lt; '\n';
  cout &lt;&lt; "The largest element is "  &lt;&lt; *max_element(v.begin(),v.end()) &lt;&lt; '\n';
  cout &lt;&lt; "The smallest element is " &lt;&lt; *min_element(myints,myints+7) &lt;&lt; '\n';
  cout &lt;&lt; "The largest element is "  &lt;&lt; *max_element(myints,myints+7) &lt;&lt; '\n';
  // using function myfn as comp:
  cout &lt;&lt; "The smallest element is " &lt;&lt; *min_element(v.begin(),v.end(),myfn) &lt;&lt; '\n';
  cout &lt;&lt; "The largest element is "  &lt;&lt; *max_element(v.begin(),v.end(),myfn) &lt;&lt; '\n';
  cout &lt;&lt; "The smallest element is " &lt;&lt; *min_element(myints,myints+7,myfn) &lt;&lt; '\n';
  cout &lt;&lt; "The largest element is "  &lt;&lt; *max_element(myints,myints+7,myfn) &lt;&lt; '\n';
  return 0;
}							
</pre>
    		</tr></table>
			<li><b>next_permutation(vector.iterátor1,vector.iterátor2)</b>; //funkcia vráti true ak sa podarí permutáciu spravi
				<br> &nbsp; &nbsp;preusporiada vektor	medzi iterátormi, aby vznikla lexikograficky nasledujúca postupnos
				<br> &nbsp; &nbsp;(ak zaèneme na usporiadanom poli vypíše nám všetky permutácie lexikograficky usporiadané)
				<br><b>prev_permutation(vector.iterátor1,vector.iterátor2)</b>; //funkcia vráti true ak sa podarí permutáciu spravi
				<br> &nbsp; &nbsp;podobne ako next, ale h¾adá predošlú postupnos
			<table width="90%" border="1"><tr><td bgcolor="#6666ff">Project1</tr>
			<tr><td bgcolor="White">	
<pre>
// next_permutation example
#include &lt;iostream>     // std::cout
#include &lt;algorithm>    // std::next_permutation, std::sort
using namespace std;
int main () {
  int myints[] = {1,2,3};
  vector&lt;int> v (myints, myints+7);   //1,2,3
  sort (v.begin(),v.end());           //náš vektor je usporiadanı, ale keby nebol je dobré ho usporiada

  cout &lt;&lt; "The 3! possible permutations with 3 elements:\n";
  do {
    cout &lt;&lt; v[0] &lt;&lt; ' ' &lt;&lt; v[1] &lt;&lt; ' ' &lt;&lt; v[2] &lt;&lt; '\n';
  } while ( next_permutation(v.begin(),v.end()));

  cout &lt;&lt; "After loop: " &lt;&lt; v[0] &lt;&lt; ' ' &lt;&lt; v[1] &lt;&lt; ' ' &lt;&lt; v[2] &lt;&lt; '\n';

  return 0;
}
</pre>
    		</tr></table>
			<li><b>merge(vekt1.iterator1, vekt1.iterator2, vekt2.iterator1, vekt2.iterator2, vekt3.iterator1)</b>; //podprogram, ktorı robí triedenie zluèovaním zluèovani
				<br> &nbsp; &nbsp;(vekt2 musí ma rozsah rovnı súètu prvkov vektora1 a vektora2
				<table width="90%" border="1"><tr><td bgcolor="#6666ff">Project1</tr>
				<tr><td bgcolor="White">	
<pre>
// merge algorithm example
#include &lt;iostream>     // std::cout
#include &lt;algorithm>    // std::merge, std::sort
#include &lt;vector>       // std::vector

int main () {
  int first[] = {5,10,15,20,25};
  int second[] = {50,40,30,20,10};
  std::vector&lt;int> v(10);

  std::sort (first,first+5);
  std::sort (second,second+5);
  std::merge (first,first+5,second,second+5,v.begin());

  std::cout &lt;&lt; "The resulting vector contains:";
  for (std::vector&lt;int>::iterator it=v.begin(); it!=v.end(); ++it)
    std::cout &quot;&quot; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
</pre>
    		</tr></table>
			<li><b>remove(vekt.iterator1, vekt.iterator2, hodnota)</b>; //v danom intervale odstráni všetky prvky, ktoré sú rovné hodnote
				<br> &nbsp; &nbsp;a vráti iterátor na novı koniec tohoto vektora	
				<table width="90%" border="1"><tr><td bgcolor="#6666ff">Project1</tr>
				<tr><td bgcolor="White">	
<pre>
// remove algorithm example
#include &lt;iostream>     // std::cout
#include &lt;algorithm>    // std::remove

int main () {
  int myints[] = {10,20,30,30,20,10,10,20};      // 10 20 30 30 20 10 10 20

  // bounds of range:
  int* pbegin = myints;                          // ^
  int* pend = myints+sizeof(myints)/sizeof(int); // ^                       ^

  pend = std::remove (pbegin, pend, 20);         // 10 30 30 10 10 ?  ?  ?
                                                 // ^              ^
  std::cout &lt;&lt; "range contains:";
  for (int* p=pbegin; p!=pend; ++p)
    std::cout &lt;&lt; ' ' &lt;&lt; *p;
  std::cout &lt;&lt; '\n';

  return 0;
}
</pre>
    			</tr></table>
			<li><b>rotate(vekt.iterator1, vekt.iterator2, vekt.iterator3);</b> //rotuje vektor v rozsahu iterator1 - iterator3 
				<br> &nbsp; &nbsp;iterator2 sa pri rotacii presúva do iteratora1
		</ul>
</dl>
Naprogramuj:
<ul><li><a href="ulohy/vector-grafika/project1.exe">presúvanie objektov</a>
	<li><a href="ulohy/gul_dyn2d/project1.exe">zráky objektov</a>
</ul>	
</body>
</html>
