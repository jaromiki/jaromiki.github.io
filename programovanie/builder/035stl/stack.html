<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	 <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1250">
 	 <meta name="Content-language" content="sk">	
	  <LINK href="../css/style.css" type="text/css" rel=stylesheet>
</head>

<body>
<h3 class="main"><b>stack</b></h3>
Stack/zásobník je objekt na doèasné odloenie nejakej hodnoty a jej opätovné získanie, takıto objekt sa nazıva tie LIFO
(poslednı dnu ide prvı von), ako keï vkladáme knihy do úzkej krabice naleato -> vidie resp. vybra mono len posledne vloenú knihu.
K dispozícii máme tieto operácie: vlo, vyber, zisti_poslednı
Tento objekt je najjednoduchší a má aj najmenej èlenskıch funkcií
<dl><dt>pripnutie kninice
		<dd>Aby sme mohli pouíva zásobník musíme pripnú príslušnú kninicu
			<br><b>#include &lt;stack></b>
			<br>Po pripnutí môme zaèa pouíva objekty popísané v tejto kninici a teraz si základ popíšeme.
	<dt>deklarácia
	<dd>Je úplne podobné ako pri deklarácii po¾a.
		<ul><li>stack &lt;typ> v1; //vytvorí prázdny zásobník
			<li>stack &lt;typ> v2(v1); //vytvorí kópiu zásobníka
		</ul>
	<dt>èlenské funkcie
	<dd><ul><li><b>size()</b>; // vráti poèet prvkov v zásobníku v konšt. èase
			<li><b>empty();</b> // funkcia vráti TRUE ak je zásobník prázdny
			<li><b>push(hodnota)</b>; //vloí hodnotu do zásobníka
			<li><b>pop()</b>; // odstráni hodnotu z vrchola zásobníka
			<li><b>top()</b>; // vráti hodnotu z vrchola zásobníka
			<li><b>swap()</b>; // vymení obsah dvoch zásobníkov v konšt. èase
		</ul>	 
	<dt>Pouitie
	<dd>Úloha: máme zadanı matematickı vıraz ozátvorkovanı tromi monımi zátvorkami (), [], {}
		<br>Zisti, èi je vıraz korektne uzátvorkovanı
		<br>Riešenie:
						<table width="90%" border="1"><tr><td bgcolor="#6666ff">Project1</tr>
				<tr><td bgcolor="White">	
<pre>
// stack example
#include &lt;vcl.h>
#include &lt;stack>
#include &lt;fstream>
#include &lt;iostream>
using namespace std;

ifstream f("data.dat");
stack &lt;char> s;
char z;
int main(int argc, char* argv[])
{   while ( (z=f.get())!=EOF)
        switch (z)
        { case '(':
          case '{':
          case '[': s.push(z);break;
          case ')': if (s.empty() || s.top()!='(') {cout &lt;&lt; "chyba znak ("&lt;&lt;endl; return 0;}
          case '}': if (s.empty() || s.top()!='{') {cout &lt;&lt; "chyba znak {"&lt;&lt;endl; return 0;}
          case ']': if (s.empty() || s.top()!='[') {cout &lt;&lt; "chyba znak ["&lt;&lt;endl; return 0;}
                    s.pop();
        }
        cout &lt;&lt;"text je OK"&lt;&lt;endl;
        cin.get();
        return 0;
}
</pre>
				</tr></table>
		<br>Úloha:
		<br>V súbore je mapa rovinného bludiska, ktoré je ohranièené múrom len na jednom mieste je otvor,
		ïalej je daná naša poloha vnútri bludiska, našou úlohou je zisti, èi sa z bludiska mono dosta
		von.
		<br>Bludisko bude zadané znakmi 
		<br>X --- stena
		<br>. --- vo¾né miesto
		<br>súbor bude ma v prvom riadku rozmery bludiska R,S, v druhom bude ma našu vıchodziu polohu
		<br>riadky bludiska sú èíslované 0 a R-1, ståpce 0 a S-1 
		<br>My sa môme pohybova vodorovne alebo zvislo
		<br>Príklad bludiska:
		<pre>10 15
1 1
XXXXXXXXXXXXXXX
X.............X
XXX..XXXXXXXX.X
XXX.....XXXXX.X
XXXXXXXXX.....X
X.........XXXXX
X.XXXXXX....XXX
X.......XXXXXXX
XXXXXXX........
XXXXXXXXXXXXXXX
</PRE>
		Riešenie:
			<table width="90%" border="1"><tr><td bgcolor="#6666ff">Project1</tr>
			<tr><td bgcolor="White">	
<pre>
#include &lt;stack>
#include &lt;fstream>
#include &lt;iostream>
using namespace std;
ifstream f("data.dat");
stack <int> s;
char mapa[100][100];
char z;
int rr,ss,jr,js,i,j;
int main(int argc, char* argv[])
{    f >>rr>>ss;      //rozmer bludisk
     f >>jr>>js;      //moja poloha
     //nacitanie+vykreslenie mapy
     for (i=0; i<rr;i++)
     {  for (j=0; j&lt;ss;j++) {f>>mapa[i][j]; cout &lt;&lt;mapa[i][j];}
        cout &lt;&lt;endl;
     }
     //moja poloha do zasobnika
     s.push(jr);s.push(js);
     while (!s.empty())
     {js=s.top();s.pop();
      jr=s.top();s.pop();  //vyber polohu
      if (js*(js-ss+1)==0 || jr*(jr-rr+1)==0) {cout &lt;&lt;"som von"&lt;&lt;endl;cin.get();return 0;}
      if (mapa[jr-1][js]=='.') {s.push(jr-1);s.push(js);}
      if (mapa[jr+1][js]=='.') {s.push(jr+1);s.push(js);}
      if (mapa[jr][js-1]=='.') {s.push(jr);s.push(js-1);}
      if (mapa[jr][js+1]=='.') {s.push(jr);s.push(js+1);} //vloz polohu
      mapa[jr][js]='o';             //oznac tu som uz bol
     }
     cout&lt;&lt;"nenasiel som cestu"&lt;&lt;endl;
     cin.get();
   return 0;
}
</pre>
			</tr></table>
	<dt>Úloha
	<dd>Máme danı orientovanı graf s n vrcholmi a m hranami, ktorı zapíšeme do 2D vektora v2d tak, 
		e v v2d[i] bude zapísanı vector kde bude vıpis jeho priamych susedov.
		<br>Naèítaj start,ciel ( 0&lt;= start,ciel &lt;n ) a zisti, èi existuje cesta zo start do ciel
		<br> &nbsp; &nbsp; (pozri 2D vector)

</dl>			
</body>
</html>
