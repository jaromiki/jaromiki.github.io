<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	 <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1250">
 	 <meta name="Content-language" content="sk">	
	  <LINK href="../css/style.css" type="text/css" rel=stylesheet>
</head>

<body>
<h3 class="main"><b>string</b></h3>
V klasickom jazyku C typ string nemáme, je nahradenı po¾om znakov. Ako pracujeme s textom zapísanım v poli charov som popísal v èasti pole.
Podobne ako pri èíselnıch poliach máme monos vytvori pole statické: char c[20];, tak aj dynamické: char *cc;
<br>Nevıhodou oproti pascalu je hlavne v tom, e nemáme operátor na priraïovanie ani operátor na spojenie dvoch stringov. Tu popíšem kninicu <b>string</b>,
ktorá zjednodušuje prácu s textom a prináša pre prácu s textami ïalšie monosti. Pre pohodlnejšiu prácu so stringami máme k dispozícii dve kninice
<ul><li><b>cstring</b> resp. string.h
	<li><b>string</b> - kniznica z STL
</ul>
Kadá z tıchto kniníc ponúka iné nástroje pre prácu s textom, tu sa budem venova kninici <b>string</b>.	
<br>Premennú typu string mono naèíta pomocou operátora &lt;&lt; z cin (alebo funkciou <b>getline(cin, prem)</b> ) a tie vypísa pomocou cout >>.
<dl><dt>Pripnutie kninice
		<dd>Podobne ako pri inıch komponentoch z kninice STL aj tu musíme pripnú príslušnú kninicu
			<br><b>#include &lt;string></b>
			<br>Po pripnutí môme zaèa pouíva objekty popísané v tejto kninici a teraz si základ popíšeme.
			<br>Pokia¾ chceme pracova aj s benımi stringami pripneme aj kninicu <b>cstring</b>
	<dt>deklarácia - konštruktor
	<dd>Je úplne podobné ako pri deklarácii po¾a
		<ul><li><b>string s1;</b> &nbsp; &nbsp; &nbsp;//vytvorí prázdny string
			<li><b>string s2(s1);</b> &nbsp; &nbsp; &nbsp;//vytvorí novı string a doòho kopíruje obsah
			<li><b>string s3(s1, pos, len);</b> &nbsp; &nbsp; &nbsp;//vytvorí novı string a doòho kopíruje obsah od pozície a dlku
			<li><b>string s4(konst_text);</b> &nbsp; &nbsp; &nbsp;//vytvorí novı string a doòho konštantnı text
			<li><b>string s5(poc, char);</b> &nbsp; &nbsp; &nbsp;//vytvorí novı string a doòho vloí zadanı znak poc-krát 
			<li><b>string s5(poc, n);</b> &nbsp; &nbsp; &nbsp;//vytvorí novı string a doòho vloí zadanı n-ty znak z ASCII tab. poc-krát 
			<li><b>string s6(s.iterator1, s.iterator2);</b> &nbsp; &nbsp; &nbsp;//vytvorí novı string a doòho vloí text zadanı iterátormi
		</ul>	
	<dt>èlenské funkcie
		<dd><h4>prístup ku prvkom</h4>
			<ul><li><b>back()</b> ... môme meni/zisti poslednı prvok (nemono poui na prázdny!!)
					<br> &nbsp; s1.back()='X';
				<li>><b>front()</b> ... môme meni/zisti prvı prvok (nemono poui na prázdny!!)
					<br> &nbsp; s1.front()='X'; //to isté ako s1[0]='X'
				<li><b>operator[]</b>
			</ul>
			<h4>iterátory</h4>
			<ul><li><b>begin()</b> ... ukazovate¾ na zaèiatok
			    <li><b>end()</b> ... ukazovate¾ na koniec
			</ul>	
			<h4>dåka</h4>
			<ul>
			<li><b>size()</b>; &nbsp; //vráti aktuálny poèet znakov v stringu (rezervovaná pamä capacity() je vdy väèšia alebo rovná)
			<li><b>length()</b>;&nbsp; //rovnaké ako size()
			<li><b>resize(n)</b>; &nbsp; //zmení akt. dåku stringu, ak predlujeme zapåòa nulovımi znakmi
			<li><b>empty()</b>; &nbsp; //log. funkcia vráti TRUE ak je string prázdny
			</ul>
			<h4>prevodové funkcie</h4>
			Vo všetkıch tıchto prevodnıch funkciách sa vyskytuje parameter adr_int, èo je ukazovate¾/adresa kam má funkcia zapísa pozíciu, ktorá u nepatrí do èísla.
			<br>Ak toto nepotrebujeme môme tento parameter nahradi nulovım ukazovate¾om <b>nullptr</b>.
			<ul><li><b>double stod(string, adr_int)</b>; &nbsp; //funkcia vráti reálne èíslo, ktoré nájde v stringu, navyše na adr_int zapíše pozíciu prvého znaku nepatriaceho do double
			<li><b>float stof(string, adr_int)</b>; &nbsp; //funkcia vráti reálne èíslo, ktoré nájde v stringu, navyše na adr_int zapíše pozíciu prvého znaku nepatriaceho do float 
			<li><b>int stoi(string, adr_int)</b>; &nbsp; //funkcia vráti int èíslo, ktoré nájde v stringu, navyše na adr_int zapíše pozíciu prvého znaku nepatriaceho do int
			<li><b>int stoi(string, adr_int,2)</b>; &nbsp; //funkcia vráti int èíslo, ktoré nájde v stringu, èíslo sa chápe zapísané v sústave so základom 2
			<li><b>int stoi(string, adr_int,16)</b>; &nbsp; //funkcia vráti int èíslo, ktoré nájde v stringu, èíslo sa chápe zapísané v sústave so základom 16
			<li><b>int stoi(string, adr_int,n)</b>; &nbsp; //funkcia vráti int èíslo, ktoré nájde v stringu, èíslo sa chápe zapísané v sústave so základom n
			<li><b>long stol(string, adr_int)</b>; &nbsp; //funkcia vráti long èíslo, ktoré nájde v stringu, navyše na adr_int zapíše pozíciu prvého znaku nepatriaceho do long 
			<li><b>long stol(string, adr_int,n)</b>; &nbsp; //funkcia vráti long èíslo, ktoré nájde v stringu, èíslo sa chápe zapísané v sústave so základom n
			<li><b>long long stoll(string, adr_int)</b>; &nbsp; //funkcia vráti long long èíslo, ktoré nájde v stringu, navyše na adr_int zapíše pozíciu prvého znaku nepatriaceho do long long
			<li><b>long long stoll(string, adr_int,n)</b>; &nbsp; //funkcia vráti long long èíslo, ktoré nájde v stringu, èíslo sa chápe zapísané v sústave so základom n
			</ul>
			<h4>porovnávanie</h4>
			stringy môme porovnáva pomocou relaènıch operátorov. Obmedzíme sa na anglickú abecedu, porovnávanie robí lexikograficky.
			<br>Je moné poui aj funkciu int compare(text1, text2)  
			<h4>h¾adanie</h4>
			<ul>
			<li><b>size_t find(char)</b>; &nbsp; //funkcia h¾adá v stringu zadanı znak a vráti pozíciu prvého vıskytu znaku
				<br>(ak nenájde vráti hodnotu/èíslo rovnú preddefinovanej konštanty npos - èo akési nekoneèno)
			<li><b>size_t find(stringova_konst)</b>; &nbsp; //funkcia h¾adá v stringu zadanı text a vráti pozíciu prvého znaku kde ten text zaèína
				<br> &nbsp; &nbsp; &nbsp; &nbsp;(ak text nenájde vráti hodnotu string::npos, mono robi test, èi sa vrátená hodnota rovná string::npos)
			<br><b>size_t find(stringova_konst, pos)</b>; &nbsp; //funkcia h¾adá v stringu od pozície pos zadanı text a vráti pozíciu prvého znaku kde ten text zaèína
			<br><b>size_t find(string)</b>; &nbsp; //funkcia h¾adá v našom stringu zadanı text z vloeného stringu a vráti pozíciu prvého znaku kde ten text zaèína	
			<br><b>size_t find(string, pos)</b>; &nbsp; //funkcia h¾adá v našom stringu od pozície pos zadanı text z vloeného stringu a vráti pozíciu prvého znaku kde ten text zaèína	
			<br><b>size_t find(pole_char)</b>; &nbsp; //funkcia h¾adá v našom stringu zadanı text z vloeného po¾a a vráti pozíciu prvého znaku kde ten text zaèína	
			<br><b>size_t find(pole_char, pos)</b>; &nbsp; //funkcia h¾adá v našom stringu od pozície pos zadanı text z vloeného po¾a a vráti pozíciu prvého znaku kde ten text zaèína	
			<li><b>size_t rfind()</b>; &nbsp; //uplne ako find ale h¾adá od konca po zac.
			<li><b>size_t find_first_not_of(s)</b>; &nbsp; //funkcia h¾adá pozíciu prvého znaku, ktorı sa nenachádza v texte s (string, pole, konšt.)
			<li><b>size_t find_first_not_of(s,pos)</b>; &nbsp; //funkcia h¾adá pozíciu prvého znaku od pozície pos, ktorı sa nenachádza v texte s (string, pole, konšt.)
			<li><b>find_first_of(s)</b>; &nbsp; //funkcia h¾adá pozíciu prvého znaku, ktorı sa nachádza v texte s (string, pole, konšt.)
			<li><b>size_t find_last_not_of(s)</b>; &nbsp; //funkcia h¾adá pozíciu posledného znaku, ktorı sa nenachádza v texte s (string, pole, konšt.)
			<li><b>size_t find_last_of(s)</b>; &nbsp; //funkcia h¾adá pozíciu posledného znaku, ktorı sa nachádza v texte s (string, pole, konšt.)
			</ul>
			<h4>modifikátory</h4>
		<ul><li><b>apend(string)</b>; &nbsp; //pridá string na koniec
			<br><b>apend(string,pos,len)</b>; &nbsp; //pridá èas stringu od udanej pozície na koniec
			<br><b>apend(string.iterator1,string.iterator2)</b>; &nbsp; //pridá èas stringu od udanej pozície na koniec
			<br><b>apend(const string)</b>; &nbsp; //pridá konštantnı text na koniec
			<br><b>apend(const string, poc)</b>; &nbsp; //pridá èas konštantného textu na koniec
			<br><b>apend(poc, char)</b>; &nbsp; //pridá na koniec zadanı znak poc-krát
			<li><b>assign(str)</b>; &nbsp; //prepíše string stringom str upraví size, prípadne aj capacity
			<br><b>assign(str, pos, len)</b>; &nbsp; //prepíše string èasou stringu str
			<br><b>assign(const string)</b>; &nbsp; //prepíše string konštantnım textom
			<br><b>assign(const string, poc)</b>; &nbsp; //prepíše string èasou konštantného textu
			<br><b>assign(poc, char)</b>; &nbsp; //prepíše string znakom zopakovanım poc-krát
			<li><b>assign(poc, char)</b>; &nbsp; //prepíše string znakom zopakovanım poc-krát
			<li><b>replace(pos, len, text)</b>; &nbsp; //odstráni zo stringu od pos zadanı poèet a vloí tam uvedenı text
			<li><b>replace(pos, len, string)</b>; &nbsp; //odstráni zo stringu od pos zadanı poèet a vloí tam uvedenı text
			<li><b>replace(pos, len, char)</b>; &nbsp; //odstráni zo stringu od pos zadanı poèet a vloí tam uvedenı znak
			<li><b>replace(pos, len, char, pocet)</b>; &nbsp; //odstráni zo stringu od pos zadanı poèet a vloí tam uvedenı znak zadanı poèet krát
			<li><b>replace(iterator1, iterator2, ...)</b>; &nbsp; //ako predošlé prípady
			<li><b>at(i)</b>; &nbsp; //podobne ako operátor [] vráti znak z miesta i (èíslujeme od 0)
			<li><b>clear()</b>; &nbsp; //nastaví akt. dåku na 0
			<li><b>copy(adresa_buf,poc, poz)</b>; &nbsp; //okopíruje znaky od pozície poz zo stringu do buffra/po¾a (nedáva znak ukonèenia textu '\n')
			<li><b>erase(pos, poc)</b>; &nbsp; //odstráni poc znakov zo stringu znaky od pozície pos (skráti dåku)
			<br><b>erase(iterator1, iterator2)</b>; &nbsp; //odstráni znaky od iter1 po iter2
			<br><b>erase(iterator)</b>; &nbsp; //odstráni znaky na zadanej pozícii
			
			<li><b>insert(pos, s)</b>; &nbsp; //vloí zadanı string/text/pole na pozíciu pos, zväèší dåku
			<br><b>insert(pos, string, subpos, len)</b>; &nbsp; //vloí zo zadaného stringu od pozície subpos na pozíciu pos, zväèší dåku
			<br><b>insert(pos, poc, znak)</b>; &nbsp; //vloí poc-krát zadanı znak na pozíciu pos
			<br><b>insert(iterator, poc, znak)</b>; &nbsp; //vloí poc-krát zadanı znak na pozíciu iterator
			<br><b>insert(iterator, string.iterator1, string.iterator2)</b>; &nbsp; //vloí znaky z iného stringu
			<li><b>swap(string)</b>; &nbsp; //vymení obsah dvoch stringov v konšt. èase
			
			<li><b>push_back(hodnota)</b> //zväèší pole o jeden prvok a zapíše doòho danú hodnotu	
				<br> &nbsp; &nbsp; &nbsp; napr.: v.push_back(10);
			<li><b>pop_back(hodnota);</b> //zruší poslednı prvok vektora
		</ul>	
	<dt>operátory
	<dd><ul><li><b>+</b> ... podobne ako v pascale mono spája stringy navzájom, prípadne aj konštantné texty
				<br> &nbsp; &nbsp; jeden z operandov môe by aj char
			<li><b>+=</b> ... podobne ako + mono pripája ku stringu string, char, prípadne aj konštantnı text
			<li><b>relaèné operátory</b> ... texty mono porovnáva na rovnos nerovnos, väèší a pod.
			<li><b>[]</b> ... pomocou indexu mono vybera jednotlivé znaky z textu
		</ul>
	<dt>vstup stringu
	<dd>Popíšem vstup pomocou kninice iostream
		<br><b>Vstup textu zo štandartného zar.</b>
		<ul><li>cin &lt;&lt; s1; //zoberie zo vstupu text po prvı biely znak a zapíše ho do s1
			<li>getline(cin, s1); //zoberie zo vstupu text po enter ('\n') a zapíše ho do s1	
				<br> &nbsp; &nbsp;štandartnı príkaz cin.getline(), cin.get() nejde na naše stringy poui
		</ul>	
		<br><b>Vstup údajov zo stringu</b>
		<pre>
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
using namespace std;
string s="125 349";
stringstream ss=s;
int aa;
int main()
{  ss &gt;&gt;aa;  //naèíta z textu prvé èíslo
  cout &lt;&lt; "Preèítal som: " &lt;&lt; aa &lt;&lt; "\n";
       cin.get();
        return 0;
}</pre>
			
		<hr>
</ul>
<dt>Príklady
<dd>
<ul><li>Vstup textu
			<table width="90%" border="1">
			<tr><td bgcolor="#6666ff">Project1</tr>
			<tr><td bgcolor="White">	
<pre>
// sort algorithm example
#include &lt;iostream>     // std::cout
#include &lt;string>       // std::string
string meno;

int main(void) {
cout &lt;&lt; "Zadajte vase meno: ";
cin >> meno;
cout &lt;&lt; "Dobry den " &lt;&lt; jmeno &lt;&lt; endl;
system("pause");
return 0;
}
</pre>
	</tr>
	<tr><td bgcolor="#6666ff">Console</tr>
			<tr><td bgcolor="Black" style="color: white">
			<br>Zadajte vase meno: Ivan Hrozny
			<br>Dobry den Ivan<br>
			</tr>	
	</table>
	Vidíme, e program naèítal len krstné meno, cin >> èíta len po prvı biely znak. Ak chceme naèíta celı vstup a po enter namiesto riadku
	<br>cin >> meno; zadáme riadok
	<br>getline(cin, meno) 
	<br>(navyše cin >> meno; nám na vstupe nechal text, èo pri ïa¾šom èítaní, napr. èísel povedie ku chybe)
	<li>Pouitie funkcie find
		<br>Úloha: Naèítaj text a zisti, ko¾ko je v texte samohlások, spoluhlások, èíslic a inıch znakov
			<table width="90%" border="1">
			<tr><td bgcolor="#6666ff">Project1</tr>
			<tr><td bgcolor="White">	
<pre>
int PocetSamohlasok = 0;
int PocetSpoluhlasok = 0;
int PocetCislic = 0;
int Pocet = 0;

// retezec, ktery chceme analyzovat
string retazec = "Programator sa zasekne pri cisteni topanok, lebo instrukcie na kreme boli: Naniest, rozotriet, opakovat.";

// definicia typu znaku
string samohlasky = "aeiouyAEIOUY";
string spoluhlasky = "bcdfghjklmnpqrstvwxzBCDFGHJKLMNPQRSTVWXZ";
string cislice = "0123456789";
cout &lt;&lt; "Povodna sprava: " &lt;&lt; retazec &lt;&lt; endl;

for (int i = 0; i < retazec.length(); i++)
    if (samohlasky.find(retazec[i]) < samohlasky.length())
        PocetSamohlasok++;
    else if (spoluhlasky.find(retazec[i]) < splouhlasky.length())
        PocetSpoluhlasok++;
    else if (cislice.find(retazec[i]) < cislice.length())
        PocetCislic++;
    else Pocet++;	
cout &lt;&lt; "Pocet samohlasok: " &lt;&lt; PocetSamohlasok &lt;&lt; endl;
cout &lt;&lt; "Pocet spoluhlasok: " &lt;&lt; PocetSpoluhlasok &lt;&lt; endl;
cout &lt;&lt; "Pocet cisel: " &lt;&lt; PocetCislic &lt;&lt; endl;
cout &lt;&lt; "Pocet inych znakov: " &lt;&lt; Pocet&lt;&lt;endl;
system("pause");
return 0;

</pre>
	</tr>
	<tr><td bgcolor="#6666ff">Console</tr>
			<tr><td bgcolor="Black" style="color: white">
			<br>Pocet samohlasok: 39
			<br>Pocet spoluhlasok: 52
			<br>Pocet cislic: 1
			<br>Pocet inych znakov: 20
			<br>Press any key to continue . . .
			</tr>	
	</table>
	<li>Pouitie find(), replace()
		<br>Máme v texte nahradi text "ano" textom "samozrejme"
			<table width="90%" border="1">
			<tr><td bgcolor="#6666ff">Project1</tr>
			<tr><td bgcolor="White">	
<pre>
#include &lt;iostream>		//find(), replace()
#include &lt;string>
using namespace std;
string s="janosik rano kupil stanok";
int pos=0;
int main(int argc, char* argv[])
{   while ((pos=s.find("ano",pos))&lt;s.length()) s.replace(pos,3,"samozrejme");
    cout &lt;&lt; s&lt;&lt; endl;
    system("pause");
        return 0;
}

</pre>
	</tr>
	<tr><td bgcolor="#6666ff">Console</tr>
			<tr><td bgcolor="Black" style="color: white">
			<br>jsamozrejmesik rsamozrejme kupil stsamozrejmek
			<br>Press any key to continue . . .
			<br>
			</tr>	
	</table>
<li>Pouitie count(), reverse(), cout_if()
	<br>Máme v texte zisti poèet vıskytov nejakého znaku
				<table width="90%" border="1">
			<tr><td bgcolor="#6666ff">Project1</tr>
			<tr><td bgcolor="White">	
<pre>
#include &lt;iostream>		//cout
#include &lt;string>		//string
#include &lt;algorithm>		//count(),reverse(), count_if() 
using namespace std;
string s="Mam Rad InformatikU";
int fun1(char x)
{ return (x>='A' && x<='Z');} // pre ve¾ké písmeno vráti pravdu (isupper() )

int main(int argc, char* argv[])
{       cout &lt;&lt;"poc a: "&lt;&lt;count(s.begin(),s.end(),'a') &lt;&lt; endl;
        reverse(s.begin(),s.end());
		cout &lt;&lt;"otoc : "&lt;&lt;s &lt;&lt; endl;
		cout &lt;&lt;"poc velkych: "&lt;&lt;count_if(s.begin(),s.end(),fun1) &lt;&lt; endl;
		system("pause");
		return 0;
}

</pre>
	</tr>
	<tr><td bgcolor="#6666ff">Console</tr>
			<tr><td bgcolor="Black" style="color: white">
				<br>poc a: 3
				<br>otoc : UkitamrofnI daR maM
				<br>poc velkych: 4
				<br>Press any key to continue . . .			<br>
			</tr>	
	</table>

	</ul>
</dl>
</body>
</html>
