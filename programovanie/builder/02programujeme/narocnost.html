<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	 <title>Èasovaè a dialógy</title>
	 <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1250">
 	 <meta name="Content-language" content="sk">	
	  <LINK href="../css/style.css" type="text/css" rel=stylesheet>
</head>

<body>
<h3>Odhad èasovej nároènosti algoritmu</h3>
<dl>
	<dt class=main>Èasová nároènos
	<dd>Pri písaní programu nie je dôleité len správnos algoritmu (t.j. èi dáva správne vısledky), ale aj efektivita programu. Niektoré algoritmy papierovo dávajú správne vısledky ale v reálnom èase
		sa vısledku nedoèkáme, lebo èas vıpoètu presahuje aj nieko¾ko rokov, alebo pamäové nároky sú také rozsiahle, e ju poèítaè nedokáe splni. Pri benom písaní programov (školské úlohy) 
		uprednostòujeme algoritmy, ktoré sa ¾ahšie programujú (napr. na triedenie rıchlejšie "spichneme" bublinky, minimum a pod. ako napr. quicksort).
		Pri písaní komerènıch programov (alebo pri súaení v programátorskıch súaiach) je dôleité aby náš algoritmus pracoval efektívne	jak s pamäou tak aj s èasom vıpoètu. 
		Programátori potrebovali nejaké objektívne kritériá na urèenie, ktorı algoritmus je lepší. Kritériá, e vyhrá ten, ktorı zbehne rıchlejšie na PC nie sú dobré, lebo to, e mne program 
		zbehol pomalšie ako "kolegovi" v Japonsku neznamená hneï, e môj algoritmus je pomalší. H¾adali sa spôsoby ako porovnáva algoritmy - ako urèi rebríèek algoritmov na riešenie konkrétneho 
		problému bez toho aby sme ich museli písa do poèítaèa.
		<br>Zvíazila myšlienka, e pre kadı typ úlohy sa urèí základná (typická) operácia a my len spoèítame poèet vykonaní tejto operácie a èím bude èíslo menšie je algoritmus lepší.
		<br>Napr. chceme nájs maximum z N prvkov v neutriedenom poli A
		<br>Typická operácia pri h¾adaní maxima je porovnávanie a ideme zisova ko¾ko tıch porovnávaní je treba
		<br>myšlienka "môjho" algoritmu je nasledovná:
		<ul><li>zvolím, e max je v prvej poloke po¾a
			<li>postupne porovnávam maximálnu poloku s ïalšími polokami a ak nájdem poloku väèšiu oznaèím ju za maximálnu
		</ul>	
		program by vyzeral asi takto:
		<pre> 
...
imax = 0;
for (i=1; i&lt;N; i++)
  if (A[imax]&lt;A[i]) imax:=i;
...
</pre>
		poèet porovnaní teda bude N-1
		<br>Informatici však prišli na to, e takéto jemné triedenie rıchlosti algoritmu nepotrebujú 
		(e ak sa algoritmy líšia napr. o 2 porovnávania, tak to nehrá úlohu), 
		<br>tie spoèíta takto presne ten poadovanı poèet je niekedy aj dos nároèné,
		a tak vymysleli <b>asymptotickú</b> nároènos, ktorá urèuje rıchlos algoritmu pre "ve¾ké" rozsahy vstupnıch dát. 
		<br><br>Napr. Nech poèet operácií algoritmu A je: 10*n
		<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Nech poèet operácií algoritmu B je: n<sup>2</sup>
		<br>Je zrejmé, e pre n&lt;10 je vhodnejší algoritmus B a pre n&gt;10 je vhodnejší algoritmus A. V porovnávaní je lepší ten algoritmus, ktorı je rıchlejší
		pre "väèšie" hodnoty. Pod¾a tejto asymptotickej nároènosti zaraïujeme algoritmy do tried, prièom trieda urèuje urèuje rıchlos algoritmu
		<br><br>pod¾a rıchlosti rastu základnıch benıch funkcií mono urèi "rebríèek sily" - ja tu uvádzam základné funkcie zoradené od najsilnejšej po najslabšiu.
		Ak sa vo vıslednom vzorci nachádzajú v šèítancoch viaceré základné funkcie nechá sa vo vısledku len sèítanec s najsilnejšou funkciou, prièom ak sèítanec obsahuje v súèine konštantu, 
		tak tá sa zanedbá (napr. 5n<sup>2</sup> -&gt;n<sup>2</sup> 
		<ul><li><b>n<sup>n</sup></b>
			<li><b>n!</b>
			<li><b>a<sup>n</sup></b> (kde konštanta a&gt;1)
				<br>sila exponencialnej funkcie je rozlíšitelná pod¾a ve¾kosti konštanty a (3<sup>n</sup> je "mocnejšie" ako 2.5<sup>n</sup>
			<li><b>n<sup>a</sup></b> (kde  konštanta a&gt;1)
				<br>sila mocninovej funkcie je rozlíšitelná pod¾a ve¾kosti konštanty a 
				<br>sila n<sup>3</sup> a (n+b)<sup>3</sup> (kde b je koštanta) sú rovnaké
			<li><b>n</b>
			<li><b>log n</b>
				<br>sila všetkıch log funkcií je rovnaká (nezáleí na základe)
			<li><b>1</b>
				<br>èas vıpoètu nezávisí od rozsahu dát (napr. h¾adáme max. v utriedenom poli)	
		</ul>
		<br>
		Asi to bude treba vysvetli na príklade.
		<br>Nech spoèítaním poètu vykonaní základnej operácie dostaneme vzah: 5*n<sup>5</sup> + 2*n*3<sup>n</sup>
		<br>najsilnejšia pouitá funkcia je 3<sup>n</sup> a tak vyberieme sšítanec 2*n*3<sup>n</sup> a po zahodení konštanty v súèine
			získame vısledok n*3<sup>n</sup>, ktorı zapisujeme v tvare O(n*3<sup>n</sup>) a èítame e algoritmus je triedy n*3<sup>n</sup>
		<br><br>
		Asi zarmútim tıch, èo èakali, e u je všetko jasné a môme pod¾a tohoto návodu "jednoducho" zaraïova algoritmy do tried, 
		situácia sa komplikuje, ak poèet vykonaní základnej operácie závisí od vstupnıch dát
		<br>Opä vysvetlím na príklade:
		<br>Máme zisti èi sa èíslo B nachádza v N prvkovom poli A
		<pre>
			ii:=0;
			while (ii&lt;N &amp;&amp; A[ii]!=B) ii:=ii+1;
			if (ii>N-1) nenachadza else nachadza;
		</pre>
		Pri cykle while nevieme ko¾ko krát robí porovnanie (niekedy staèí aj jedno, inokedy musíme testova a do konca po¾a)
		<br>Informatici sa dohodli, e v takıchto prípadoch budeme bra do úvahy priemernú (štatistickú) hodnotu poètu vykonaní základnej operácie
		<br>(keby sme nechali h¾ada poèet porovnávaní pre rôzne náhodné dáta v poli a zapisovali si poèet nutnıch porovnaní a nakoniec by sme z tıchto èísel urèili priemer)
		<br>V tomto prípade sa dá vısledok "vytuši" N/2 - priemerná dåka, kım èíslo v poli nájdem, 
		<br>Odhad tohto priemerného poètu (èo je najpravdepodobnejší vısledok) bıva dos zloitı a ja odporúèam pouíva namiesto neho "najhorší" prípad èo v 99% urèí algoritmu rovnakú (správnu) triedu. 
			Treba si ale uvedomi, e tento postup nemusí vdy vies ku správnemu vısledku - niekedy urèí vyššiu=&gt;horšiu triedu.
			(asi vás trápi, èo keï to bude akurát ten prípad 1% - ia¾ náš (stredoškolskı) matematickı aparát v niektorıch príkladoch jednoducho na niektoré úlohy nestaèí)
			Tu by som asi mal poveda, e sa s takımito prípadmi nestretnete, e sú vzácne, ale u pri analıze triedenia quickSort získame naším aparátom triedu n<sup>2</sup>, tie
			Shellov algoritmus triedenie nám spadne do triedy O(n<sup>2</sup>) a vieme, e to nie je tak. 
	<dt>Ukáka vıpoètu poètu operácií
	<dd>Pre predstavu o tom, ako sa zloitos prejavuje na skutoènom poèítaèi, sa pozrieme, ako dlho pobeia algoritmy na poèítaèi, ktorı robí 10<sup>9</sup> (miliardu) operácií za sekundu. 
		Tento poèítaè je porovnatelnı s tımi, ktoré dnes bene pouíváme. Pozrime sa, ako dlho na òom pobeia algoritmy s následujícími zloitosami:
	<table border="1"><tr><th rowspan="2">funkcia<th colspan="6">n
			<tr><td>10<td>20<td>50<td>100<td>1000<td>10<sup>6</sup>
			<tr><td>log n		<td>3,3ns<td>4,3ns<td>4,9ns<td>6,6ns<td>10,0ns<td>19,9ns
			<tr><td>n			<td>10ns<td>20ns<td>30ns<td>100ns<td>1&micro;s<td>1ms
			<tr><td>n*log n		<td>33ns<td>86ns<td>282ns<td>664ns<td>10&micro;s<td>20ms
			<tr><td>n<sup>2</sup><td>100ns<td>400ns<td>900ns<td>100&micro;s<td>1ms<td>1000s
			<tr><td>n<sup>3</sup><td>1&micro;s<td>8&micro;s<td>27&micro;s<td>1ms<td>1s<td>10<sup>9</sup>s
			<tr><td>2<sup>n</sup><td>1&micro;s<td>1ms<td>1s<td>10<sup>21</sup>s<td>10<sup>292</sup>s<td>nekon.
			<tr><td>n!<td>3&micro;s<td>10<sup>9</sup>s<td>10<sup>23</sup>s<td>10<sup>149</sup>s<td>10<sup>2558</sup>s<td>nekon.
	</table>			
	Pre predstavu: 
	<br>1 000 s je asi tak ètvr hodiny, 
	<br>1 000 000 s je necelıch 12 dní, 
	<br>10<sup>9</sup>s je 31 rokov a 10<sup>18</sup>s je asi tak vek Vesmíru. 
	<br>Take nepolynomiálne algoritmy sú pre väèšie rozsahy velmi rıchlo nepouite¾né.
	<dt>Sumár
	<dd>Niektoré typické algoritmy netreba u analyzova z h¾adiska èasovej nároènosti, ale odvoláme sa na všeobecnú znalos algoritmu a aj jeho èasovú nároènos.
	<table>
	<tr><th>Algoritmus<th>Èasová nároènos</tr>
	<tr><td>h¾adanie v neutriedenom poli<td>O(n)
	<tr><td>h¾adanie v utriedenom poli<td>O(log n)</tr>
	<tr><td>h¾adanie k-teho najväèšieho prvku<td>O(n)</tr>
	<tr><td>h¾adanie mediána<td>O(n)</tr>
	<tr><td>jednoduché triedenia (max, bubliny, vsúvanie)<td>O(n<sup>2</sup>)</tr>
	<tr><td>triedenie quick <td>O(n*log n)</tr>
	<tr><td>vsúvanie prvku (odstránenie prvku) z utriedeného po¾a<td>O(n)</tr>
	</table> 
</dl>
</body>
</html>
