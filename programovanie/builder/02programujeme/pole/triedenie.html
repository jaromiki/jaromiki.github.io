<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	 <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1250">    
	  <LINK href="../../css/style.css" type="text/css" rel=stylesheet>	<title>Triedenie</title>
</head>

<body>
<center><h3 class=nadpis>Triedenie</h3></center>
Znalos triediacich algoritmov pri programovaní v C-èku nie je nutná, lebo existujú kninièné podprogramy na utriedenie rôznych objektov.
Viac mono nájst v kapitole venujúcej sa štandartnej kninici STL. Tu je to z dôvodu precvièenia algoritmického myslenia, resp. vycibrenie programátorskej techniky.
Nech A je mnoina n prvkov {a<sub>i</sub>} na ktorej je definovaná relácia usporiadania t. j. 
<ul><li>pre všetky 0 &lt; j, k &lt;= n platí niektorı z nasledovnıch vzahov: a<sub>j</sub> = a<sub>k</sub>; a<sub>j</sub> > a<sub>k</sub>; a<sub>j</sub> &lt; a<sub>k</sub>
	<li>pre všetky 0 &lt; j, k, l &lt;= n platí: a<sub>j</sub> > a<sub>k</sub>  a a<sub>k</sub> > a<sub>l</sub> => a<sub>j</sub> > a<sub>l</sub>
</ul>
Takúto mnoinu voláme lineárne usporiadate¾ná. Problém triedenia je nájs takú permutáciu, aby pre všetky j,k &lt;= n platilo: j>k => a<sub>j</sub> >= a<sub>k</sub>. 	 
<br>
Relácia usporiadania je urèená nejakou vlastnosou prvkov mnoiny a voláme ju k¾úè. V C môme triedi pod¾a èíselnıch, 
znakovıch a textovıch k¾úèov, princíp je rovnakı. Myšlienka triedenia bude vysvetlená na triedení celıch èísel 
(zoradenie èísel od najmenšieho po najväèšie), pouitie na triedenie pod¾a inıch k¾úèov je analogické)                   
<dl><dt class=main>M A X  -  S O R T
	<DD>Je základnım a najjednoduchším triedením. Táto jednoduchá myšlienka je a prekvapujúco rıchla. Myšlienka je nasledovná.
	<br>Chceme usporiada n iakov stojacich za sebou pod¾a ve¾kosti. Porovnávaním nájdeme najväèšieho a vymeníme ho s poslednım. 
	Teraz rovnako budeme usporiadava (n-1) iakov a takto budeme h¾ada max. v stále menšej skupine. Keï nám ostane u iba jeden prvok, 
	je skupina utriedená.
<TABLE cellSpacing=0 width="80%" align=center bgColor='white' border=1>
         <TR><TD vAlign=" top" bgColor='#99cccc'><P><I>Triedenie cez maximum</I> </P>
         <TR><TD vAlign=top><PRE>procedure Max;
{ for (i=n-1; i>0; i--)  //i ...na ktore miesto pojde max
  { im=0;              //kde bıva maximum
    for (j=1; i<=i;i++)   
	if (a[im] &lt; a[j]) im=j;
	vymen(a,im,i);     //vymeni v poli a prvky im-ty a i-ty 
  }
{</pre>
 </table>		 
Nevıhoda tejto metódy je, e triedenie trvá vdy rovnako dlho - ak je pole skoro alebo úplne utriedené, tak jej to nepomôe. Táto metóda triedenia sa nedá vylepšova.

	<dt class=main>BUBLE-SORT
	<dd>Toto triedenie si vysvetlíme na príklade.  Predstavte si  takúto situáciu.  Na hodine telocviku  ste sa celá
	trieda postavili do radu tak, ako ste prichádzali. Keï prišiel uèite¾,  zaèal vás  zoradova. Zobral prvého z¾ava,
	ak bol jeho pravı sused menší, vymenil ich. Toho, èo bol predtım naj¾avejší, zase porovnal s jeho  pravım susedom. 
	Ak novı pravı sused bol opä menší, tak aj ich navzájom vymenil.  Ale ak bol pravı sused väèší, tak svojho ob¾úbenca 
	ponechal tak a zaèal opakova tie isté operácie s tım väèším pravım susedom. Keï došiel opä na pravı koniec radu, 
	pozrel sa na vás, èi ste u zoradení. Ak ste ešte neboli, tak opä  zaèal rovnako z ¾avého konca. Keï došiel opä 
	na pravı koniec radu, tak sa zasa pozrel, èi u ste zoradení ...  Ak ste boli, tak skonèil a dal vám rozcvièku.
	Teraz si to zopakujeme s kartami.  Majme 20 pomiešanıch kariet, na ktorıch sú èísla od 1 do 15.  Prv ne ich zaèneme triedi, 
	uloíme ich pekne do radu v takom poradí, v akom sme ich našli.  Budeme postupova pod¾a uèite¾ovho algoritmu. 
	Teda najprv zoberieme naj¾avejšiu a porovnáme ju s kartou,  ktorá je od nej hneï napravo.  Ak tá naša ( v tomto
	prípade prvá a ïalej to bude vdy  väèšia z posledného porovnania ) je väèšia, tak ich obe vymeníme, ináè svoju pozornos 
	zameriame na tú väèšiu a ïalšie  operácie  budeme  prevádza  s òou.  Take opä ju porovnáme s kartou  po jej pravici, ...  
	Keï dôjdeme  na pravı koniec radu je jedna karta zaruèene u na správnom mieste.
	Urèite ste na to prišli, e posledná karta je najvyššia. Teraz nám treba ešte usporiada N-1 kariet. Po prebehnutí z¾ava doprava
	sa zas zaruèene na posledné miesto (N-1) dostane najvyššia karta a ostane nám ešte N-2 kariet.
	<br>Takto budeme pokraèova, a budeme ma len 2 karty, ktoré treba usporiada - porovnáme ich a ak treba zameníme a je jasné,
	e teraz sú u všetky karty utriedené.
<TABLE cellSpacing=0  width="80%" align='center' bgColor='white' border=1>
    <TR><TD vAlign=" top" bgColor='#99cccc'><P><I>Prvé bubliny</I> </P>
    <TR><TD vAlign=top><PRE>void buble(int *a, int n)   //do podprogramu prenesieme pole a pocet prvkov
{  for(i=n-1; i>0; i--)           //i ... kolko prvkov este triedime
      for(j=1; i&lt;=n; j++)       //j ... adresa praveho prvku z dvojice, ktorú porovnávam
         if (a[j-1]>a[j]) vymen(a,j,j-1);
}</pre>
 </table>		 
	Vidíme, e program je krátky a celkom zrozumitelnı. Skúsme h¾ada nedostatky algoritmu:
	<ol><li>algoritmus sa nestará, èi náhodov u pole nie je utriedené (kadé pole triedi rovnako dlho)
		<li>prvky sa premiestòujú len o 1 políèko, èie celá cesta kadého políèka na svoje správne miesto trvá dlho
	</ol>	
	Skúsme teraz upravi algoritmus tak, aby utriedené pole zbytoène netriedil. Vieme zisti, e pole je u utriedené?
	<br><br>Áno
	<br>Ak sme pri prechode z¾ava doprava niè nevymieòali, tak je nielen "poslednı" prvok u správne umiestnenı ale aj ostatné.
	<br>Pozn. Kede podprogram "nièí" premennú n je poèet prvkov prenesenı cez parameter a premenná n v hlavnom programe je ochránená.
<TABLE cellSpacing=0 width="80%" align='center' bgColor='white' border=1>
         <TR><TD vAlign=" top" bgColor='#99cccc'><P><I>Druhé - lepšie bubliny</I> </P>
         <TR><TD vAlign=top><PRE>void buble2(int *a,int n)
{ for (int este=1;n>0 && este; n--)
  {  este=0;
     for (int j=1; j&lt;=n; j++)
	   if (a[j-1]>a[j]) 
	   {  vymen(a,j,j-1); este=1; }</pre>
 </table>		 
	<br>Tento algoritmus je lepší najmä ak triedené pole nie je moc poprehadzované a monos, e bude utriedené skôr je reálna.
	Pre náhodne zamiešané polia, však môe by efekt aj opaènı - t. j. triedenie bude trva dlhšie.
	<br><br>
	Pri sledovaní vımen urèite prídete na myšlienku, e prvky umiestnené nad poslednou vımenou sú u na svojich miestach a teda
	pri zniovaní premennej n môme by niekedy "smelší". 
<TABLE cellSpacing=0 width="80%" align=center bgColor='white' border=1>
         <TR><TD vAlign=" top" bgColor='#99cccc'><P><I>Tretie - lepšie bubliny</I> </P>
         <TR><TD vAlign=top><PRE>void buble3(int *a,int n)
{  int k;
   for (n--;n>0;n--)
   {  k=1;
      for (j=1;j&lt;=n; n--)
	    if (a[j-1]>a[j]) { vymen(a,j,j-1); k:=j-1; }
	  n=k;
    }</pre>
 </table>
	<br>No a to sú u bublinky v plnej dokonalosti. Napriek tomu, e sme ich 2 krát vylepšovali nedosahujú kvalít lepších triedení
	(asi platí, e èím je nieèo horšie, tım sa to ¾ahšie vylepšuje)
	Ïalšie vylepšenie je u radikálne - pozri Dobosievicz, poprípade u nasledovné pretriasanie.

    <dt class=main>S H A K E R  -  S O R T
	<dd>Na úvod jedno  dôleité upozornenie! Pred skúmaním tohto triedenia si najprv prezrite BUBBLE-SORT.  
		Toto triedenie sa toti zakladá práve na òom, je toti jeho vylepšením. Jeden z problémov bubliniek je,
		e zatia¾ èo ve¾ké prvky vcelku rıchlo putujú doprava, tie malé postupujú len ve¾mi pomaly.
		<br>Príklad1: Utriedenú postupnos "pokazíme tak, e najväèší prvok prehodíme na druhı koniec. Bublinky na jeden
		beh túto chybu opravia.
		<br>Príklad2: Utriedenú postupnos "pokazíme tak, e najmenší prvok prehodíme na druhı koniec. Bublinky musia urobi
		a n-1 behov, aby to napravili.
		<br>Tento nedostatok (pomalı posun malıch prvkov) napráva triedenie pretriasaním, kde raz ideme z¾ava doprava 
		a potom sprava do¾ava. Zároveò budeme robi "smelé" kroky, keï zistíme e dlhšie úseky na zaèiatku, resp. na konci sú u utriedené
		(pozri predošlı príklad)

<TABLE cellSpacing=0 width="80%" align='center' bgColor='white' border=1>
         <TR><TD vAlign=" top" bgColor='#99cccc'><P><I>Triedenie pretriasanim</I> </P>
         <TR><TD vAlign=top><PRE>void shaker(int *a, int n);
for (int i1=0, int i2=n-1; i1&lt;i2; i2=i4,i1=i3)
{  i4=i1;                    //i4 ... kam sa bude posuvat i2
   for (i=i1; i&lt;i2; i++) if (a[i]>a[i+1]){ i4=i; vymen(a,i,i+1); }
   i3=i2;                    //i3 ... kam sa bude posuvat i1
   for (i=i4; i>i1; i--) if (a[i]&lt;a[i-1]){ i3=i; vymen(a,i,i-1); }
}</pre>
 </table>
Toto zlepšenie budí dojem, e triedenie znaène urıchli ale väèšinou iadny vıraznı pokrok nepobadáme. 

    <dt class=main>I N S E R T  -  S O R T
	<dd>Triedenie vsúvaním je zaloené na myšlienke:
	<br>Máme utriedenıch iakov a príde novı iak. Najprv mu nájdeme miesto (medzi ktorıch sa má zaradi), iakov od tohto miesta
	do konca odsunieme a na uvolnené miesto príde novı iak. Tento postup môme viackrát opakova. Toto triedenie je ve¾mi rıchle
	ak prichádzajúce prvky sú pribline usporiadané (netreba ve¾a presúva). Pri náhodnom usporiadaní je porovnatelné s bublinkami.
	<br>Algoritmus
	<br>Pri programovaní je vıhodné h¾adanie miesta a odsúvanie robi naraz - usporiadané prvky od konca porovnávame s novım a ak
		je novı menší prvok v zozname posunieme doprava. 
	<br>Myšlienka programu je takáto:
	<br> &nbsp; &nbsp; na zaèiatku si zvolíme pole jednoprvkové (a[0]), ktor0 je utriedené.
	<br> &nbsp; &nbsp; príde druhı prvok a nájdeme mu miesto kam sa má zaradi (za prvého menšieho alebo na zaèiatok) a zaradíme ho
	<br> &nbsp; &nbsp; u máme dvojprvkové pole utriedené a príde tretí atï.
<TABLE cellSpacing=0 width="80%" align=center bgColor='white' border=1>
         <TR><TD vAlign=" top" bgColor='#99cccc'><P><I>Insert - triedenie vkladaním</I> </P>
         <TR><TD vAlign=top><PRE>void insert(int *a, int n);
{  for (i=1;i&lt;n;i++)                 //i ... kto je novy
   {  k=a[i];                            //noveho odlozime nabok, aby sa ostatni mohli posuvat doprava 
      for (int j=i-1; j>=0 && k&lt; a[j]; j--) a[j+1] = a[j]; //vacsi sa posuvaju doprava 
	  a[j]=k;                            //nasli sme miesto kam patri a je tak volno 
   }
}    
  </pre>
 </table>
    <dt class=main>S H E L L  -  S O R T
	<dd>Preèo shell ?  Lebo  ho vymyslel  jeden pán  menom Shell.  Na úvod vás chcem poprosi : kto neovláda ešte insertsort 
		( triedenie vkladaním ), nech si ho najprv detailne pozrie. Budeme ho toti vyuíva. Pán Shell  prišiel na jednu  
		supergeniálnu vec.  Myslel si, e dobré a rıchle  triedenie musí  robi èo najviac  vımen na ve¾ké vzdialenosti.
		Poïme na to prakticky. Opä sme na hodine telocviku. Tentoraz sa omeškala skoro polovica triedy. Zvyšná u bola nastúpená. 
		Uèite¾ ich chcel zoradi klasickım vkladaním, ale všimol si, e tí, èo prišli neskôr sú zväèša menší ako tí, èo prišli vèas. 
		A tu dostal nápad. Akı ?
		<br>Uvedomil si, e vkladaním by to  trvalo príliš dlho. Tí menší by toti museli prís a dopredu.  
		Jeho napadlo povymieòa  ich pred vkladaním. Ale ako ?  Mal dve skupiny :  prvú tvorili tí, èo prišli naèas;  
		druhú oneskorenci. A tak porovnal prvıch z oboch skupín,  a usporiadal ich. Ako ? Napríklad vımenou. 
		Tak isto porovnal druhıch zo skupín. Rovnako  tretích, štvrtıch, ...  Èo dosiahol ? 
		Väèšina  menších sa ocitla v prvej skupine. Teraz však  na prekvapenie mnohıch obe skupiny spojil a znova ich rozdelil na 
		tri skupiny !  A zase  pokraèoval podobne :  zobral prvıch zo všetkıch troch skupín.  Ich troch usporiadal takto : 
		prvého porovnal s druhım. Ak bol prvı väèší, vymenil ich.  Ak nie, nechal ich tak. Na to porovnal druhého s tretím. 
		Zase :  ak bol druhı väèší, vymenil ich; ak nie, nechal. Rovnako aj druhıch zo všetkıch troch skupín usporiadal vkladaním. 
		Podobne tretích, štvrtıch, ...  A zase ich spojil. Èo urobil potom ?
		<br>Tentoraz ich u nerozde¾oval,  ale usporiadal ich všetkıch vkladaním. Preèo asi tak urobil ?
		Jednoducho preto, e keby ich rozdelil na pä skupín, v kadej by boli iba dvaja. A to u je jednoduhšie urobi insertsort 
		na celej triede.  Prvok sa toti posunie maximálne o jedno miesto smerom dopredu ( k menším ). To však dokáe aj insertsort.
		<br>Teraz si to môme zopakova s kartami. Máme neusporiadané karty. Rozdelíme ich na tri kôpky pokia¾ mono s rovnakım 
		poètom prvkov. Na kadej z nich vidíme vrchnú kartu. Vrchné karty utriedime vkladaním. Potom ich poloíme pred jednotlivé 
		kôpky rubom nahor. Takto na kôpkach vidíme iné karty, ktoré zase utriedime vkladaním. Opä ich preloíme pred kôpky rubom 
		nahor na tie, èo tam u boli. Takto pokraèujeme a sa nám nevyèerpajú karty. Ak nám na konci nezostanú tri karty, ale dve;
		tak utriedime len tie dve a preloíme. Ak jedna, iba preloíme. Teraz spojíme kôpky nasledovne. Na ¾avú poloíme strednú 
		a na to ešte priloíme pravú. Tak dostaneme jednu kopu. Èo urobíme ïalej ?
		<br>
		Teraz opä rozdelíme kopu na kôpky, napríklad na pä. Kôpky rozloíme z¾ava doprava tak, aby vrchná karta bola lícom nahor. 
		Vrchné karty zase utriedíme vkladaním a odloíme pred kôpky. Takto postupujeme a do vyèerpania kariet. 
		Kôpky poskladáme takto : najpravejšiu dáme na jej ¾avého suseda, to èo sme dostali dáme opä na ¾avého suseda, ...  
		A napokon celú kopu otoèíme lícom nahor. Znova rozdelíme kopu tentoraz na devä kôpok, ...
		Takto postupujeme kım to je vıhodné. Kedy je to nevıhodné ?  Keï sa karta môe posunú smerom dopredu len o jedno, dve miesta. V tom prípade utriedime celú kopu vkladaním.
		Otázku ideálneho návrhu parametrov (kroku) vyriešil pán Knuth. Krok je vlastne vzdialenos porovnávanıch prvkov.
		Našiel aj vzorec na ich jednoduchı vıpoèet : 
		k<sub>0</sub>=1, k<sub>i</sub>=3*k<sub>i-1</sub>, prièom k<sub>i</sub> &lt; n div 6.
		Zaèína sa tım najväèším k<sub>i</sub>, potom k<sub>i-1</sub>, ... a po k<sub>0</sub>=1, èo však je obyèajnı insertsort.
		Všeobecne sa dá poveda, e zmenšujúci krok treba voli tak aby sa neporovnávali stále tie isté skupiny. Dobré vısledky dáva
		postupnos
		<br>k1=n / 5
		<br>k2=k1 / 3 + k1 / 5 - 1
		<br>Tento algoritmus  sa nazıva  shellsort  alebo  insertsort s ubúdajúcim krokom.
		Zaujímavosou je, e robíme zdanlivo viac ako pri vsuvaní (ved klasické vsúvanie sa napokon aj zavolá) a napriek tomu
		je vısledok opaènı a èas vıpoètu pri pouití Shell triedenia je podstatne kratší. Tu sa ukazuje aké je triedenie vsúvaním
		rıchle, ak je postupnos "skoro" utriedená.


<TABLE cellSpacing=0 width="80%" align='center' bgColor='white' border=1>
         <TR><TD vAlign=" top" bgColor='#99cccc'><P><I>Triedenie Shell</I> </P>
         <TR><TD vAlign=top><PRE>void shell(int *a, int n);
{ h= n/5;
  while (h>2) 
  {  i=0; j=h+1;
     while (j&lt;n)
	 {  p=a[j]; k=i;
	    while (k>0 &amp;&amp; p&lt;a[k])
		{  a[k+h] = a[k];
		   k-=h;
		}
		a[k+h] = p;
		i++; j++;
	 }
	 h= h/3 + h/5 - 1;
  }	 	   		
  for {i=1; i&lt;n; i++)
  {  p=a[i]; j= i-1;
     while(p &lt; a[j])
	 {  a[j+1] = a[j];
	    j--;
	 }
	 a[j+1] = p;
  }	 	
}</pre>
</table>

	<dt class=main>Q U I C K  -  S O R T
	<dd>Quick je anglické slovo a znamená asi to¾ko ako rıchly. Teda pod¾a mena by mal by tento algoritmus rıchly. 
	On aj vskutku je, mnohí ho povaujú za najrıchlejšie triedenie vôbec. Dokonca aj prax to èasto potvrdí.
	<br>Myšlienka:
	<br>Tentoraz nebude hodina telocviku, ale si povieme rozprávku.
	Kde bolo, tam bolo, bola raz jedna krajina menom Putánia. V tej krajine sa piesok sypal a voda sa liala. 
	Nezvyèajné tu bolo nieèo iné. ili tu toti dva národy : liliputáni a maxiputáni.  Liliputáni boli malí, kım maxiputáni zase ve¾kí.
	<br>
	Liliputáni  sa vdy  saovali,  e sú oproti  maxiputánom v nevıhode. Chceli ma väèšie práva,  ale menšie povinnosti.  
	To sa však nepáèilo maxiputánom, ktorım sa zdali poiadavky liliputánov prehnané. Nieko¾ko rokov sa osoèovali, a sa napokon 
	rozhodli, e sa rozdelia a vytvoria dve krajiny : krajinu liliputánov a krajinu maxiputánov. Pôvodnú krajinu rozdelili na 
	dve polovice a vypoèítali vıšku, ktorá bude rozhodujúcim deliacim kritériom. Vıšku vypoèítali tak, aby existovali aspoò
	dvaja tej vıšky. Tıch urèili za policajtov.  Po vytıèení hranice však zistili, e nie všetci sa presahovali. Tak prišli 
	k slovu policajti. Jeden odišiel  do krajiny liliputánov  a tam h¾adal špiónov.  Ako ich spoznal ?  Jednoducho, boli od neho 
	vyšší. Ten druhı šiel zase do krajiny maxiputánov. Tam tie h¾adal špiónov. Tí boli od neho niší. Keï jeden z nich našiel 
	špióna, chcel ho da vyhosti. Ale colníci mu oznámili, e cez hranice nemono chodi len tak, a u vôbec nie špióni.
	Jedine vtedy, ak by šlo o vımenu.  Tak musel poèka,  kım aj ten druhı policajt nájde špióna. Potom si ich mohli vzájomne vymeni.
	<br>
	Keï si ich vymenili, zase odišli kadı do svojej krajiny h¾ada špiónov. Ak jeden našiel, poèkal kım nájde aj ten druhı 
	a zase si ich vymenili. Takto pokraèovali, a kım sa v jednej krajine neminuli špióni. Ak ale v tej druhej ešte boli, 
	presahovali ich ku hraniciam a posunuli hranicu tak, aby špióni zostali za hranicou. Takımto spôsobom vznikli dve nové krajiny : 
	Liliputánia a Maxiputánia. Stala sa však pritom takáto vec. Liliputánia mala raz to¾ko obyvate¾ov ako Maxiputánia. 
	To sa ukázalo dramatickım pri vo¾bách do vlády. Kım v Maxiputánii bol kadı tretí ministrom, v Liliputánii to bol iba kadı
	šiesty. Keïe však všetci si chceli dobre i, tak aj chceli by ministrami. To ale nebolo moné, iba ak by sa Liliputánia 
	rozdelila na dve krajiny, povedal ktosi. A toho sa ¾udia chytili. Ešte donedávna pevná a jednotná Liliputánia sa rozdelila. 
	<br>Ako ?  
	<br>Podobne ako sa rozdelila  bıvalá Putánia. Tak vznikli Lilililiputánia a Maxililiputánia. V snahe všetkıch by ministrami 
	sa rozdelili nielen tie, ale aj Maxiputánia.
	<br>
	Tak to šlo a dovtedy kım kadı nebol predsedom vlády. Pritom si však nevšimol, e je aj jedinım obyvate¾om krajiny, ktorej vládne. 
	Tu prišiel cudzinec a všimol si jednu vec.  Postavil obyvate¾ov krajín v takomto poradí : Lililililililili...putánec, 
	Maxilililililili...putánec, Lililililili...putánec,  Maxilililili...putánec,  Lililili...putánec, Maxilili...putánec, 
	Lili...putánec, Maxi...putánec a Maximaximaximaxi...putánec. A oni stáli usporiadaní pod¾a ve¾kosti !
	<br>
	A rozprávke je koniec. 
	<br>Hovorí sa, e kadá rozprávka má mravné ponauèenie. Táto nás okrem mnohého iného nauèila aj novú metódu ako utriedi prvky.
	Teraz si to vysvetlíme na palièkách. Sú neutriedené. Vypoèítame medián ( prvok ve¾kosti, pod¾a ktorej budeme rozde¾ova ).  
	Policajti pôjdu sprava a z¾ava. Ten, èo ide sprava, h¾adá väèších od seba.
	Ten, èo ide z¾ava, h¾adá menších od seba. Ak jeden z nich nájde palièku zlej vıšky, poèká kım nájde aj ten druhı. 
	Potom si ich vymenia a h¾adajú ïalej, a kım sa nestretnú. Tam, kde sa stretnú, vytvoria hranicu. Tım vzniknú dve
	skupiny, z ktorıch kadú utriedime tak ako tú prvú. Èie znova vypoèítame medián a rozde¾ujeme ... Toto delenie robíme, 
	kım má naša skupina viac ako jednu palièku. Takú skupinu u toti netreba triedi.
	Zvláštnosou tohto triedenia je to, e je rekurzívne. To znamená zvıšené nároky na pamä poèítaèa. Ukázalo sa, e rozhodujúcim
	èinite¾om úspešnosti triedenia je správny vıber mediána. Ak toti zoberieme ako medián najmenší prvok, tak dostaneme prvú 
	skupinu jednoprvkovú. A našou snahou je rozdeli postupnos pokia¾ mono na polovice. Vıber správneho mediána je ale rovnako 
	zloitı problém ako samotné triedenie, preto sa medián volí náhodne, napr. aritmetickı priemer prvého a posledného prvku,
	prípadne hodnota nejakého prvku (prvého, posledného, stredného)
<TABLE cellSpacing=0 width="80%" align='center' bgColor='white' border=1>
         <TR><TD vAlign=" top" bgColor='#99cccc'><P><I>Triedenie Quick</I> </P>
         <TR><TD vAlign=top><PRE>void rozdel(int *a, int left,int right);
{  i = left; j = right;
   x = a[(left+right+)/2];
   while (i<=j)
   {  while (a[i] &lt; x) i++;
      while (a[j] &gt; x) j--
	  if (i&lt;=j)
	  {  p=a[i]; a[i]=a[j]; a[j]=p;
	     i++; j--;
	  }
   }
   if (left &lt;j) quick(left,j);
   if (i&lt; right) quick(imright);
}
				   
void quick(int *a,int n);
{
    rozdel(a,1,n)
}</pre>   	
</table>
Program je jednoduchı. Zavolá iba rekurzívnu procedúru rozde¾, ktorá miesto neho všetko urobí.

	<dt class=main>D O B O S I E W I C Z  -  S O R T
	<dd>Toto triedenie je zaloené na triedení pretriasaním, alebo shakersorte. Bolo by dobré pozrie si najprv to.
	Ak ste to zvládli, môme sa venova dobosiewiczsortu. Odkia¾ také aké meno ?  Po autorovi triedenia, pánovi po¾ského pôvodu, 
	menom Dobosiewicz. Èím takım sa preslávil ?  Vymyslel triedenie, ktoré sa ve¾mi podobá triedeniu pretriasaním s ubúdajúcim krokom. 
	Teda jednoducho povedané vyuil myšlienku vımen na dlhé vzdialenosti v triedení pretriasaním. Pritom neobjavil niè nové, 
	iba spojil to, èo vyuili iní. To však nebol koniec. On ešte takéto triedenie vylepšil ekonomickejšou réiou. Èo to znamená, 
	uvidíme neskôr.
	<br>
	Ste na prvej hodine telocviku a  postavili ste sa do radu ako prišlo. Je vás, dajme tomu, 32. Uèite¾ vás zaèal usporadúva. 
	Porovnal prvého s dvadsiatympiatym. Ak bol prvı väèší, vymenil ich; ak nie nechal tak.
	Potom vybral 2. a 26. Rovnakım spôsobom ich porovnal, prípadne vymenil. Obdobne 3. a 27., ... Nakoniec porovnal 8. a 32.
	Teraz vypoèítal tri štvrtiny z 24 = 18. A zaèal zasa s porovnávaním : 14. s 32., 13. s 31., 12. s 30., 11. s 29., ... , 2. s 20. 
	a nakoniec 1. s 19. Preèo postupoval opaènım smerom ?  Aby aj tí malí mali šancu dosta sa rıchlo dopredu.
	Znova vypoèítal krok  ( 18 : 4 ) x 3 = 12 a porovnával tentoraz od zaèiatku : 1. s 13., 2. s 14., 3. s 15., ... , 19. s 31. 
	a napokon 20. s 32. ïalej pokraèoval s krokom 9 od konca : 23. s 32., 22. s 31., ... , 2. s 11. a 1. s 10.
	<br>Kedy skonèil ?  Vtedy, keï krok bol rovnı 1 !
	Aké odlišnosti od shakersortu s ubúdajúcim krokom ste zistili ?
	<br>
	Vysvetlíme si to  na situácii s krokom 9.  V shakersorte s ubúdajúcim krokom by sme prvky : 1., 10., 19. a 28. utriedili shakersortom. 
	No my namiesto toho porovnáme a keï treba vymeníme 1. s 10., 10. s 19. a 19.s 28. Niè viac !  Podobnos na shakersort s ubúdajúcim 
	krokom je len povrchná. Vskutku originálnym spôsobom je tu vyuitá myšlienka vımen na ve¾ké vzdialenosti. 
	Pri zachovaní koeficientu 3/4 sa zdá by toto triedenie najúèinnejšie (porovnate¾né  vısledky  sa dajú  dosiahnu s koeficientom 2/3).
    <TABLE cellSpacing=0 width="80%" align='center' bgColor='white' border=1>
    <TR><TD vAlign=" top" bgColor='#99cccc'><P><I>Triedenie dobosievicz</I> </P>
    <TR><TD vAlign=top><PRE>
Procedure dobosievicz;
Var p,i,j,k:integer;
    h,m,s,ss:WORD;
Begin
  h:=Pocet div 3;
  while h>2 do
  begin
    i:=pocet;
    j:=i-h;
    while j>0 do
    BEGIN
      if a[i]&lt;a[j] then
      Begin
        p:=a[i]; a[i]:=a[j]; a[j]:=p;
      End;
      dec(i);dec(j);
    END;
     h:=3*h div 4;

    i:=1+h;
    j:=1;
    while i&lt;=Pocet do
    BEGIN
      if a[i]&lt;a[j] then
      Begin
        p:=a[i]; a[i]:=a[j]; a[j]:=p;
      End;
      inc(i);inc(j);
    END;
     h:=3*h div 4;
  end;

  a[0]:=0;
  for i:=2 to Pocet do
  BEGIN
    p:=a[i];j:=i-1;
    while p&lt;a[j] do
    Begin
      a[j+1]:=a[j];
      dec(j);
    End;
    a[j+1]:=p;
  END;
End;

</pre>
</table>
<br>V jednoduhšej variante namiesto pretriasania môme da bublinky len jednosmerové, program sa skráti a na èase sa to moc neprejaví.

	<dt class=main>M E R G E  -  S O R T
	<dd>Alebo triedenie zluèovaním. Dôvod tohto názvu pobadáme za chví¾u. Teraz poïme na hodinu telocviku. Uèite¾ béèkarov ochorel, 
	tak ste mali telocvik spolu s nimi. Na zaèiatku ste sa postavili obidve triedy osve. Áèka na jedno miesto a béèka na druhé, 
	ale obe skupiny boli zoradené pod¾a ve¾kosti. Ako ich èo najrıchlejšie usporiada do jednej skupiny pod¾a ve¾kosti?  
	Uèite¾ to urobil takto :  zobral najmenších ( prvıch ) z oboch skupín,  porovnal ich; menšieho postavil  na zaèiatok nového 
	radu a  k väèšiemu zavolal ïalšieho ( druhého ) z tej skupiny, do ktorej on nepatril. Tıchto dvoch  opä porovnal a menšieho 
	zaradil  na druhé miesto novej skupiny. K tomu, èo zostal, zasa pridal ïalšieho z tej skupiny, do ktorej nepatril. 
	Takto vytváral novú skupinu bez problémov a do chvíle, keï sa mu chalani z jednej skupiny minuli. S tım si však poradil bez
	problémov. Jednoducho ich všetkıch rad radom presunul do novej skupiny presne v tom poradí, v akom stáli. A mal ich usporiadanıch.
	Takıto postup sa nazıva zluèovanie. Ide tu v podstate o zlúèenie dvoch usporiadanıch skupín tak, aby sa zachovalo usporiadanie. 
	Táto metóda je jednoduchá, ale ako ju vyui na triedenie ?  Veï jej predpokladom je existencia utriedenıch skupín. 
	Ako vyrieši tento problém si vysvetlíme na triedení kariet. Máme kopu neutriedenıch kariet. Rozdelíme ju trebárs na polovice. 
	Ak by boli usporiadané, vedeli by sme ich zlúèi a neporuši usporiadanie. Ale to sa nestalo. Tak zoberieme prvú skupinu 
	a znova ju rozdelíme na polovice.  Tu si môeme zopakova :  ak by boli utriedené obe skupiny, vedeli by sme ich zlúèi ...
	<br>Keïe však nie sú, pokraèujeme v rozde¾ovaní. Vzniká vána námietka : budeme ma po nejakom n-tom rozdelení u usporiadané 
	obe skupiny ?  Ja tvrdím, e áno ! Bude to vtedy, keï obe skupiny budú najviac jednoprvkové. Je bez pochybností, 
	e kadá jednoprvková skupina je utriedená, teda vtedy skonèíme rozde¾ovanie a zaèneme zluèovanie. Po zlúèení dostaneme 
	napr. dvojprvkovú skupinu. Mali by sme ju zlúèi s ïa¾šou dvojprvkovou z predchádzajúceho delenia. Tá však ešte nie usporiadaná. 
	Tak rozdelíme aj ju na dve jednoprvkové. Tie sú u utriedené, tak ich môeme zlúèi. Vısledok zasa zlúèime pod¾a uèite¾ovej 
	metódy na štvorprvkovú skupinu. Atï...

	Problémom zostáva u len aplikácia postupu v programe. Jednotlivé èinnosti si môme rozdeli na tieto základné : 
	<br>rozde¾, zlúè. 
	<br>To budú aj názvy dvoch podstatnıch procedúr. Zostal u len jeden vány problém.  Kam uklada postupnos, ktorú vytvárame 
	pri zluèovaní ?   Riešenie :  vyuijeme nejaké iné pole, napr. k tomu nášmu zrkadlovo obrátené. Presnejšie to bude pole a(-1), a(-2),
	a(-3), ...  Teda na zápornom úseku vytvoríme zlúèené pole a potom ho len prenesieme do kladnej èasti.
</dl>
<br><a href="p-demo.html" target="obsah">Demo</a>

</body>
</html>
