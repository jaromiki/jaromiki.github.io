<html>
<head>
	 <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1250">
	 <meta name="Content-language" content="sk">	
	 <meta name="autor" content="RNDr. Jaroslav Mikuláš">	
 	<META http-equiv="Page-Enter" content="blendTrans(Duration=1)">
	  <LINK href="../../css/style.css" type="text/css" rel=stylesheet>
</head>

<body>
<h3>Dynamické polia</h3>
Dynamické polia sú také, ktoré uívate¾ vytvára a za behu programu, mení jeho ve¾kos a odstraòuje ho keï ho u nepotrebuje.
<br>Pozn. 
<br>Pokroèilejšie objekty, ktoré mono pouíva ako pole mono nájs v kap. kninica STL 
<dl><dt>Deklarácia
	<dd><code>typ *nazov; &nbsp; &nbsp; &nbsp;//napr. int *pole</code>
		<br>Do takto vytvorenej premennej mono zapisova adresu nejakého objektu v pamäti poèítaèa, my v tejto èasti budeme v pamäti vytvára polia
		a ich adresu budeme ma odpamätanú v takejto premennej. 
		<br>V takto vytvorenej premennej bude odloená adresa zaèiatku po¾a. Zadeklarovaním premennej ešte pole neexistuje a teda ho nemôeme ešte pouíva 
		(musíme ho najprv vytvori) 
	<dt>Vytvorenie po¾a
	<dd>Dynamické polia mono v pamäti vytvori starším spôsobom pomocou príkazov:
		<br>(nachádzajú sa v kninici stdlib.h, resp. cstdlib)  
		<ul><li>void * malloc(int size)
				<br>funkcia v halde alokuje predpísanı poèet bajtov a adresu na danı objekt vráti ako návratovú hodnotu.
					<code><br>int *p;
						<br>p=(int *) malloc(10*sizeof(int));  &nbsp; &nbsp;//vytvori v pamäti priestor pre 10 integer premennıch a adresu prvého zapíše do prem. p
					</code>
					<br>Dôleité 
					<li>návratovú adresu, ktorú nám vracia funkcia malloc musíme vdy pretypova pod¾a toho na akı typ ukazuje
					<li>ve¾kos priestoru musíme vdy vypoèíta }poèet_prvkov * sizeof(typ)
					<li>takto vytvorené pole má neznáme hodnoty
		 	<li>void * calloc(int pocet, int size)		
				<br>funkcia v halde alokuje predpísanı poèet objektov - <b>pocet</b> - prièom kadı objekt má dåku <b>size</b>, 
				celková dåka alokovanéko priestoru bude: pocet * size, adresu na danı objekt vráti ako svoju návratovú hodnotu. 
				Na rozdiel od funkcie malloc sú všetky poloky inicializované na hodnotu 0, preto táto funkcia je pomalšia.
				<code><br>int *p;
				<br>p=(int *) calloc(10,sizeof(int)); 
				</code>
				<br>vytvori priestor pre 10 integer premennıch a adresu prvého zapíše do prem. p
			<li><code>void* realloc (prem_pointer, int size)</code>
				<br>Táto funkcia premennej <b>prem_pointer</b> zmení ve¾kos patriaceho po¾a. Zmena môe by smerom nahor (pole sa zväèší) ale aj nadol.
				V prípade potreby bude pole presunuté na nové miesto v pamäti (pole musí by v pam. súvislé), funkcia vráti adresu tohoto miesta.
				<br>Pri zväèšovaní po¾a sa chová ako calloc().
			<li><code>void  free(void * prem)</code>
				<br>Uvolnenie premennej z haldy, pamä premennej prem sa tımto uvolní (hodnota/adresa zapísaná v prem. sa nemení - stále ukazuje na rovnakú pamä, ale pamä je u vo¾ná pre systém)
 				<br>Ak by v premennej bol NULL pointer, tak funkcia nerobí niè.  	

		</ul>
	<dt>Vytvorenie po¾a	- novší spôsob
	<dd>Novší spôsob je vytváranie po¾a pomocou operátora new (volanie operátora je rıchlejšie ako volanie podprogramu a je to aj uívate¾sky priate¾skejšie)
		<br>Popíšem pouitie na príklade
		<br><code>int *p1, *p2; 
		<ul><li><code>p1 = new int[100]; &nbsp; &nbsp;//vytvori pole 100 intov
				<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//v pripade neuspechu vyvola vynimku
			<li>p2 = new (std::nothrow)int[50]; &nbsp; &nbsp;//vytvori pole 50 intov 
				<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//v pripade neuspechu nevyvola vynimku ale vrati NULL pointer
				<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//aby slovo <b>nothrow</b> potrebujeme pripnut niektoru kniznicu STL (napr. #include &lt;new &gt;)
			<li>delete[] p1; &nbsp; &nbsp;//zrusi pole
		</ul>
		Nemáme nástroje na resize po¾a, ak chceme pole zväèšova alebo zmenšova musíme si to naprogramova sami (lepšie je poui objekt vector namiesto po¾a - pozri STL).
				


</body>
</html>
