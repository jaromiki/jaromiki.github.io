<html>
<head>
	 <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1250">
	 <meta name="Content-language" content="sk">	
 	<META http-equiv="Page-Enter" content="blendTrans(Duration=1)">
	  <LINK href="../../css/style.css" type="text/css" rel=stylesheet>
</head>

<body>
<dl>
<dt class=main>Operácie s prvkami po¾a
<dd>Tu u budeme predpoklada, e pole je u naplnené, poprípade aj vypísané na kontrolu správnosti naèítania. Teraz si ukáeme ako môme poloky po¾a meni, h¾ada v nich hodnoty a pod. 
Postupne si ukáeme postupy pri nasledovnıch úlohách:
<ul><li>Zmena jednej poloky po¾a
	<li><a href="#zmena1">Zmena všetkıch poloiek po¾a</a>
	<li><a href="#zmena2">Zmena nieko¾kıch poloiek po¾a</a>
	<li><a href="#hladanie1">H¾adanie hodnoty v neutriedenom poli</a>
	<li><a href="#hladanie2">H¾adanie hodnoty v utriedenom poli</a>
	<li><a href="#hladanie3">H¾adanie poètu vıskytov hodnoty v poli</a>
	<li><a href="#hladanie4">H¾adanie maximálnej hodnoty v poli</a>
	<li><a href="#sucet">Vıpoèet súètu/priemeru èísel v poli</a>
	<li><a href="#vlozenie">Vkladanie nového èísla do utriedeného po¾a</a>
	<li><a href="#rusenie">Rušenie èísla z utriedeného po¾a</a>
	<li><a href="#rotacia">Rotácia prvkov po¾a</a>
</ul>	
<dt>Zmena jednej hodnoty
<dd>Situácia môe by dvojaká:
	<ul><li>adresu (index) prvku, ktorı chceme meni u máme v premennej <b>KAM</b>
			<br>potom staèí uívate¾ovi zada novú hodnotu do Editu (alebo InputBoxu) a zapísa ju do pola do bunky KAM
			<br><code>Pole[KAM] = StrToInt(Edit1->Text);</code>
		<li>necháme uívate¾a, aby si sám urèil ktorá bunka sa má meni. Potrebujeme teda dve hodnoty.
			<br><code>KAM = StrToInt(Edit1->Text);
			<br>Pole[KAM] = StrToInt(Edit1->Text);</code>
			<br><br>alebo pouitím InputBoxu: 
			<br><code>KAM = StrToInt(InputBox("Index", "Zadaj index po¾a",1);
			<br>Pole[KAM] = StrToInt(InputBox("Hodnota prvku è.:"+IntToStr(KAM), "Zadaj novú hodnotu:",0));</code>
	</ul>		
<a name="zmena1"><dt>Zmena všetkıch poloiek po¾a</a>
<dd>chceme napr. zväèši hodnotu v kadej bunke o 1. Urobíme to nasledovne:
	<TABLE cellSpacing=0  bgColor=white border=1> 
	<TR><TD bgColor=#99cccc><I>zmena prvkov po¾a o 1</I></tr>
	<TR><TD style="padding:5" vAlign=top>
				<code><b>for</b> (i=0;i&lt;n;i++) pole[i]++;</code></tr>
			</table>
<a name="zmena2"><dt>Zmena niektorıch poloiek po¾a</a>
<dd>Nech máme zmeni všetky záporné poloky po¾a na hodnotu -1 a všetky kladné na hodnotu 2. Postup bude nasledujúci:
	<TABLE cellSpacing=0  bgColor=white border=1> 
	<TR><TD bgColor=#99cccc><I>zmena prvkov po¾a</I></tr>
	<TR><TD style="padding:5" vAlign=top>
				<code><b>for</b>(i=0;i&lt;n;i++) 
				<br>{  if (pole[i]&lt;0) pole[i] = -1;
				<br> &nbsp; &nbsp; &nbsp;else if (pole[i]&gt;0) pole[i]=2; 
				<br>}</code></tr>
			</table>

<a name="hladanie1"><dt>H¾adanie hodnoty v neutriedenom poli</a>
<dd>Máme zisti, èi sa v poli niekde na indexoch 1 a N nachádza hodnota X. Vısledkom môe by:
	<ul><li>hodnota (TRUE alebo FALSE) v logickej premennej (napr. NASIEL)
		<li>vıpis, oznam o vısledku h¾adania v Edite
		<li>poradové èíslo kde našiel prvı krát h¾adanú hodnotu zapísané v premennej (Napr. KDE)
			(Ak sme nenašli v poli h¾adanú hodnotu zapíšeme do kde 0)
	</ul>	 
  V nasledovnej ukáke urobím všetky odpovede.
	<TABLE cellSpacing=0  bgColor=white border=1> 
	<TR><TD bgColor=#99cccc><I>h¾adanie hodnoty v poli</I></tr>
	<TR><TD style="padding:5" vAlign=top>
				<code>NASIEL = 0; &nbsp; &nbsp; &nbsp;//zatial som nenasiel
				<br>KDE = -1; &nbsp; &nbsp; &nbsp;//zatial som nenasiel
				<br>Edit1->Text = "nenasiel"; &nbsp; &nbsp; &nbsp;//zatial som nenasiel
				<br><b>for</b> (i=0;i&lt;n; i++) 
				<br> &nbsp;if (pole[i]=X) 
				<br> &nbsp;{ NASIEL = 1;
				<br> &nbsp; &nbsp; &nbsp; &nbsp;KDE = i; &nbsp; &nbsp; &nbsp;//zapíšem si kde sa to stalo 
				<br> &nbsp; &nbsp; &nbsp; &nbsp;Edit1->Text = "nasiel";
				<br> &nbsp; &nbsp; &nbsp; &nbsp;break; &nbsp; &nbsp; &nbsp;//cyklus môem skonèi
				<br> &nbsp;}
				<br>}</code></tr>
			</table>
	Myšlienka je teda, e pred cyklus natipujem odpovede, e som nenašiel a v cykle, ak nájdem, tak tie odpovede opravím.
	Po nájdení prvej h¾adanej hodnoty cyklus ukonèím príkazom <b>break</b> (program bude pokraèova za príkazom cyklu). 
	Programátorov zaujímala stredná hodnota poètu poloiek, ktoré musíme skontrolova, kım nájdeme poadovanú hodnotu
	a štatistika vraví, e N/2 (kde N je poèet poloiek po¾a). 
	<br>Je to ako keï v hoteli h¾adáme ubytovaného kamaráta - do ko¾kıch izieb musíme priemerne nakuknú kım ho nájdeme
	<br>Ak sú poloky v poli poukladané pod¾a ve¾kosti (utriedené) vieme to spravi omnoho rıchlejšie.

<!--                 H L A D A N I E   V   U T R I E D E N O M  P O L I          -->	
<a name="hladanie2"><dt>H¾adanie hodnoty v utriedenom poli</a>
<dd>Nech poloky po¾a sú utriedené od najmenšieho po najväèšie (ak sú niektoré poloky rovnaké - to nevadí). 
	<br>Hodnotu X budeme h¾ada v indexoch od a=1 po b=N. Pri h¾adaní hodnoty X v poli pouijeme nasledovnú fintu:
	<br> Vypoèítam si index stredného prvku nášho intervalu:
		<br> &nbsp; &nbsp;<code>ab = (a+b)/2;</code>
	<br>môu nasta prípady
		<br> &nbsp; &nbsp;pole[ab] == X, to je najlepší prípad, našli sme môeme konèi
		<br> &nbsp; &nbsp;pole[ab] &gt; X, zmeníme b = ab-1; &nbsp; h¾adanie u robíme len v¾avo
		<br> &nbsp; &nbsp;pole[ab] &lt; X, zmeníme a = ab+1; &nbsp; h¾adanie u robíme len v¾avo
		<br>teraz ak a>b, tak sme nenašli môme konèi
	<br><br>Naprogramované môe vyzera nasledovne
	<TABLE cellSpacing=0  bgColor=white border=1> 
	<TR><TD bgColor=#99cccc><I>h¾adanie hodnoty v utriedenom poli</I></tr>
	<TR><TD style="padding:5" vAlign=top>
				<code>int A = 0; &nbsp; &nbsp; &nbsp;//dolná hranica indexu odkade h¾adáme
				<br>int B = N; &nbsp; &nbsp; &nbsp;//holná hranica indexu pokade h¾adáme
				<br>int AB; &nbsp; &nbsp; &nbsp;//stred intervalu

				<br>int KDE = -1; &nbsp; &nbsp; &nbsp;//zatia¾ som nenašiel
				<br>while (A &lt;= B) 
				<br>{
				<br> &nbsp; &nbsp; AB = (A+B) / 2;
				<br> &nbsp; &nbsp;if (Pole[AB] == X) { KDE = AB; break; }
				<br> &nbsp; &nbsp;if (Pole[AB] &gt; X) B = AB-1; 
				<br> &nbsp; &nbsp;if (Pole[AB] &lt; X) A = AB+1;
				<br>} 
                                <br>if (KDE>-1) {;}   // nasiel
                                <br>else {;}          // nenasiel 
				</code></tr>
	</table>			
	Programátorov zaujímala stredná hodnota poètu poloiek, ktoré musíme skontrolova, kım nájdeme poadovanú hodnotu
	a štatistika vraví, e je to log<sub>2</sub>(N) (kde N je poèet poloiek po¾a).
	Tento rozdiel oproti predošlému príkladu (neutriedené) je obrovskı. Napríklad:
	<table border="1">
	<tr><th>poèet prvkov<th>poèet h¾adaní<br>neutriedené<th>poèet h¾adaní<br>utriedené</tr>
	<tr align="center"><td>1 000<td>500<td>10</tr>
	<tr align="center"><td>1 000 000<td>500 000<td>20</tr>
	<tr align="center"><td>1 000 000 000<td>500 000 000<td>30</tr>
	</table>
	<br>Dôsledok
	<br>Ak sa vo ve¾kom poli bude èasto h¾ada, je dobré ma to pole utriedené - ako pole utriedi je samostatná téma pri poli.
    <br>Úloha
	<br>skús naprogramova <a href="ulohy/hadanie.exe">"hádanie èísel"</a>
<!--                 H L A D A N I E   P O C T U   V Y S K Y T O V                   -->	

	<a name="hladanie3"><dt>H¾adanie hodnoty - poèet vıskytov </a>
	<dd>Niekedy nestaèí zisti, èi sa daná hodnota v poli nachádza, ale chceme zisti ko¾ko krát sa nachádza. V neutriedenom poli sa úloha od predošlej líši v tom,
		e po nájdení hodnoty nemôme h¾adanie ukonèi, ale musíme preh¾adáva do konca po¾a a pri nájdení h¾adanej hodnoty si nejakú pomocnú premennú zväèšíme o 1. 
	<TABLE cellSpacing=0  bgColor=white border=1> 
	<TR><TD bgColor=#99cccc><I>h¾adanie hodnoty v poli</I></tr>
	<TR><TD style="padding:5" vAlign=top>
			<code>{ POCET = 0; &nbsp; &nbsp; &nbsp;//zatial som nenasiel
			<br><b> for</b> (i=0; i&lt;n; i++) 
			<br> &nbsp; if (pole[i]==X) POCET++;
			<br>}</code></tr>
	</table>
<!--                 H L A D A N I E   M A X I M A                                   -->	

	<a name="hladanie4"><dt>H¾adanie maximálnej hodnoty v poli</a>
	<dd>Ide o èastú úlohu, pri h¾adaní algoritmu treba porozmıšla ako by sme tento problém riešili bez poèítaèa (poèítaèové algoritmy sa èasto inšpirujú benım ivotom èloveka).
		Napr. na dvore školy sú nastúpenı všetci iaci a my chceme nájs najvyššieho. Návod môe by nasledovnı:
		<ul><li>tipneme, e najväèší je prvı iak a zoberieme ho z radu
			<li>postupne ho porovnávame s ïalšími, prièom ak nájdeme niekoho väèšieho, tak toho menšieho pošleme zaradi sa kde bol a väèšieho si vytiahneme k sebe
			<li>keï dôjdeme na koniec radu, máme pri sebe toho najvyššieho
		</ul>
		no a na poèítaèi to môe by nasledne:
	<TABLE cellSpacing=0  bgColor=white border=1> 
	<TR><TD bgColor=#99cccc><I>h¾adanie hodnoty v poli</I></tr>
	<TR><TD style="padding:5" vAlign=top>
			<code>{ KDE = 0; &nbsp; &nbsp; &nbsp;//tipol som, kde je najväèšie èíslo
			<br><b> for</b> (i=1; i&lt;n;i++) 
			<br> &nbsp; if (pole[KDE] &lt; pole[i]) KDE = i; &nbsp; &nbsp; &nbsp;//ak nájdem väèšieho tip upravím
			<br>}
			<br>//a tu viem, e najväèšie èíslo je na adrese <b>KDE</b> a najväèšia hodnota je <b>pole[KDE]</b>.
			</code></tr>
	</table>
	
	<!--                 H L A D A N I E   S U C T U                                     -->	
<a name="sucet"><dt>Vıpoèet súètu/priemeru prvkov po¾a</a>
	<dd>Myšlienka je jednoduchá, vytvoríme si premennú SUCET do ktorej dáme nulu. Prejdeme postupne všetkımi polokami po¾a a kadú pripoèítame do SUCET.
		Po prejdení po¾a bude v premennej SUCET súèet všetkıch prvkov. 
	<TABLE cellSpacing=0  bgColor=white border=1> 
	<TR><TD bgColor=#99cccc><I>Vıpoèet súètu a priemeru z poloiek po¾a</I></tr>
	<TR><TD style="padding:5" vAlign=top>
			<code>{ SUCET = 0; &nbsp; &nbsp; &nbsp;//zatia¾ je súèet nula
			<br><b> for</b> (i=0; i&lt;n; i++) 
			<br> &nbsp; SUCET += pole[i]; &nbsp; &nbsp; &nbsp;//kadé èíslo pripoèítam ku SUCET
			<br>}
			<br>//cyklus skonèil -&gt; súèet u mám
			<br>PRIEMER = 1.0*SUCET / N; &nbsp; &nbsp; &nbsp;//priemerná PRIEMER by mala by desatinná
			<br>}</code></tr>
	</table>
	
	<!--                 V L O Z E N I E   C I S L A                                     -->	
	<a name="vlozenie"><dt>Vkladanie nového èísla do utriedeného po¾a</a>
	<dd>Èastım prípadom je e prvky po¾a máme utriedené a máme do po¾a prida nové èíslo a samozrejme chceme aby pole aj po pridaní bolo utriedené.
		<br>Predpoklady:		 
		<br>Nech poèet èísel v poli je N a nové èíslo máme v premennej CISLO
		<br>Postup pozostáva z dvoch krokov
		<ul><li>nájdenie miesta medzi ktoré èísla chceme nové èíslo vloi
			<li>odsunutie tıch èísel, ktoré sú od nového väèšie o jedno miesto vpravo
			<li>vloenie na nového èísla na uvolnené èíslo
		</ul>
		H¾adanie miesta kam máme vloi nové èíslo môme robi odpredu po¾a alebo od konca po¾a. ¼ahko zistíme, e ak to budeme zisova od konca, tak to
		môme vıhodne spoji s odsúvaním tıch väèších èísel. 		
	<TABLE cellSpacing=0  bgColor=white border=1> 
	<TR><TD bgColor=#99cccc><I>Vsúvanie èísla do utriedeného po¾a</I></tr>
	<TR><TD style="padding:5" vAlign=top>
			<code>i = N-1; &nbsp; &nbsp; &nbsp;//odtia¾to zaèneme h¾ada a odsúva
			<br>while (i&gt;=0 && pole[i]>CISLO) do 
			<br>{
			<br> &nbsp; pole[i+1] = pole[i]; &nbsp; &nbsp; &nbsp;//ak si väèší ako novı posuò sa doprava 
			<br> &nbsp; i--;
			<br>}
			<br>pole[i+1] = CISLO; &nbsp; &nbsp; &nbsp;//na uvolnené èíslo vloíme nové èíslo
			</code></tr>
	</table>
	
	<!--                 R U S E N I E   C I S L A                                     -->	
	<a name="rusenie"><dt>Rušenie prvku v poli</a>
	<dd>Rušením K-teho prvku v poli rozumieme posunutie všetkıch èísel napravo od neho o 1 miesto v¾avo (ako keï z police kníh odstránime jednu a všetky napravo od nej 
		posunieme o jedno miesto v¾avo). 
	<TABLE cellSpacing=0  bgColor=white border=1> 
	<TR><TD bgColor=#99cccc><I>Rušenie K-teho èísla v poli</I></tr>
	<TR><TD style="padding:5" vAlign=top>
			<code>//predpokladám, e v poli nejaké èísla mám (N&gt;0) a ešte (0 &lt;=K &lt;= N-1)
			<br>for (i = K+1; i&lt; N; i++) &nbsp; &nbsp; &nbsp;//všetky èísla od (K+1) do konca sa posunú o 1 v¾avo
			<br> &nbsp; Pole[i-1] = Pole[i]; 
			<br>N--; &nbsp; &nbsp; &nbsp;//nesmieme zabudnú upravi poèet èísel v poli  
			</code></tr>
	</table>
	
	<!--                 R O T A C I A   P O L A                                     -->	
	<a name="rotacia"><dt>Rotácia po¾a</a>
	<dd>Pod rotáciou po¾a vpravo rozumieme posun všetkıch prvkov (okrem posledného) o jedno miesto vpravo a poslednı prvok sa presunie do do poloky èíslo 1.
		<br>(Pohyb poloiek po¾a pripomína krútivı pohyb na kolotoèi)
		<br>Obyèajne pod rotáciou automaticky myslíme posúvanie o jedno miesto vpravo ale myšlienku mono zovšeobecni na rotaciaN, ktorá posúva prvky o N miest.
		<br>Podobne mono zadefinova rotáciu v¾avo.
		<br>No a teraz ako by to bolo na poèítaèi
		<TABLE cellSpacing=0  bgColor=white border=1> 
		<TR><TD bgColor=#99cccc><I>Rotácia po¾a vpravo o 1</I></tr>
		<TR><TD style="padding:5" vAlign=top>
			<code>pom = Pole[N-1]; &nbsp; &nbsp; &nbsp;//posledné èíslo si odloím nabok
			<br>for (i = N-2; i>=0;i--) Pole[i+1] = Pole[i]; &nbsp; &nbsp; &nbsp;//kadé èíslo sa posunie doprava
			<br>Pole[0] = pom; &nbsp; &nbsp; &nbsp;//odloené èíslo zapíšem na uvo¾nené miesto
		</code></tr>
		</table>	
		Pozn.
		<br>Naprogramujte to s vıpisom do StringGrid (ståpec 0 pred rotáciou, ståpec 1 po rotácii)
		<br>Porozmıš¾ajte ako efektívne urobi rotáciu o K miest
	<dt>ïalšie zaujímavé úlohy
	<dd><ul>
		<li>h¾adanie najdlhšej súvislej rastúcej oblasti v poli
		<li>problém dvojfarebnıch hrnèekov - ako ich najrıchlejšie utriedi
		<li>problém trojfarebnıch hrnèekov - ako ich najrıchlešie utriedi
		<li>h¾adanie najdlhšej nesúvislej rastúcej podpostupnosti z postupnosti zapísanej v poli
		<li>h¾adanie súvislej podoblasti po¾a s maximálnym súètom
		<li>h¾adanie súvislej podoblasti po¾a so súètom najbliším èíslu Z
		<li>majmä postupnos {a<sub>i</sub>}=1,3,9,27,81,... a èíslo Z&gt;0
			<br>zapíšte èíslo Z v tvare c<sub>1</sub>*1 + c<sub>2</sub>*3+c<sub>3</sub>*9 + c<sub>4</sub>*27 + ..., kde c<sub>i</sub> je z mnoiny {-1;0;+1}
			a vypíšte nenulové sèítance
		<li>Zisti ko¾ko rôznych postupností dåky n sa dá vytvori z èísel {0,1} ak nuly nesmú by dve za sebou	
		<li>Máme dané poukáky v hodnote 7€ a 17€ (nekoneèné mnostvo), treba zaplati sumu  Z€, zisti èi sa dá zaplati presne len poukákami 	
		<li>Máme dané poukáky v hodnote 7€, 13€ a 21€ (nekoneèné mnostvo), treba zaplati sumu  Z€, zisti èi sa dá zaplati presne len poukákami
		<li>Máme dané poukáky v hodnote 7€, 13€ a 21€ (v poète n<sub>7</sub>, n<sub>13</sub>, n<sub>21</sub>), treba zaplati sumu  Z€, zisti èi sa dá zaplati presne len poukákami
		<li>v n prvkovom poli sú èísla od 1 po 1000. Zisti, ktoré èíslo sa vyskytuje najèastejšie
		<li>máme N dominovıch kockiek (na kadej koske sú dve èísla) a èíslo Z. Urète natoèenie kociek aby (súèet vrchnıch èísel) mínus (súèet dolnıch èísel) bol
			najbliie ku èíslu Z
		<li>Problém alkoholika
			<br>na dlhej polici sú flaše s alkoholom, v kadej je nejaké nenulové mnostvo alkoholu a<sub>i</sub>. Nesmieme flaše prehadzova, zvolenú flašu
			musíme dopi dodna a po skonèení pitia nesmú vzniknú 2 (alebo N) prázdne f¾aše za sebou
			<br>Ko¾ko sa dá vypi najviac
		<li>Problém zlodeja
			<br>Je N rôznych tovarov a o kadom tovare je zadané 
				<br>-poèet kusov p<sub>i</sub>
				<br>-váha jedného kusa m<sub>i</sub>
				<br>-cena jedného kusa c<sub>i</sub>	
				<br>ïalej je daná nosnos našeho auta NOS
				<br>Zistite aká najväèšia hodnota sa dá ukradnú
		<li>Permutácie
			<br>Máme 4-prvkové pole, kde poloky po¾a sú rôzne  - vypíš všetky permutácie po¾a
			<br>Zmeò na 5-prvkové pole
			<br>Zmeò na N-prvkové pole
		<li>Máme dve postupnosti A a B, kde poèet prvkov v poli A je PA a poèet prvkov v poli B je PB
			<br>Zisti najdlhšiu spoloènú podpostupnos po¾a A a po¾a B, vısledok zapíš do po¾a C
		<li>Máme dve postupnosti A a B, kde poèet prvkov v poli A je PA a poèet prvkov v poli B je PB
			<br>Ko¾ko najmenej prvkov musíme prida/povsúva do polí A resp. B aby vznikli rovnaké polia 
		<li>Máme postupnos v poli A
			<br>Zisti, ko¾ko najmenej prvkov musíme vynecha aby vznikol palindrom (rovnaké poradie spredu aj od zadu)
		</ul>
<dt class=main>Príklady na precvièenie:
<dd><table cellspacing="20">
	<tr><td><img src="../obr/ktstrofa.png" border="0" alt="" height="50">		
	<td>
		<ol>
		<li>Naprogramuj: <a href="project1.exe">uloha</a> 
		<li>Napíš funkciu na vıpoèet súètu dvoch vektorov. 
			<br>Vygeneruj vektor1 a zobraz v memo1 (kadé èíslo je v samostatnom riadku) 
			<br>Vygeneruj vektor2 a zobraz v memo2
			<br>Súèet vektorov zobraz v memo3. 
		<li>Napíš funkciu na vıpoèet súètu dvoch matíc typu pole (10x10 dvojcifernıch).
			<br>Vygeneruj pole1 a zobraz v memo1 
			<br>Vygeneruj pole2 a zobraz v memo2
			<br>Súèet polí zobraz v memo3. 
	</ol></tr>	
	</table>
</dl>
</body>
</html>
