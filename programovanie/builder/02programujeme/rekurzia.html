<html>
<head>
	 <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1250">
	 <meta name="Content-language" content="sk">	
 	<META http-equiv="Page-Enter" content="blendTrans(Duration=1)">
	  <LINK href="../css/style.css" type="text/css" rel=stylesheet>
</head>

<body>
<h3 class=nadpis>Rekurzia</h3>
Vieme, e z podprogramu môme vola len tie podprogramy, ktoré sú z miesta volania vidite¾né. Vola mono "svoje deti" a starších 
bratov a tie kadı podprogram môe vola sám seba. Práve volanie seba má špeciálne vyuitie a nazıvame to "rekurzia".
<br>Rekurzia je podobná cyklu ale sú niektoré dôleité rozdiely:
<ul><li>Kadé volanie podprogramu (a teda aj volanie samo seba) vytvorí nové lokálne premenné. Kadı beh rekurzie je teda
		pamäovo nároènı - do zásobníka sa uloí 
		<ul type="square"><li>návratová adresa
			<li>lokálne premenné vèítane parametrov
		</ul>	 
	<li>Cyklus moe teoreticky zbehnú neobmedzenı poèet krát - rekurzia vdy narazí na hranicu urèenú ve¾kosou zásobníka
		(nieko¾ko 100kB) po prekroèení ktorého nastane error "Stack overflow"
	<li>kadı cyklus jednoducho mono nahradi rekurziou no nahradenie rekurzie je úloha niekedy ve¾mi obtiana	 
</ul>	
<dl><dt>Nekoneèná rekurzia
	<dd><TABLE cellSpacing=0 borderColorDark=white width="80%" align=center bgColor=white borderColorLight=gray border=1>
         <TR><TD vAlign=" top" bgColor=#99cccc><P><I>procedúra <B>pridaj</B> volá samu seba:</I> </P></TD></TR>
         <TR><TD vAlign=top><PRE>float s=0;
void pridaj()
{  s+=StrToFloatDef(InputBox(Vstup, Zadaj sumu, "1"),0);}

void __fastcall TForm1::Button1Click(TObject *Sender)
{
  pridaj();
}</PRE>
</TABLE>
	Úlohou procedúry je prida súètu <b>s</b> naèítané èíslo. Kadé volanie zapíše do zásobníka 
	<br> - návratovú adresu 32-bitov
	<br> - stringovú premennú s (náhodná hodnota)
	<br> - integerovú premennú i (náhodná hodnota)
	<br> - bajtovú premennú n (hodnota pod¾a hodnoty pri volaní)
	a nakoniec teda narazí na strop zásobníka a spadne s chybou "Preteèenie zásobníka". Nekoneèná rekurzia teda nemá v programovaní 
	vıznam lebo vedie zaruèene ku pádu programu.
	<dl><dt>Dôsledok
		<dd>Kadı "dobrı" rekurzívny podprogram má "nerekurzívnu" vetvu - vetvu, kde sa nenachádza volanie sama seba. Ináè povedané:
			<br><b>"kadı správny rekurzívny podprogram musí ma šancu nevola sám seba"</b>.  
   	</dl>

 	<dt class=second>Jednoduchá - chvostová rekurzia
	<dd>Chvostová rekurzia nastane vtedy, keï rekurzívna procedúra volá samu seba ako poslednı svoj príkaz. Takáto rekurzia sa ve¾mi
		¾ahko dá prepísa na cyklus. Jej pouitie je iba na cvièné úèely.
		<table cellSpacing=0 borderColorDark=white width="80%" align=center bgColor=white borderColorLight=gray border=1>
		<tr><th bgColor=#99cccc  align="left">Rekurzívna verzia
		<tr><td><pre>
long long faktorial(int n)
{ if (n) return n*faktorial(n-1);
  else return 1;
}  
void __fastcall TForm1::Button1Click(TObject *Sender)
{ Edit2->Text = IntToStr(faktorial(StrToInt(Edit1->Text)); }
</pre>
	<tr><th bgColor=#99cccc align="left">Nerekurzívna verzia
	<tr><td><pre>long long faktorial(int n)
{ for (int i=1,f=1;i&lt;n;i++) f*=i; 
  else return f;
}  
void __fastcall TForm1::Button1Click(TObject *Sender)
{ Edit2->Text = IntToStr(faktorial(StrToInt(Edit1->Text)); }
</pre>
</table>			
		Tu nemá zmysel pouitie rekurzie, lebo oproti iterácii je omnoho èasovo nároènejšia i ašie laditelná.
 	<dt>Pravá rekurzia
	<dd>Ak sa za rekurzívnym volaním nachádzajú ešte nejaké príkazy alebo ak rekurzívne voláme na viacerıch miestach 
		programu je prechod na nerekurzívny algoritmus zloitejší.   
		<br>Typické úlohy riešené rekurzívne:
		<dl><dt><font color="Blue">Rozde¾ a panuj</font>
			<dd>Ide o delenie úlohy nejakej zloitosti na 2 alebo viac podúloh menšej zloitosti. 
				<br>Typickımi úlohami sú napríklad:
				<ul><li>Naplò bunky po¾a "<b>pole</b>" indexu N1 ... N2 rovnakou hodnotou 1 bez pouitia cyklu
						<br>Myšlienka je rozdeli rozdeli úsek o dåke N2-N1+1 na menšie úseky. Úloha je zloitosti N2-N1+1 a mono
						ju deli na úlohu zloitosti 1 (úsek dåky 1) a N2-N1 alebo šikovnejšie je deli zloitos pribline
						ma rovnako zloité úseky.
						<table cellSpacing=0 borderColorDark=white width="80%" align=center bgColor=white borderColorLight=gray border=1>
						<tr><th bgColor=#99dddd  align="left">Naplnenie po¾a</tr>
						<tr><td><pre>
void plnenie(int pole[],int a,int b) &nbsp; &nbsp;//naplníme jednotkami
{  int s=(a+b)/2;
   if (b-a) {plnenie(a,s); plnenie(s+1,b);}
   else pole[a]=1;
}</pre></tr></table>
Dôkaz správnosti algoritmu je cez matematickú indukciu.
					<li>Hanojské vee
					<li><a href="permutacie.exe">Permutácia</a> n prvkov
					<li>Súèet ve¾kého poètu reálnych èísel v poli
				</ul>	
		    <dt><font color="Blue">Prehladávanie s návratom</font>
			<dd>Tie niekedy nazıvaná metóda<b> "pokus omyl"</b>. Ide o úlohy, keï je systém popísanı stavmi a prechodmi 
				z ktorého stavu mono prejs do ktorého. Našou úlohou bıva zisti èi existuje prechod zo stavu A do stavu B.
				<ul><li>Najznámejší príklad je klasické plošné bludisko, kde je úlohou nájs miestnos s nejakou vlastnosou. Pohyb
					po bludisku pripomína dávny príbeh z minulosti Tezeus &lt; -- > Minotaurus. Hrdina sa vyberie jednou z prístupnıch
					ciest, znaèí si kde u bol a keï sa nedá ís ïalej vráti sa spä. Touto metódou zaruèene prejdeme celé bludisko. 
				<br><a href='bludisko.exe'>stiahni</a>
					<li>Zistenie plochy najväèšieho ostrova na mape (mapa je napr. daná tabu¾kou, kde voda je napr. '.' a pevnina 'X')
					<li>problém 8 dám na šachovnici
				</ul>	
			<dt><font color="Blue">Rekuzívne obrázky</font>
			<dd>Ve¾mi pripomínajú úlohy Rozde¾ a panuj" ale ide o špecifické grafické úlohy a tak sa èasto uvádzajú samostatne. 
			<dt><font color="Blue">Špeciálne úlohy</font>
			<dd><ul><li>Bez po¾a a bez stringu naèítaj znaky ukonèené znakom Enter (#13) a vypíšte ich odzadu 
					<li>Riešenie diofantickıch úloh ax-by = 1, pre a,b>0 v obore Z<sub>0</sub><sup>+</sup> 
						<br>(Nech a>b, a=b*q+r ->ax-by=(bq+r)x-by = rx -b(y-qx)=1
						<br>nech b>a, b=a*q+r ->ax-by=ax-(aq+r)y = a(x-qy)-ry=1
						<br>trivialne riešenia sú ak a*b=0 alebo (a-1)*(b-1)=0)
		</dl>
 	<dt class=second>Otázky
	<dd><ol><li>Èo je rekurzia
			<li>Preèo nemôe rekurzia vytvori nekoneènú smyèku
			<li>Ako by ste riešili úlohu Hanojskıch veí
		</ol>	
	</dl>		
</body>
</html>
