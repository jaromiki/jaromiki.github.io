<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
	 <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1250">
 	 <meta name="Content-language" content="sk">	
	  <LINK href="../css/style.css" type="text/css" rel=stylesheet>
</head>

<body>
<h3>Preaovanie operátorov</h3>
S pojmom preaovanie/prekrıvanie operátorov sme sa stretli v èasti Programujeme->preaovanie. V prípade tried sa prekrıvanie (najmä aritmetickıch operátorov)
pouíva dos èasto. Napríklad vytvoríme triedu zlomok a je vıhodné ma definované základné aritmetické operátory +, -, *,/
<br>Návratová hodnota operátora bıva èasto tie typu class ale môe by ¾ubovo¾ná.
<br>Pripomenieme si obmedzujúce pravidlá pre preaovanie operátorov:
<ul><li>priorita operátorov sa nedá meni
	<li>poèet operandov operátora sa nedá meni
	<li>operátor ? sa nedá preaova
</ul>
<dl><dt class="main">Preaovanie binárnych operátorov
	<dd>Vytvoríme triedu <b>zlomok</b> a zadefinujeme operátor + (plus) na súèet dvoch zlomkov. Urobi to môme
		<ul><li>èlenskou funkciou triedy
			<li>priate¾skou fukciou triedy
		</ul>	
	<dl><dt>Pomocou èlenskej triedy 
		<dd>- prekvapujúco bude ma binárny operátor len jeden argument (prvı argument bude aktuálna trieda)
			<table width="60%" bgcolor="#cccccc" border="2" bordercolor="#cccccc" bordercolordark="#999999" bordercolorlight="ffffff">
			<tr><th bgcolor=#99aaff align="left"> Unit1.cpp</th></tr>
			<tr><td>
<pre>#include &lt;iostream>
using namespace std;
class zlomok
{ int c,m;
  int nsd(int a, int b) {while (a!=b) if (a>b) a-=b; else b-=a; return a;}
  public:
  void normuj() {if (c*m) {int p= (c*m?nsd(abs(c), abs(m)):1); c/=p; m/=p;}}
  zlomok (int cc, int mm) {c=cc; m=mm; if (c*m) normuj();}
  zlomok () {c=1; m=1;}
  int get_c() {return c;}
  int get_m() {return m;}
  zlomok operator+(zlomok &amp;xx)
  {   zlomok temp;
      temp.c = c*xx.m + m*xx.c;
	  temp.m = m*xx.m;
	  temp.normuj();
	  return temp;
   }
};
int main()
{  zlomok x(4,12), y(1,2),z;
   z = x+y;
   cout &lt;&lt; z.get_c() &lt;&lt;'/' &lt;&lt; z.get_m() &lt;&lt; endl;
   cin.get();
   return 0;
}</pre>
			</tr></table>
			<b>Poznámky:</b>
			<br>Preaenı operátor + je naprogramovanı tak, aby nemenil iadny operand. Pre návratovú adresu teda bolo treba vytvori pomocnú premennú temp.
			<br>Preaenı operátor + je naprogramovanı tak, e ¾avı operand predáva funkciu a pravı operand je predávanı ako parameter tej funkcie
			<br>Preaenı operátor + je naprogramovanı tak, e parameter je predávanı referenciou (adresou), èo je rıchlejšie ako hodnotou, navyše nie je volanı deštruktor, ktorı môe robi problémy
			<br>Nako¾ko vısledok súètu je opä zlomok, mono sèitovanie reazi z = x+x+y;
			<br>Súèet mono poui aj nasledovne:
			<br> &nbsp; &nbsp; &nbsp;cout &lt;&lt; (x+y).get_c
			<br><b>Úlohy:</b>
			<ul><li>Naprogramuj operátor + na pripoèítanie celého èísla 
					<br> &nbsp; &nbsp; &nbsp;(pre èlenskú funkciu dokáeme poèíta vırazy: zlomok + int, zlomok + double) 
					<br> &nbsp; &nbsp; &nbsp;(pre priate¾skú funkciu dokáeme poèíta aj vırazy: int + zlomok, double + zlomok) 
			    <li>Naprogramuj ku triede zlomok ešte operátory -,*,/
			</ul>
		<dt>Pomocou priate¾skej funkcie
		<dd>Tento postup je èastejší a logickejší. Funkcia bude ma dva operátory tzpu zlomok a bude typu zlomok
			<table width="60%" bgcolor="#cccccc" border="2" bordercolor="#cccccc" bordercolordark="#999999" bordercolorlight="ffffff">
			<tr><th bgcolor=#99aaff align="left"> Unit1.cpp</th></tr>
			<tr><td>
<pre>#include &lt;iostream>
using namespace std;
class zlomok
{ int c,m;
  int nsd(int a, int b) {while (a!=b) if (a>b) a-=b; else b-=a; return a;}
  public:
  void normuj() {if (c*m) {int p= (c*m?nsd(abs(c), abs(m)):1); c/=p; m/=p;}}
  zlomok (int cc, int mm) {c=cc; m=mm; if (c*m) normuj();}
  zlomok () {c=1; m=1;}
  int get_c() {return c;}
  int get_m() {return m;}
  friend zlomok operator+(zlomok &amp;xx, zlomok &amp;yy)
  {   zlomok temp;
      temp.c = yy.c*xx.m + yy.m*xx.c;
	  temp.m = yy.m*xx.m;
          temp.normuj();
	  return temp;
   }
};
int main()
{  zlomok x(4,12), y(1,2),z;
   z = x+y;
   cout &lt;&lt; z.get_c() &lt;&lt;'/' &lt;&lt; z.get_m() &lt;&lt; endl;
   cin.get();
   return 0;
}</pre>
			</tr></table>
		<dt>Preaovanie operátora =
		<dd>Rozdiel medzi operátormi +,-,*,/ a operátorom = je ten, e operátor mení hodnotu v ¾avom argumente
			<br>Uvediem len preaenı operátor
			<table width="60%" bgcolor="#cccccc" border="2" bordercolor="#cccccc" bordercolordark="#999999" bordercolorlight="ffffff">
			<tr><th bgcolor=#99aaff align="left"> Unit1.cpp</th></tr>
			<tr><td>
<pre>zlomok operator=(zlomok &amp;xx)
 {   c = xx.c;
     m = xx.m;
	 return *this;
 }
 //alebo pre priate¾skú funkciu by to vyzeralo nasledovne
friend zlomok operator=(zlomok &amp;xx, zlomok &amp;yy)
 {   xx.c = yy.c;
     xx.m = yy.m;
	 return xx;
 }</pre>
			</tr></table>
						<b>Poznámky:</b>
						<br>Preaenı operátor = je naprogramovanı tak, aby menil ¾avı operand. Návratová hodnota je aktuálny class (¾avı argument po priradení) aby sme mohli priradenie reazi.
		<dt>Preaovanie relaènıch operátorov
		<dd>Na rozdiel od predošlıch operátorov návratová hodnota nebude zlomok ale bool resp int
			<br>Uvediem len definíciu preaeného operátora
			<table width="60%" bgcolor="#cccccc" border="2" bordercolor="#cccccc" bordercolordark="#999999" bordercolorlight="ffffff">
			<tr><th bgcolor=#99aaff align="left"> Unit1.cpp</th></tr>
			<tr><td>
<pre>int operator==(zlomok &amp;xx)
 {  
	 return c==xx.c &amp;&amp; m==xx.m;
 }
 //alebo pre priate¾skú funkciu by to vyzeralo nasledovne
friend int operator==(zlomok &amp;xx, zlomok &amp;yy)
 {   return yy.c==xx.c &amp;&amp; yy.m==xx.m;
 }</pre>
			</tr></table>


			
	</dl>
</dl>	
</body>
</html>
