<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
	 <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1250">
	 <meta name="Content-language" content="sk">	
	  <LINK href="css/style.css" type="text/css" rel=stylesheet>
	<title>Mysql-SELECT</title>

</head>

<body >
<h2>SELECT - vıber dát z databázy</h2>
Na akéko¾vek získavanie údajov slúi jedinı príkaz – SELECT.
<br><br>SELECT slúi na zobrazenie èohoko¾vek. Môete napríklad napísa
<br><b>SELECT 1 + 1;</b>
<br>alebo
<br><b>SELECT 2 * PI() * 5;</b>
a v oboch prípadoch dostanete správnu odpoveï. Tieto príklady sa ale ve¾mi nevzahujú
k tabu¾kám, ktoré naša databáza spravuje. Najjednoduhšia forma príkazu SELECT, ktorá sa tıka databázy má tvar: 
<br><b>SELECT * FROM klienti;</b>
<br>Hviezdièka má v tomto príkaze vıznam „úplne všetko“. Nie vdy má ale zmysel vypisova úplne všetko. 
Keby sme napríklad chceli iba mennı zoznam klientov kninice usporiadanı pod¾a abecedy, pouili by sme príkaz
<br><b>SELECT meno, priezvisko FROM klienti ORDER BY priezvisko, meno;</b>
Namiesto všetkıch kolóniek sa teraz budú vypisova iba dve. Príkazom ORDER BY dávame
serveru najavo, e vısledky chceme ma usporiadané pod¾a priezvisk a v prípade rovností priezvisk
pod¾a mien. V prípade, e by sme takıto príkaz chceli vykonáva èasto nad ve¾kou tabu¾kou, je
vhodné spravi si index, pod¾a ktorého chceme triedi/vypisova.
<br>V niektorıch situáciach by sa vám mohlo hodi, aby vısledok funkcie SELECT nebol
v dvoch ståpcoch, ale v jednom. Niè nám nebráni poui funkciu CONCAT, ktorá spája reazce, ktoré
jej zadáte do jednoho. Príkaz môe vyzera napríklad takto:
<br><b>SELECT CONCAT(meno," ",prezvisko) FROM klienti ORDER BY priezvisko, meno;</b>
<br>Keby ste chceli, aby databázovı stroj nevrátil všetky vısledky (napríklad preto, lebo chcete
zobrazi vısledky na webovej stránke a všetky sa na stránku nezmestia), môete to zariadi
príkazom LIMIT. Napríklad príkaz
<br><b>SELECT nazov FROM knihy ORDER BY nazov LIMIT 40, 10;</b>
<br>Vypíše z tabu¾ky kníh 10, prièom zaène štyridsiatou. Vısledky funkcie SELECT sú èíslované ako v Cèku,
to znamená, e na zaèiatku je nultı vısledok. Keby sme chceli z tabu¾ky klientov vypísa všetkıch bratislavèanov, spravili by sme to príkazom
<br><b>SELECT meno,priezvisko FROM klienti WHERE bydlisko_obec="Bratislava";</b>
<br>a ak chceme všetky knihy, ktoré majú v názve SQL, spravíme to takto:
<br><b>SELECT knihy.nazov FROM knihy WHERE knihy.nazov LIKE "%SQL%";</b>
<br>A koneène sa dostávame k tomu, preèo sa databázy ovládané SQL jazykom nazıvajú
relaèné databázy. Všetky príkazy SELECT sa doteraz tıkali jednej jedinej tabu¾ky. Lene medzi
tabu¾kami môu by zloité vzahy a my chceme zachyti tie vztahy medzi tabu¾kami. Príkaz SELECT je ale schopnı vyh¾adáva 
vo viacerıch tabu¾kách naraz. Zaèneme nieèim jednoduchım. Napríklad chceme zoznam názvov kniiek aj
s autormi. Názvy kniiek sú v inej tabu¾ke, ne mená autorov. SELECT bude teda musie èíta obe
tabu¾ky a priradi správneho autora k správnej knike. Spraví sa to takto:
<br><b>SELECT autori.meno, knihy.nazov FROM knihy, autori WHERE knihy.autor_id = autori.autor_id;</b>
<br>Ako to vlastne funguje? Skúste zada databáze ten istı príkaz, ale bez èasti WHERE. Zistíte, e vám
vypíše kadého autora s kadou knikou. No a èas WHERE spôsobí, e sa z tejto masy vypíšu iba
tie veci, kde je èíslo autora z tabu¾ky kníh rovnaké ako èíslo autora z tabu¾ky autorov.
Teraz nieèo kúsok zloitejšie. Potrebujeme zoznam všetkıch hororov, ktoré máme
v kninici. Spraví sa to takto:
<br><b>SELECT knihy.nazov FROM knihy,kategorie WHERE knihy.kategoria_id = kategorie.kategoria_id AND kategorie.nazov = "Horor";</b>
<br>Keby sme poznali èíslo kategórie „horor“, vystaèili by sme aj so selectom, ktorı by pristupoval iba
k tabu¾ke knihy. To však bene nevieme, lebo to bıva vnútornou záleitosou databázy.
Ïalšia úloha – potrebujeme zisti mená ¾udí, ktorí majú nejaké poièané knihy a to, aké
knihy majú poièané. Príkaz bude vyzera takto:
<br><br><b>SELECT klienti.meno, klienti.priezvisko, knihy.nazov FROM knihy,klienti,pozicky
<br>WHERE pozicky.klient_id = klienti.klient_id
<br>AND pozicky.kniha_id=knihy.kniha_id
<br>AND pozicky.datum_uzatvorenia IS NULL;</b>
<br><br>Všimnite si, e aj keï tabu¾ka pozicky nesie v tomto prípade podstatnú informáciu, iadne dáta
priamo z nej sa nevypisujú – za príkazom SELECT nasledujú len kolónky z tabuliek klienti a knihy.
Príkaz select polia vyberá sa pod¾a ståpcov, ktoré sú oddelené èiarkou. Ak chceme vybra všetky ståpce môeme poui znak *. 
<em>Syntax:</em>
<p>
  SELECT zoznam_poloziek FROM nazvy_tabuliek &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>//povinná èas</em><br />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE podmienky<br />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GROUP BY nazov_stlpca_pre_zoskupenie<br />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HAVING skupinova_podmienka<br />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ORDER BY polozka;
	<!--  <em>//komentar</em><br />   -->  
</p>

<em>Príklad:</em>
<p>
  SELECT * FROM udaje;
</p>
<table width="50%" border="1"> 
  <tr> <th>id<th>meno<th>priezvisko<th>vek<th>telefon </tr>
  <tr><td>1<td>Maria<td>Mala<td>21<td>0907876900</tr>
  <tr><td>2<td>Jozko<td>Stary<td>25<td>0902002223</tr>   
  <tr><td>3<td>Ema<td>Balazova<td>45<td>0904145623</tr>    
  <tr><td>4<td>Maria<td>Novakova<td>24<td>0902057357</tr>   
  <tr><td>5<td>Jan<td>Novak<td>37<td>0904666456</tr> 
</table><br />
<!--  ////////////////////////////////////////////////////////////////   -->
<h2>DISTINCT</h2>
<p>Aby sme zabránili  opakovaniu hodnôt, hneï za SELECT vloíme k¾úèové slovo <code>DISTINCT</code>.</p>
<em>Príklad:</em>
<p>
  SELECT DISTINCT meno FROM udaje;
</p>
<table width="15%" border="1" > 
  <tr><th>meno</tr>
  <tr><td>Jozko</tr>
  <tr><td>Maria</tr>   
  <tr><td>Ema</tr>
  <tr><td>Jan</tr>  
</table><br />
<em>Príklad:</em>
<p>
  SELECT COUNT(DISTINCT meno) as pocet_roznych_mien FROM udaje;
	<em>//Vıstup: 5</em>  
</p>
<p>Ak je ståpcov èi vırazov viac <code>DISTINCT</code> musí nasledova bezprostredne za slovom SELECT a h¾adajú sa rôzne riadky ako celky, nie jednotlivé ich èasti.</p><br />
<h2>WHERE</h2>
<p>Príkaz <code>WHERE</code> vyberie len tie záznamy, ktoré vyhovujú podmienke, ostatné záznamy sa ignorujú.<br />
V podmienke môu by operácie:</p>
<ul>
<li>s textovım reazcom (rovnos, nerovnos, podobnos),</li>
<li>matematické (rovnos, nerovnos, väèší ne, menší ne),</li>
<li>logické (AND, OR, NOT).</li>
</ul>
<em>Príklad:</em>
<p>
  SELECT meno, priezvisko, vek FROM udaje WHERE vek > 25;
</p>
<table width="30%" border="1"> 
  <tr> <th>meno<th>priezvisko<th>vek</tr>
  <tr><td>Ema<td>Balazova<td>45</tr>   
  <tr><td>Jan<td>Novak<td>37</tr>   
</table>
<p>Ak by sme chceli porovnáva urèitú hodnotu s hodnotou NULL pomocou porovnávacích operátorov nemalo by to zmysel. Take nasledujúci dotaz nemá v princípe iadny zmysel, pretoe sa snaíme porovna ståpec a neznámu hodnotu:</p>
<em>Príklad:</em>
<p>
  SELECT meno, priezvisko, vek FROM udaje WHERE vek > NULL;
</p>
<p>Pouitím vırazu <code>IS NULL</code> bude všetko v poriadku.</p>
<em>Príklad:</em>
<p>
  SELECT meno, priezvisko, vek FROM udaje WHERE vek IS NULL;
</p>
<p>V súvislosti <code>WHERE</code> a <code>NULL</code> môe nasta ešte jeden problém. V prípade, e chceme vypísa všetky osoby v tabu¾ke a zadali by sme nasledovnı príkaz:</p>
<em>Príklad:</em>
<p>
  SELECT meno, priezvisko, vek FROM udaje WHERE vek > 20;
	<!--  <em>//komentar</em><br />   -->  
</p>
<p>môe ale aj nemusí vypísa. Ak ståpec vek nesmie obsahova hodnoty NULL je všetko v poriadku. Ale ak hodnoty NULL môe obsahova a nachádza sa v tabu¾ke záznam s hodnotou NULL nevypíšu sa všetky osoby. Nasledovnım príkazom sa vyrieši aj tento problém.</p>
<em>Príklad:</em>
<p>
  SELECT meno, priezvisko, vek FROM udaje WHERE vek > 20 or vek IS NULL;
</p><br />
<!--  ////////////////////////////////////////////////////////////////   -->
<h2>GROUP BY</h2>
<p>Nie vdy nás zaujíma agregovaná hodnota v rámci celej tabu¾ky. Niekedy potrebujeme hodnoty v rámci nejakej podskupiny. <code>GROUP BY</code> slúi k tomu, aby zlúèila záznamy, ktoré obsahujú rovnaké hodnoty do jedného záznamu, prípadne jednej hodnoty.</p>

<em>Príklad:</em><br />
<p>Ak by sme chceli zisti zastúpenie jednotlivıch mien v našej tabu¾ke pouijeme nasledovnı príkaz:</p>
<p>
  SELECT meno, count(meno) as 'pocet' FROM udaje GROUP BY meno;
</p>

<table width="25%"> 
  <tr> <th>meno<th>pocet</tr>
  <tr> <td>Maria<td>2</tr>
  <tr> <td>Jozko<td>1</tr>   
  <tr> <td>Ema<td>1</tr>
  <tr> <td>Jan<td>1</tr>  
</table>

<p>Vznikol nám novı ståpec, ktorı nám urèuje poèet vıskytov jednotlivıch mien v tabu¾ke. Nadpis tohoto po¾a by bol "count(meno)" a preto sme ho pomocou <code>as</code> premenovali na "pocet".</p><br /> 
<!--  ////////////////////////////////////////////////////////////////   -->
<h2>HAVING</h2>
<p>Niekedy potrebujeme v rámci zoskupenıch záznamov vybra len tie záznamy, ktoré budú spåòa ïalšie podmienky. Pouitím príkazu <code>HAVING</code> obmedzíme rozsah vıpisu tabu¾ky tım, e z agregovanıch riadkov vyradíme tie, ktoré nevyhovujú uvedenej podmienke.</p>

<em>Príklad:</em><br />
<p>Vypíšeme si len tie mená, ktorıch poèet je väèší ako jedna.</p>
<p>
  SELECT meno, count(meno) as 'pocet' FROM udaje GROUP BY meno HAVING count(meno)>1;
</p>
<table width="25%"> 
  <tr><th>meno<th>pocet</tr>
  <tr><td>Maria<td>2</tr>
</table><br />
<h2>ORDER BY</h2>
<p>Pre vzostupné zoradenie údajov v tabu¾ke pod¾a urèitého ståpca slúi príkaz <code>ORDER BY</code>.</p>

<em>Príklad:</em>
<p>
  SELECT * FROM udaje ORDER BY priezvisko;
</p>

<table width="50%"> 
  <tr> <th>id<th>meno<th>priezvisko<th>vek<th>telefon</tr>
  <tr><td>3<td>Ema<td>Balazova<td>45<td>0904145623</tr> 
  <tr> <td>1<td>Maria<td>Mala<td>21<td>0907876900</tr>
  <tr> <td>5<td>Jan<td>Novak<td>37<td>0904666456</tr> 
  <tr> <td>4<td>Maria<td>Novakova<td>24<td>0902057357</tr>
  <tr> <td>2<td>Jozko<td>Stary<td>25<td>0902002223</tr>   
</table>

<p>Pokia¾ by sme chceli zoradi tabu¾ku zostupne pouijeme príkaz <code>DESC</code>.</p>
<em>Príklad:</em>
<p>
  SELECT * FROM udaje ORDER BY priezvisko DESC;
</p><br />

<h2>LIMIT</h2>
<p>Ak si myslíme, e vıpis príkazu SELECT by mohol by ve¾mi dlhı a chceli by sme ho obmedzi na poèet prvıch x-riadkov, pouijeme k¾úèové slovo <code>LIMIT</code> na konci príkazu. Parameter n je offset a znaèí, od ktorého nasledujúceho riadku bude vıpis pokraèova a parameter m znaèí maximum vypísanıch riadkov.</p>
<em>Syntax:</em>
<p>
  SELECT zoznam_poloziek FROM nazov_tabulky WHERE podmienka LIMIT n[, m];
</p>
<em>Príklad:</em>
<p>
  SELECT * FROM udaje WHERE meno='Maria' LIMIT 1;
</p>
<table width="50%" border="1"> 
  <tr><th>id<th>meno<th>priezvisko<th>vek<th>telefon</tr>
  <tr><td>2<td>Maria<td>Mala<td>21<td>0907876900</tr>
</table>
</div>
</body>
</html>
